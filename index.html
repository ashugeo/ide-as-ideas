<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mémoire Hugo Sainte-Marie</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
  <link rel="stylesheet" href="css/main.min.css" />
  <script src="js/jquery-3.2.1.min.js"></script>
  <script src="js/main.js"></script>
  <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
</head>

<body class="stackedit">
  <div class="stackedit__left">
    <div class="stackedit__toc">
      
<ul>
<li><a href="#design-et-systèmes-décriture-algorithmique">Design et systèmes d’écriture algorithmique</a></li>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#algorithmes">Algorithmes</a>
<ul>
<li><a href="#quest-ce-quun-algorithme-">Qu’est-ce qu’un algorithme ?</a>
<ul>
<li><a href="#instructions-et-résultat">Instructions et résultat</a></li>
<li><a href="#les-algorithmes-symboliques">Les algorithmes symboliques</a></li>
</ul>
</li>
<li><a href="#approche-technico-historique">Approche technico-historique</a>
<ul>
<li><a href="#de-la-main-à-la-machine">De la main à la machine</a></li>
<li><a href="#jacquard-ou-le-tissage-programmé">Jacquard, ou le tissage programmé</a></li>
<li><a href="#la-machine-analytique-de-babbage">La machine analytique de Babbage</a></li>
<li><a href="#la-révolution-turing">La révolution Turing</a></li>
<li><a href="#les-intelligences-artificielles">Les intelligences artificielles</a></li>
</ul>
</li>
<li><a href="#approche-fondamentale">Approche fondamentale</a>
<ul>
<li><a href="#séquence">Séquence</a></li>
<li><a href="#affectation">Affectation</a></li>
<li><a href="#itération">Itération</a></li>
<li><a href="#condition">Condition</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#écritures-algorithmiques">Écritures algorithmiques</a>
<ul>
<li><a href="#quest-ce-que-lécriture-">Qu’est-ce que l’écriture ?</a>
<ul>
<li><a href="#écriture-et-langage">Écriture et langage</a></li>
<li><a href="#types-décritures">Types d’écritures</a></li>
<li><a href="#écritures-alternatives">Écritures alternatives</a></li>
</ul>
</li>
<li><a href="#lécriture-informatique">L’écriture informatique</a>
<ul>
<li><a href="#de-lalgorithme-au-programme">De l’algorithme au programme</a></li>
<li><a href="#de-lordinateur-à-linformatique">De l’ordinateur à l’informatique</a></li>
<li><a href="#langages-naturels-et-langages-formels">Langages naturels et langages formels</a></li>
<li><a href="#langages-informatiques">Langages informatiques</a></li>
</ul>
</li>
<li><a href="#systèmes-décriture-algorithmique">Systèmes d’écriture algorithmique</a>
<ul>
<li><a href="#environnements-de-développement-et-workflow">Environnements de développement et workflow</a></li>
<li><a href="#lignes-de-code-règles-et-conventions">Lignes de code, règles et conventions</a></li>
<li><a href="#programmation-visuelle">Programmation visuelle</a></li>
<li><a href="#modes-singuliers-de-programmation-algorithmique">Modes singuliers de programmation algorithmique</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#algorithmes-et-design">Algorithmes et design</a>
<ul>
<li><a href="#la-place-du-designer">La place du designer</a>
<ul>
<li><a href="#rapport-de-lhomme-à-la-machine">Rapport de l’homme à la machine</a></li>
<li><a href="#créer-ses-outils">Créer ses outils</a></li>
</ul>
</li>
<li><a href="#contextes-dapplication">Contextes d’application</a>
<ul>
<li><a href="#problématiques-possibles">Problématiques possibles</a></li>
<li><a href="#quel-environnement-quel-terrain-">Quel environnement, quel terrain ?</a></li>
<li><a href="#deux-approches">Deux approches</a></li>
</ul>
</li>
</ul>
</li>
</ul>

    </div>
  </div>
  <div class="stackedit__right">
    <div class="stackedit__html">
      <h1 id="design-et-systèmes-décriture-algorithmique">Design et systèmes d’écriture algorithmique</h1>
<h1 id="introduction">Introduction</h1>
<p>Au fil des dernières années, les algorithmes sont entrés dans nos vies, à tel point qu’on les rencontre aujourd’hui partout, sans même s’en apercevoir. Dans leur ouvrage “<em>Le temps des algorithmes</em>”, Serge Abiteboul et Gille Dowek<sup class="footnote-ref"><a href="#fn1" id="fnref1">1</a></sup> établissent une liste d’usages variés qui existent aujourd’hui sous forme de programmes embarqués dans nos équipements numériques :</p>
<ul>
<li>le calcul : transformer des données – généralement des nombres –, résoudre des équations algébriques, encoder ou décoder un message ;</li>
<li>la gestion de l’information : stocker, archiver et indexer des données ;</li>
<li>la communication : faire circuler l’information via des <em>protocoles</em> de communication ;</li>
<li>l’exploration : parcourir un grand nombre de possibilités afin de définir celle qui correspond le mieux à un problème donné – plus court chemin, meilleure répartition, etc. On appelle aussi cette méthode la recherche exhaustive ou “recherche par force brute” (<em>brute force</em> en anglais)<sup class="footnote-ref"><a href="#fn2" id="fnref2">2</a></sup> ;</li>
<li>l’analyse des données : agréger des statistiques et les classifier, afin par exemple de prédire des comportements – suggestions, recommandations ou encore publicité ciblée grâce au <em>big data</em><sup class="footnote-ref"><a href="#fn3" id="fnref3">3</a></sup> ;</li>
<li>mais aussi : le traitement du signal (transformer, amplifier ou compresser une image ou un son), la commande d’un objet (établir la conduite d’une voiture autonome à partir des données captées), la fabrication de biens (automatiser la production industrielle), la modélisation et la simulation (dans la recherche scientifique, en établissant des théories), etc.</li>
</ul>
<p>La présence croissante des algorithmes dans nos vies peut soulever des craintes – plus ou moins justifiées – et en font aujourd’hui un objet de débat politique. Dans ce contexte, on tend toutefois à oublier une caractéristique fondamentale : les algorithmes sont écrits par des êtres humains. Les programmes que nous utilisons au quotidien sont ou ont été développés par des développeurs, qui emploient des outils spécifiques à leur tâche. Ce sont ces outils qui forment le domaine d’étude précis de ce mémoire, avec – inévitablement – une approche de design, c’est-à-dire centrée sur les utilisateurs et les usages.<sup class="footnote-ref"><a href="#fn4" id="fnref4">4</a></sup></p>
<p>J’aborde ce sujet en assumant une démarche très empirique : je fais partie de ces personnes qui doivent expérimenter pour comprendre. Compte tenu de la dimension relativement technique de l’écriture algorithmique, sa pratique constitue pour moi l’approche de recherche en design la plus adaptée à mon profil, et permet de concrétiser l’étude en proposant des solutions applicatives.</p>
<h1 id="algorithmes">Algorithmes</h1>
<h2 id="quest-ce-quun-algorithme-">Qu’est-ce qu’un algorithme ?</h2>
<h3 id="instructions-et-résultat">Instructions et résultat</h3>
<p>Un algorithme est une suite finie d’instructions qui vise à être exécutée afin de produire un résultat. Le terme instruction, pour sa part, suggère une double définition : il s’agit à la fois de l’action de disposer – mettre quelque chose dans un disposition en vue d’un résultat, telle l’instruction militaire –, et, dans un sens métonymique, d’un discours indiquant <em>ce qui doit être fait</em>. Cette seconde vision, qui fait état de la <em>transmission</em> d’une information, implique une forme de langage – celui-ci peut prendre plusieurs formes, notamment l’écriture.</p>
<p>Pour comprendre ou enseigner la notion d’algorithme, on fait bien souvent appel à des cas concrets que l’on rencontre dans la vie quotidienne. Une recette de cuisine, par exemple, constitue un algorithme : on y trouve des <em>entrées</em> (les ingrédients, quantités, ustensiles utilisés) ainsi que des instructions (casser en morceaux, cuire au bain-marie, couper en dés). Enfin, le résultat obtenu lorsqu’on suit minutieusement cette recette de cuisine est, bien évidemment, le plat préparé. Cette vision nous fournit une première définition du concept d’algorithme, donnée par Abiteboul et Dowek.</p>
<blockquote>
<p>Un algorithme est un procédé qui permet de résoudre un problème, sans avoir besoin d’inventer une solution à chaque fois. Avec cette définition, il est clair que, depuis l’aube de l’humanité, nous inventons, utilisons et transmettons des algorithmes : cuisine, taille du silex, pêche à la ligne, culture des lentilles et du blé, etc.<sup class="footnote-ref"><a href="#fn5" id="fnref5">5</a></sup></p>
</blockquote>
<h3 id="les-algorithmes-symboliques">Les algorithmes symboliques</h3>
<p>Dans cette définition générique de la notion d’algorithmes s’inscrit une catégorie spécifique plus réduite, un ensemble que l’on nomme <em>algorithmes symboliques</em>. Par abus de langage et en raison de notre contexte technologique contemporain, la notion d’algorithmes symboliques a presque remplacé celle, plus générique, d’algorithmes : l’informatique a orienté l’emploi même du mot. La spécificité des algorithmes symbolique est qu’ils manipulent des symboles écrits : chiffres, lettres, assemblés en nombres, en mots et en phrases, et vecteurs de sens. Étymologiquement, le terme <em>algorithme</em> est d’ailleurs issu de la combinaison du mot latin <em>algorismus</em> – dérivé du nom du mathématicien Al-Khwarizmi<sup class="footnote-ref"><a href="#fn6" id="fnref6">6</a></sup> – et du mot grec <em>arithmos</em>, qui signifie “nombre”. Cette proximité entre les notions d’algorithmique et de mathématiques s’est confirmé grâce aux progrès techniques des deux siècles passés.</p>
<h2 id="approche-technico-historique">Approche technico-historique</h2>
<h3 id="de-la-main-à-la-machine">De la main à la machine</h3>
<p>Remontons aux origines des algorithmes symboliques, il y a 5&nbsp;000 ans. À cette époque, les mathématiciens ont déjà mis au point des algorithmes servant à résoudre des calculs algébriques simples tels que des additions et des multiplications, mais ceux-ci sont exécutés à la main par les scribes. Des tâches répétitives qu’on aurait tout intérêt à déléguer aux machines, afin que celles-ci s’effectuent <em>mécaniquement</em>.</p>
<p>S’ensuivent cinq millénaires d’innovations techniques. Les premiers abaques<sup class="footnote-ref"><a href="#fn7" id="fnref7">7</a></sup>, suivis quelques siècles plus tard de leurs proches dérivés, les bouliers, assistent les hommes dans ces calculs mais ne sont pas encore autonomes. Au Moyen Âge, les cloches au sommet des cathédrales sonnent chaque heure sans intervention humaine : ce sont les premières machines capables d’exécuter des algorithmes symboliques. En 1642, l’inventeur français Blaise Pascal<sup class="footnote-ref"><a href="#fn8" id="fnref8">8</a></sup> met au point la première machine à calculer, qu’il nomme “machine arithmétique” ; elle est retravaillée quelques 30 ans plus tard par Gottfried Leibniz<sup class="footnote-ref"><a href="#fn9" id="fnref9">9</a></sup> qui y ajoute une interface permettant de réaliser de façon automatique des multiplications et des divisions.</p>
<h3 id="jacquard-ou-le-tissage-programmé">Jacquard, ou le tissage programmé</h3>
<p>En 1801, l’inventeur lyonnais Joseph Jacquard met au point un système de métier à tisser qui portera son nom : le fameux “métier Jacquard”. Celui-ci combine les métiers à tisser classiques avec le principe de cartes perforées inventé en 1728 par Jean-Baptiste Falcon – qui lui-même reprenait l’idée des rubans perforés que Basile Bouchon, son maître, proposait trois ans plus tôt. En perçant ou non un trou à un emplacement spécifique d’une carte, on peut programmer la machine : une fois insérée en <em>entrée</em> de la machine,  les cartes guident les crochets qui soulèvent les “fils de chaînes” – dont l’agencement produit le motif sur le textile tissé. Ce dispositif est souvent considéré comme la première forme de stockage d’informations binaires (<em>tout</em> ou <em>rien</em>, <em>vrai</em> ou <em>faux</em>), et le métier Jacquard comme l’ancêtre de l’ordinateur.</p>
<p>Mais ces machines ne sont pas encore des ordinateurs à proprement parler. Il leur manque pour atteindre ce statut une caractéristique majeure : l’universalité. En effet,  les machines cités plus haut en exemples sont chacune destinée à une unique fonction ; là où un ordinateur est polyvalent, <em>universel</em>, capable d’exécuter n’importe quel algorithme symbolique imaginable : en résumé, une “machine à tout faire”.</p>
<h3 id="la-machine-analytique-de-babbage">La machine analytique de Babbage</h3>
<p>Au cours du XX<sup>ème</sup> siècle, l’apparition des premières <em>machines analytiques</em> va transformer les usages des algorithmes. En 1834, le visionnaire britannique Charles Babbage<sup class="footnote-ref"><a href="#fn10" id="fnref10">10</a></sup> débute le développement d’une machine d’un concept alors nouveau, qu’il qualifie de “machine analytique”. Celle-ci reprend le principe des machines à calculer mécaniques qui existent alors depuis plusieurs siècles déjà. Mais l’inventeur a l’idée d’ajouter à ces systèmes le principe des cartes perforées apparues avec les métiers Jacquard. Les composants de cette machine sont similaires à ceux qui équipent un ordinateur moderne.</p>
<blockquote>
<ul>
<li>un dispositif d’entrée comporte deux lecteurs de cartes perforées (instructions et données) ; ces cartes sont issues des techniques du métier à tisser.</li>
<li>un organe de commande gère le transfert des nombres et leur mise en ordre pour le traitement ;</li>
<li>un moulin est chargé d’exécuter les opérations sur les nombres ;</li>
<li>un magasin permet de stocker les résultats intermédiaires ou finaux ;
trois types d’imprimantes sont prévus.<sup class="footnote-ref"><a href="#fn11" id="fnref11">11</a></sup></li>
</ul>
</blockquote>
<p>Pendant qu’il travaille sur ce projet, Babbage entre en correspondance avec Ada Lovelace. Pionnière de la science informatique, c’est elle qui, en 1843, sera à l’origine du premier algorithme destiné à être exécuté sur une machine : la machine à différences de Charles Babbage. Cet algorithme, considéré comme le premier programme informatique à proprement parler, sert alors à calculer la suite des nombres de Bernouilli<sup class="footnote-ref"><a href="#fn12" id="fnref12">12</a></sup>. Ada Lovelace est ainsi connue comme la première programmeuse de l’histoire.</p>
<h3 id="la-révolution-turing">La révolution Turing</h3>
<p>Les travaux de Lovelace et Babbage trouvent écho un siècle plus tard, dans les années 1930, grâce notamment aux recherches d’Alan Turing<sup class="footnote-ref"><a href="#fn13" id="fnref13">13</a></sup>. Cet inventeur, figure emblématique de la recherche mathématico-scientifique du XX<sup>ème</sup> siècle, conçoit en 1936 la “machine de Turing”, en vue de donner une définition précise au concept d’algorithme et à sa représentation formelle et technique de “procédure mécanique”.</p>
<blockquote>
<p>[La machine de Turing] consiste en deux éléments principaux :</p>
<ol>
<li>une machine représentée par une tête de lecture/écriture susceptible de se trouver dans un nombre fini d’états,</li>
<li>une bande (magnétique par exemple) de longueur infinie […] devant laquelle se meut la tête de lecture et qui alimente en données cette machine. […]</li>
</ol>
<p>Turing montre qu’une partie de la bande peut contenir la description de la table d’actions élémentaires d’une autre machine de Turing : une machine peut en simuler une autre. C’est grâce à cette construction schématique […] que Turing peut démontrer qu’il existe des machines de Turing dites universelles capables d’imiter toute autre machine de Turing. <sup class="footnote-ref"><a href="#fn14" id="fnref14">14</a></sup></p>
</blockquote>
<p>Turing illustre ainsi la notion d’<em>universalité</em> telle qu’elle avait été formulée par Lovelace et Babbage. La machine de Turing universelle est considérée comme la genèse des travaux de John von Neumann, qui en 1945 propose un modèle utilisé encore aujourd’hui dans nos ordinateurs modernes : l’architecture de von Neumann.</p>
<blockquote>
<p>L’architecture de von Neumann décompose l’ordinateur en quatre parties distinctes :</p>
<ul>
<li>l’unité arithmétique et logique (UAL) ou unité de traitement, qui effectue les opérations de base ;</li>
<li>l’unité de contrôle, qui est chargée du séquençage des opérations ;</li>
<li>la mémoire, qui contient à la fois les données et le programme qui indique à l’unité de contrôle quels calculs faire sur ces données. La mémoire se divise en mémoire vive (programmes et données en cours de fonctionnement) et mémoire de masse (programmes et données de base de la machine) ;</li>
<li>les dispositifs d’entrées-sorties, qui permettent de communiquer avec le monde extérieur.<sup class="footnote-ref"><a href="#fn15" id="fnref15">15</a></sup></li>
</ul>
</blockquote>
<p>En transposant ces composantes dans notre vocabulaire matériel contemporain, on confirme la proximité entre ce modèle, vieux de plus de 70 ans, et les ordinateurs que nous utilisons au quotidien :</p>
<ul>
<li>le processeur effectue les opérations ;</li>
<li>la mémoire vive (<abbr title="Random Access Memory">RAM</abbr>) stocke les données en cours d’utilisation ; et les disques durs – ou autres supports de stockage – contiennent des données pérennes ;</li>
<li>les périphériques en tout genre permettent l’interaction en <em>entrée</em> (clavier, souris, écran tactile, microphone, caméra, port <abbr title="Universal Serial Bus">USB</abbr>, lecteur de disque, etc.) et en <em>sortie</em> (écran, haut-parleurs, etc.)</li>
</ul>
<h3 id="les-intelligences-artificielles">Les intelligences artificielles</h3>
<p>Contrairement à ce qu’on pourrait penser – notamment en constatant la propagation récente du terme “intelligence artificielle” –, la recherche dans ce domaine ne date pas d’il y a quelques années ou même du début du siècle. En effet, depuis 70 ans déjà, la thèse de Turing – qui suggérait qu’une machine pouvait simuler n’importe quel processus de raisonnement formel à partir de symboles binaires – a amené de nombreux chercheurs en neurologie, informatique et cybernétique<sup class="footnote-ref"><a href="#fn16" id="fnref16">16</a></sup> à considérer la possibilité de créer un cerveau artificiel. En 1950, Turing énonce le fameux “Test de Turing”, un concept de validation d’intelligence artificielle fondée sur la faculté d’une machine à imiter la conversation humaine, en confrontant un être humain à une machine (cachée) et en les faisant simplement discuter : si à la fin de l’exercice, le témoin pense avoir échangé avec une autre personne réelle, alors la machine réussit le test de Turing.<sup class="footnote-ref"><a href="#fn17" id="fnref17">17</a></sup></p>
<p>La recherche en intelligence artificielle est réellement née en 1956. Allen Newell, Herbert Simon, John McCarthy, Marvin Minsky et Arthur Samuel, parmi d’autres participants d’un atelier donné au Dartmouth College à Hanover (États-Unis), sont ainsi devenus les fondateurs et leaders de cette science nouvelle. Leurs premiers travaux rencontrèrent un immense succès auprès de la presse : leurs ordinateurs étaient capables de gagner au jeu de dames contre des joueurs en chair et en os, de résoudre des problèmes algébriques énoncés textuellement, ou encore de composer du texte grammaticalement correct – en somme, de parler anglais<sup class="footnote-ref"><a href="#fn18" id="fnref18">18</a></sup>.</p>
<p>Le domaine de l’intelligence artificielle est extrêmement vaste et met en relation de nombreuses disciplines : informatique, mathématiques, psychologie, linguistique, philosophie, neurosciences, psychologie et bien d’autres encore. Pour cette raison, la question de l’intelligence artificielle ne sera pas traitée en détail ici. Toutefois, pour comprendre l’accroissement inédit de ce domaine au cours de la dernière décennie – et l’explosion médiatique qui en a suivi –, il est important de noter le décalage de notre contexte culturel et technique actuel, par rapport à celui en place aux débuts de la recherche en intelligence artificielle. Celui-ci est notamment lié au phénomène des <em>big data</em> : en équipant de plus en plus de foyers et d’individus d’ordinateurs personnels (au sens large, c’est-à-dire en incluant les équipements comme les smartphones et les tablettes), les plateformes numériques collectent de plus en plus de données sur nos comportements. <sup class="footnote-ref"><a href="#fn19" id="fnref19">19</a></sup> Par ailleurs, l’évolution de notre matériel informatique joue également un rôle essentiel. Les lois de Moore (ou plus strictement “conjonctures de Moore”) caractérisent cette croissance par le fait que le nombre de transistors pour un espace donné (par exemple un centimètre carré) au sein d’un microprocesseurs double approximativement tous les deux ans.<sup class="footnote-ref"><a href="#fn20" id="fnref20">20</a></sup></p>
<p>On trouve dans le champ de l’intelligence artificielle la notion “d’apprentissage machine” (<em>machine learning</em> en anglais). Qu’il soit supervisé – assisté par un être humain qui valide ou non les propositions de la machine – ou non, ce principe permet à des algorithmes d’extraire et analyser des données afin d’y discerner des schémas, structures, ou tout autres éléments constitutifs de catégories. La notion d’apprentissage réside dans le fonctionnement en deux temps de ces programmes : ils doivent d’abord être entraînés avec des échantillons de données “labellisées”, c’est-à-dire accompagnées de l’information que le programme devra ensuite chercher à trouver dans d’autres données. Par exemple en proposant quelques dizaines de photographies de chats – chacune labellisée “chat” – à un algorithme de reconnaissance d’image, celui-ci “apprend” à quoi ressemble un chat et sera capable d’en trouver avec une certitude plus ou moins grande dans d’autres images non labellisées à l’avenir.</p>
<p>Parmi les systèmes et modèles propres à l’apprentissage machine, on trouve notamment les réseaux neuronaux<sup class="footnote-ref"><a href="#fn21" id="fnref21">21</a></sup>. Ceux-ci sont librement inspirés du fonctionnement des neurones biologiques, ceux qui composent le cerveau d’un être vivant – typiquement, des êtres humains.<sup class="footnote-ref"><a href="#fn22" id="fnref22">22</a></sup> Ce nouveau paradigme s’affranchit de la conception classique d’un algorithme, qui jusqu’alors était entièrement conçu par un programmeur : ici, la machine détermine elle-même les moyens et méthodes qu’elle met en jeu afin d’atteindre les objectifs spécifiés. Malgré leur incompréhension des symboles mêmes qu’ils manipulent, ces algorithmes conçoivent, modélisent, simulent et classifient ainsi les données d’une manière obscure pour l’auteur même du programme.</p>
<h2 id="approche-fondamentale">Approche fondamentale</h2>
<p>Les algorithmes se ressemblent : ils sont constitués d’un nombre restreint d’expressions structurantes similaires, que l’on retrouve fréquemment, agencées différemment selon la finalité recherchée. Selon Abiteboul et Dowek, n’importe quel algorithme symbolique peut être exprimé à partir de quatre instructions élémentaires : la séquence, l’affectation, l’itération et la condition.<sup class="footnote-ref"><a href="#fn23" id="fnref23">23</a></sup></p>
<h3 id="séquence">Séquence</h3>
<p>La <em>séquence</em> est l’ordre même dans lequel les instructions sont agencées, c’est-à-dire la structure de l’algorithme elle-même : “fait <em>ceci</em>, puis <em>cela</em>”. Lorsqu’il est représenté – c’est à dire écrit ou dessiné –, on lit classiquement un algorithme de haut en bas, conformément au sens de lecture de nombreux langages. On peut parfois s’émanciper, d’une certaine manière, de cette séquence, notamment en spécifiant expressément à l’algorithme d’éluder une partie des instructions dans certains cas précis. On groupe alors les instructions en ensembles – que l’on peut appeler des <em>fonctions</em> –, auxquels on peut ensuite faire référence. La “tête de lecture”, ou <em>positionnement</em> de l’algorithme à un moment donné de son exécution, ne déroule donc pas nécessairement la structure même cet algorithme de manière linéaire : elle peut effectuer des allers-retours, sauter des parties, y revenir, etc.</p>
<h3 id="affectation">Affectation</h3>
<p>L’affectation est le fait d’attribuer une valeur à une <em>variable</em> – par exemple, “<em>a</em> prend la valeur de <em>b</em>”. Une variable est constituée d’un nom (son identifiant) et d’une valeur unique à chaque instant. Cette valeur peut être numérique (un nombre entier ou décimal, naturel ou relatif), textuelle (un caractère ou une chaîne de caractères) ou encore un booléen : vrai (<em>true</em>) ou faux (<em>false</em>).<sup class="footnote-ref"><a href="#fn24" id="fnref24">24</a></sup> Une variable peut également accueillir un ensemble de données comme un tableau (<em>array</em> en anglais) indexé et/ou associatif. Comme son nom l’indique, une <em>variable</em> peut prendre plusieurs valeurs au cours du temps, à l’exception des constantes – dont la valeur est figée.</p>
<h3 id="itération">Itération</h3>
<p>L’itération, communément appelé <em>boucle</em>, est le fait de répéter une série d’instructions. Ce concept est fondamental, puisque les algorithmes ont généralement pour but d’automatiser des tâches répétitives. On trouve plusieurs types de boucles, en voici une liste non exhaustive :</p>
<ul>
<li>la boucle “pour” (<em>for loop</em> en anglais), qui exécute les instructions pour un nombre donné d’itérations : “répète 10 fois <em>ceci</em>” ;</li>
<li>la boucle “tant que” (<em>while</em> en anglais), qui exécute les instructions tant qu’un énoncé est valide : “tant que <em>ceci</em> est vrai, fait <em>cela</em>” ;</li>
<li>la boucle “pour chaque” (<em>for each</em> en anglais), qui exécute les instructions pour chaque entité d’une liste (des contacts dans un annuaire par exemple) : “<em>pour</em> chaque <em>ceci</em>, fait <em>cela</em>”.</li>
</ul>
<h3 id="condition">Condition</h3>
<p>Enfin, la condition, ou <em>test conditionnel</em>, permet d’effectuer ou non une instruction – ou série d’instructions – selon la valeur d’une variable donnée : par exemple, “si <em>ceci</em> est vrai, faire <em>cela</em>”. On appelle généralement <em>expression conditionnel</em> le schéma “si, alors, sinon” (<em>if, then, else</em>). De plus, on trouve parfois dans ces structures un nombre plus ou moins important d’expressions du type <em>sinon si</em> (<em>else if</em>), qui permettent des conditions imbriquées. Ici encore, cette notion est extrêmement importante, en cela qu’elle permet à un algorithme de prendre des chemins différents, de s’adapter à la complexité éclectique des données réelles qui lui sont fournies, et ainsi d’être plus polyvalent.</p>
<p><code>@TODO</code> : image Keep Talking And Nobody Explodes</p>
<h1 id="écritures-algorithmiques">Écritures algorithmiques</h1>
<h2 id="quest-ce-que-lécriture-">Qu’est-ce que l’écriture ?</h2>
<h3 id="écriture-et-langage">Écriture et langage</h3>
<p>L’écriture est une méthode de communication qui consiste à représenter un langage via l’inscription de signes graphiques sur des supports variés. En cela, elle est une forme d’inscription, tel que le terme est défini par Bruno Bachimont : l’association d’un substrat matériel à une forme d’expression. L’écriture est née quatre millénaires avant notre ère, en Mésopotamie, afin de conserver des traces d’échanges – notamment commerciaux –, la mémoire humaine n’étant pas infaillible et encore moins illimitée. Le philosophe François Dagognet nous rappelle l’adage latin : “<em>Verba volant, scripta manent</em>” – les paroles s’envolent, les écrits restent.<sup class="footnote-ref"><a href="#fn25" id="fnref25">25</a></sup> Mais Dagognet souligne aussi que dans ce passage de la parole à l’écrit, le discours n’est pas forcément transcrit scrupuleusement, mais peut au contraire subir des modifications.</p>
<blockquote>
<p>De ce que le vocalisé s’insinue dans le texte et aide à le comprendre, il ne s’ensuit pas que l’imprimé ne le dépasse pas. Si le graphisme ne supprime pas entièrement le gestuel, il l’amoindrit, tend à l’éloigner, voire à l’enjamber. <sup class="footnote-ref"><a href="#fn26" id="fnref26">26</a></sup></p>
</blockquote>
<p>En résumant sa pensée, je retiendrai ceci : si l’écriture découle de la parole comme une nouvelle forme d’échange communicationnel, elle n’en est pas une forme strictement identique. Un énoncé vocal ne transmet pas seulement la nature de l’énoncé, mais également sa forme – la tonalité, la prononciation, l’attitude –, au même titre que la représentation graphique joue sur des variations de représentation – graphie, tracé, composition, contraste – pour véhiculer une information qui enrichit le contenu même de l’écrit.</p>
<p>Ce propos rejoint la thèse d’Anne-Marie Christin, professeure spécialiste de l’écriture et des relations entre texte et image. Selon elle, l’écriture ne reproduit pas la parole, mais la rend visible : elle est le résultat de la fusion entre le langage, qui régit les échanges à l’intérieur d’un groupe, et l’image, composée de figures et de supports.<sup class="footnote-ref"><a href="#fn27" id="fnref27">27</a></sup></p>
<p>L’écriture présuppose un emploi du langage. Selon le <abbr title="Trésor de la Langue Française informatisé">TLFi</abbr>, le terme “langage” implique une définition multiple, selon que l’on parle du langage comme faculté et comme système, ou bien comme moyen d’expression, comme usage. Un langage est généralement doté d’une sémantique, et souvent d’une syntaxe, deux branches de la linguistique symétriquement opposées. La sémantique est une branche de la linguistique, elle étudie les <em>signifiés</em> : ce dont on parle, ce que l’on cherche à transmettre – en résumé, le <em>fond</em> de l’énoncé. La syntaxe, pour sa part, se concentre sur le <em>signifiant</em> : la langue, la représentation graphique, la grammaire employée, etc. – en résumé, la <em>forme</em> de l’énoncé. <sup class="footnote-ref"><a href="#fn28" id="fnref28">28</a></sup></p>
<h3 id="types-décritures">Types d’écritures</h3>
<p>L’écriture met généralement en relation au moins deux acteurs : l’<em>écrivain</em>, celui qui produit l’écrit, et le <em>lecteur</em>, qui reçoit – en lisant – l’écrit. À ce stade, on ne parle pas nécessairement de texte. La notion d’écrit, au sens large, peut désigner les diverses formes que peuvent prendre la traduction graphique de l’information communiquée : dessins, symboles, chiffres, lettres, etc. Toutefois, le sens généralement admis du terme <em>écrit</em> désigne trois grandes catégories de systèmes : logographique, syllabique et alphabétique.</p>
<ul>
<li>l’écriture logographique emploie des <em>logogrammes</em>, caractères – ou <em>glyphes</em> – représentant un mot ou un <em>morphème</em> – une fraction de mot. Plus précisément, on parle d’un <em>pictogramme</em> lorsqu’on représente directement un objet (par exemple, le blé), et d’un idéogramme lorsqu’on cherche à symboliser une idée (par exemple, la vitalité).</li>
<li>l’écriture syllabique emploie un <em>syllabaire</em>, composés de symboles exprimant chacun une syllabe. Les différentes formes d’écritures chinoises et japonaises en sont les exemples les plus courants.</li>
<li>enfin, l’écriture alphabétique est celle que nous connaissons le mieux, pour l’utiliser quotidiennement. Elle utilise un ensemble de symboles, dont chacun représente un phonème – plus petite entité linguistique –, composés de manière à former des mots. Une trentaine de signes alphabétiques suffisent généralement à écrire une langue. <sup class="footnote-ref"><a href="#fn29" id="fnref29">29</a></sup></li>
</ul>
<p>En outre, la pratique de l’écriture se place comme acte fondateur de la littérature. Par “littérature”, j’entends la conception de l’écriture comme une forme d’art. Cet art recouvre de nombreux genre et styles, plus ou moins strictement définis. On peut en établir une liste selon plusieurs critères – genre pictural, genre narratif, genre dramatique, contenu, ou encore registre. <sup class="footnote-ref"><a href="#fn30" id="fnref30">30</a></sup></p>
<h3 id="écritures-alternatives">Écritures alternatives</h3>
<p>Nul besoin de traiter en détail les formes d’écritures que nous connaissons le mieux : page par page, alignant des mots dans un alphabet latin, de la gauche vers la droite et du haut vers le bas. Pour questionner la notion d’écriture, je préfère m’intéresser à ses représentations moins classiques. Pour Anne-Marie Christin, l’exemple le plus pertinent qui a libéré l’écriture occidentale est une œuvre de Mallarmé, poète français du XIX<sup>ème</sup>siècle. On le décrit aujourd’hui comme un des premiers “poèmes typographiques”.</p>
<blockquote>
<p>Tout a changé dans la pensée occidentale de l’écrit avec le <em>Coup de Dés</em> de Mallarmé. Pour la première fois de leur histoire, les héritiers de l’alphabet que nous sommes ont pris conscience du fait qu’ils ne disposaient pas simplement, avec ces quelques signes, d’un moyen plus ou moins commode de transcrire graphiquement leur parole mais d’un instrument complexe, double, auquel il suffisait de réintégrer la part visuelle – spatiale – dont il avait été privé pour lui restituer sa plénitude active d’écriture. Les premières tentatives faites en ce sens au Moyen Âge […] étaient demeurées sans suite : notre culture foncièrement orale en avait aisément éliminé la formule, d’autant que la reproduction était coûteuse, très peu de temps après l’apparition de l’imprimerie.<sup class="footnote-ref"><a href="#fn31" id="fnref31">31</a></sup></p>
</blockquote>
<p><code>@TODO</code>: image Mallarmé</p>
<p>Dans la même idée de mise en espace des lettres, le poète français Guillaume Apollinaire publie en 1918 un ouvrage intitulé “<em>Calligrammes</em>”, terme qu’il invente à partir de la contraction de <em>calligraphie</em> – l’art graphique du dessin de caractères – et d’<em>idéogramme</em>. Cette forme particulière de poésie est parfois nommée “poésie graphique”.</p>
<p><code>@TODO</code>: images Apollinaire</p>
<p>On notera que François Dagognet classe le travail d’Apollinaire dans une catégorie qu’il intitule “<em>iconographies ordinatrices et inventives</em>”. Celle-ci est constitué de productions graphiques et littéraires qui font usage de <em>métaboles</em>, qu’il emprunte au groupe µ<sup class="footnote-ref"><a href="#fn32" id="fnref32">32</a></sup> dans son ouvrage “<em>Réthorique Générale</em>” : un métabole désigne tout espèce de changement du langage.<sup class="footnote-ref"><a href="#fn33" id="fnref33">33</a></sup></p>
<p><ins>On reportant ces distinctions au champ des algorithmes, on pourrait facilement s’interroger sur la forme que pourrait prendre une “écriture alternative” d’un algorithme, comme par exemple une écriture <em>poétique</em>. Le livre “<em>./code --poetry</em>” de Daniel Holden et Chris Kerr, ainsi que le site web associé<sup class="footnote-ref"><a href="#fn34" id="fnref34">34</a></sup> présentent des exemples de programmes s’affranchissant des conventions habituelles (voir la partie “<em><a href="#lignes-de-code-r%C3%A8gles-et-conventions">Lignes de code, règles et conventions</a></em>”) et dont le résultat est essentiellement esthétique : en résumé, du <em>code poétique</em>.
<img src="img/code-poetry.png" alt="Flocking.go, un programme poétique animé dans le langage Go">
<em><a href="http://code-poetry.com/flocking">Flocking.go</a>, un programme poétique animé dans le langage Go</em>
</ins></p>
<h2 id="lécriture-informatique">L’écriture informatique</h2>
<h3 id="de-lalgorithme-au-programme">De l’algorithme au programme</h3>
<p>Un programme informatique est une suite d’instructions qui effectue une ou plusieurs tâches spécifiques lorsqu’elle est exécutée par un ordinateur.<sup class="footnote-ref"><a href="#fn35" id="fnref35">35</a></sup> L’universitaire français Franck Varenne attire notre attention sur une possible origine de la confusion entre algorithmes et programmes. Il cite Charles Hoare, professeur et informaticien britannique, également connu pour la conception de nombreux algorithmes encore utilisés aujourd’hui. Hoare déclare que “la programmation informatique est une science exacte en ce que toutes les propriétés d’un programme […] peuvent être découvertes à partir du texte du programme lui-même au moyen de raisonnement purement déductif.” Varenne y oppose l’argumentation de James Fetzer, philosophe américain spécialisé notamment en informatique : la vision de Hoare amène à confondre les algorithmes et les programmes. Selon Varenne, rien n’implique une exacte similitude entre le comportement supposé du programme – à la lecture donc – et les conséquences réelles de son exécution sur la machine.</p>
<blockquote>
<p>Les algorithmes sont des solutions formelles (abstraites en ce sens) et effectives pour certains problèmes bien formulés. Les programmes chargés en mémoire (exécutables) sont en revanche des modèles causaux (car physiques) de ces algorithmes. Alors que les algorithmes sont des modèles abstraits des programmes exécutables, les programmes exécutables sont des modèles causaux des algorithmes.<sup class="footnote-ref"><a href="#fn36" id="fnref36">36</a></sup></p>
</blockquote>
<p>Varenne qualifie donc ces modèles d’<em>imparfaits</em> : le programme ne peut jamais être vérifié formellement, mais seulement de façon empirique. En effet, on peut établir la validité d’un programme, notamment en développant une sémantique formelle qui régule le <em>code</em> écrit par le programmeur. On résout alors les erreurs de programmation : variables sans valeur définie, fautes de syntaxe, structure erronée ou illogique, etc. Toutefois, la machine peut elle-même faire preuve de dysfonctionnement du fait même de sa dimension physique : processeur défectueux, espace de stockage corrompu, mémoire vive saturée, etc.</p>
<p>Cette marge d’incertitude entre le programme que l’on voit et ce que l’on obtient lorsqu’il est exécuté a été baptisé WYSINWYX, pour <em>What You See Is Not What You eXecute</em> – littéralement “ce que vous voyez n’est pas ce que vous exécutez”.<sup class="footnote-ref"><a href="#fn37" id="fnref37">37</a></sup> Cet acronyme est une référence au paronyme duquel il est inspiré : le terme WYSIWYG —<em>What You See Is What You Get</em>, soit “ce que vous voyez est ce que vous obtenez” – désigne, en informatique, les interfaces utilisateurs où l’on compose directement le résultat final souhaité.<sup class="footnote-ref"><a href="#fn38" id="fnref38">38</a></sup></p>
<h3 id="de-lordinateur-à-linformatique">De l’ordinateur à l’informatique</h3>
<p>La définition du terme “ordinateur”, dans son sens admis populairement, se base sur les travaux de Turing – comme évoqués dans la partie <em><a href="#la-r%C3%A9volution-turing">La révolution Turing</a></em>.</p>
<blockquote>
<p>Un ordinateur est un système de traitement de l’information programmable tel que défini par Turing et qui fonctionne par la lecture séquentielle d’un ensemble d’instructions, organisées en programmes, qui lui font exécuter des opérations logiques et arithmétiques.</p>
</blockquote>
<p>Les composants technologiques des ordinateurs modernes traitent des informations <em>binaires</em>. Là où les cartes perforées de Falcon utilisaient des trous ou des pleins pour signifier un des deux états uniques qui composent un <em>bit</em><sup class="footnote-ref"><a href="#fn39" id="fnref39">39</a></sup>, nos ordinateurs, dont le fonctionnement est basé sur l’électricité, utilisent pour signifier une valeur la présence ou l’absence de courant, de charge ou de tension électrique – suivant qu’il soit question de stocker ou de transmettre une donnée.</p>
<p>Les racines mathématiques de l’<em>ordinateur</em> se retrouvent dans l’étymologie même du terme. En 1955, Fançois Girard, responsable du service publicité d’IBM<sup class="footnote-ref"><a href="#fn40" id="fnref40">40</a></sup> France, fait appel à son ancien professeur de lettres, Jacques Perret, afin de trouver ensemble une traduction au mot anglais “computer”. Perret propose alors l’appellation “ordinatrice électronique”, inspirée de l’<em>ordonnateur</em>, ce composant de la machine décrit par Babbage comme celui qui “prend et reporte les nombres, et les soumet à l’opération demandée”. L’intitulé est ensuite simplifié en <em>ordinateur</em> et entre rapidement dans le langage populaire.</p>
<p>La notion d’informatique est intimement liée à l’univers des ordinateurs. Si en anglais, ordinateur se dit “computer”, la notion d’informatique est tout simplement désignée par la formule “computer science”. Certains penseurs affirment toutefois que l’on ne peut pas définir l’informatique comme “la science des ordinateurs”. On attribue notamment à Edsger Dijkstra, informaticien néerlandais reconnu, l’aphorisme suivant : “L’informatique n’est pas plus la science des ordinateurs que l’astronomie n’est celle des télescopes.” Les auteurs de cette phrase sont en réalité Michael Fellows et Ian Perberry, et la citation complète – traduite – est la suivante :</p>
<blockquote>
<p>L’informatique n’est pas plus la science des ordinateurs que l’astronomie n’est celle des télescopes, la biologie celle des microscopes, ou la chimie celle des <em>béchers</em> et des tubes à essais. La science ne traite pas des outils. Elle traite de notre manière de les utiliser, et de ce que l’on découvre en les utilisant. <sup class="footnote-ref"><a href="#fn41" id="fnref41">41</a></sup></p>
</blockquote>
<p><code>@TODO</code> : définir “computer” Salanskis (cf. Guillaume)</p>
<p>Dans “<em>Qu’est-ce que l’informatique ?</em>”, Franck Varenne propose et critique de nombreuses ébauches définitionnelles – c’est là le cœur de l’ouvrage – avant de conclure par la description suivante :</p>
<blockquote>
<p>[L’informatique est] une technologie (dans son caractère instumental et de délégation opératoire) et une discipline (dans ses versants cognitifs et réthoriques) de démultiplication, d’entrelacement, d’application […] et/ou de confrontation des voies de la référence. Plus brièvement : elle est une technologie d’entrecroisement automatique et programmable des voies de la référence. <sup class="footnote-ref"><a href="#fn42" id="fnref42">42</a></sup></p>
</blockquote>
<p>Varenne nomme “voies de la référence” la faculté des <em>symboles</em> utilisés en informatique (nombres, lettres, signes, etc.) à faire référence à un ou plusieurs autres symboles. En ce qui concerne le calcul numérique, les <em>voies</em> sont au nombre de deux : la <em>concrétisation</em> ou l’<em>abstraction</em>. Si elle en est fondamentalement inspirée, l’informatique va au-delà du calcul et joue sur les niveaux de symboles mis en œuvre : les symboles sont hybridés via des procédés de sous-symbolisation et de simulation. On pourrait illustrer cette distinction par un phénomène de “couches” superposées, où chacune est une symbolisation de celle sur laquelle elle s’appuie : cette superposition constitue ainsi une forme de <em>simulation</em> récursive, chaque strate jouant le rôle de la précédente sous une autre forme.</p>
<p><code>@TODO</code> : schéma couches</p>
<h3 id="langages-naturels-et-langages-formels">Langages naturels et langages formels</h3>
<p>En linguistique, on appelle “langage naturel” un langage qui a évolué naturellement au travers de l’utilisation humaine et de sa répétition, sans planification particulière ou préméditation consciente de la part du peuple qui l’utilise. On y oppose la notion de “langage formel”, parfois également appelé “langage construit” ou encore “langage artificiel”. À l’inverse, il s’agit ici d’un langage créé de toute pièce dans un temps relativement court, par une population bien plus restreinte – éventuellement l’œuvre d’un seul auteur. On peut distinguer trois catégories parmi ces langages construits :</p>
<ul>
<li>les langages conçus ou <em>engelangs</em> (de l’anglais <em>engineered</em>), à nouveau divisés en langages logiques (par exemple les langages de programmation informatique), philosophiques ou expérimentaux  ;</li>
<li>les langages auxiliaires ou <em>auxlangs</em>, créés pour la communication internationale – un des plus célèbres étant l’Esperanto ;</li>
<li>les langages artistiques ou <em>artlangs</em>, comme ceux inhérents à une œuvre de science-fiction ou de fantaisie (par exemples les langues crées par l’auteur J.&nbsp;R.&nbsp;R.&nbsp;Tolkien).</li>
</ul>
<p>Le terme de “langage formel” fait davantage référence au champ des mathématiques et de l’informatique. Cette notion intègre à la fois l’ensemble des séquences de caractères et des symboles qui sont employés et les différentes règles qui déterminent leurs usages. Une des applications concrètes des langages formels se trouve dans les langages de programmation informatique, c’est donc logiquement ceux auxquels je m’intéresse en particulier dans la suite de cet exposé.</p>
<h3 id="langages-informatiques">Langages informatiques</h3>
<p>Il existe une grande variété de langage de programmation, comme en témoigne la liste établie sur Wikipédia<sup class="footnote-ref"><a href="#fn43" id="fnref43">43</a></sup>. Tous possèdent des règles de syntaxe, un vocabulaire, une sémantique, un vocabulaire et des identifiants qui leurs sont propres. À la vue de cette liste – plus de 600 langages référencés –, une question me brûle les lèvres : pourquoi y a-t-il autant de langages de programmation ? Sur le site communautaire de programmation StackOverflow<sup class="footnote-ref"><a href="#fn44" id="fnref44">44</a></sup>, l’ingénieur Matt Sherman propose dans un article<sup class="footnote-ref"><a href="#fn45" id="fnref45">45</a></sup> plusieurs éléments de réponse :</p>
<ul>
<li>les différents langages sont autant d’outils, chacun plus ou moins adapté à des usages précis – il s’agit de choisir pour chaque finalité le langage qui sera le plus efficace, sûr et rapide à manier.</li>
<li>les programmeurs ont des goûts personnels – et des compétences qui leurs sont propres. Tel ou tel langage est souvent choisi en fonction des connaissances de l’équipe de programmation sur celui-ci.</li>
<li>la variété des langages de programmation est ainsi riche, en ce qu’elle permet plus de flexibilité en fonction des tâches à accomplir et des personnes qui vont employer ces langages.</li>
</ul>
<p>Il faut aussi prendre en compte la faculté qu’ont les langages à disparaître – tels des langues mortes –, et le fait que certains ne soient que très peu utilisés, car trop spécifiques, de niche, ou tout simplement conçus pour le divertissement plutôt que dans l’optique d’une application logicielle concrète. Par ailleurs, on peut catégoriser les langages de programmation en paradigmes de programmation. En résumé, un paradigme désigne la façon que le programmeur a d’envisager la structure et le fonctionnement du programme. Quelques exemples viennent éclairer cette définition :</p>
<ul>
<li>la programmation <em>orientée objet</em>, où l’on considère le programme comme une collection d’<em>objets</em> en interaction ;</li>
<li>la programmation <em>impérative</em>, parmi laquelle on trouve notamment la <em>programmation procédurale</em> qui fait appel à une suite de procédures – ou <em>fonctions</em> ;</li>
<li>la programmation <em>déclarative</em> qui consiste à déclarer les données du problème, puis à le faire résoudre par le programme ;</li>
<li>et bien d’autres familles encore. On remarquera que certains langages mêlent plusieurs paradigmes : le JavaScript par exemple, créé en 1995 et aujourd’hui un des plus présents notamment sur le web, est multi-paradigme : il est à la fois orienté objet, impératif et déclaratif.</li>
</ul>
<p><code>@TODO</code> : exemple code (js)</p>
<p>Je m’attarde sur deux types de langages qui me semblent se démarquer des langages de programmation “classiques”, les plus populaires de nos jours étant JavaScript, Python, Ruby, Java, PHP ou encore C++, d’après une étude<sup class="footnote-ref"><a href="#fn46" id="fnref46">46</a></sup> menée par la plateforme de développement collaboratif GitHub<sup class="footnote-ref"><a href="#fn47" id="fnref47">47</a></sup>. À l’inverse, il existe une façon de décrire un algorithme dans un langage naturel, sans faire référence à un langage de programmation particulier : il s’agit du <em>pseudo-code</em>. Sans réelle règle ou convention établie, l’écriture en pseudo-code permet de mesurer la difficulté de la conception d’un algorithme, et ainsi d’anticiper une structure flexible et adaptée au développement réel qui a lieu dans un second temps.</p>
<p><code>@TODO</code> : exemple pseudo-code</p>
<p>Une autre catégorie de langage qui questionne les limites des langages de programmation est celle des langages dits “ésotériques”, parfois appelés langages <em>exotiques</em> – <em>esoteric languages</em> en anglais, ou <em>esolangs</em> dans la forme contractée. Le terme “ésotérique” désigne une forme d’enseignement secret ou hermétique, réservé à des initiés. En effet, qu’ils se présentent comme des œuvres logicielles, des exercices intellectuels ou même de simples plaisanteries<sup class="footnote-ref"><a href="#fn48" id="fnref48">48</a></sup>, ces langages nécessitent une certaine maîtrise antérieure des langages de programmation classiques pour être compris, voire manipulés. Parmi les plus connus se trouve le <em>Brainfuck</em> – et sa variante <em>JSFuck</em>, basée sur le langage JavaScript valide, c’est-à-dire exécutable. En n’employant que 8 caractères distincts – 6 pour le <em>JSFuck</em> –, ce langage amène à produire du code particulièrement <em>obfusqué</em>.<sup class="footnote-ref"><a href="#fn49" id="fnref49">49</a></sup> Un autre exemple particulièrement intéressant d’<em>esolang</em> est le Piet, nommé d’après le célèbre peintre néerlandais Piet Mondrian. Ce langage n’est pas textuel mais graphique : les programmes prennent la forme d’images semblables à de l’art abstrait – librement inspiré des travaux du peintre éponyme.</p>
<p><code>@TODO</code> : “Hello world” Brainfuck + Piet</p>
<p>Dans la suite de cet exposé, je reviens à des langages plus classiques, afin d’étudier les systèmes d’écriture les plus couramment utilisés pour produire des programmes.</p>
<h2 id="systèmes-décriture-algorithmique">Systèmes d’écriture algorithmique</h2>
<h3 id="environnements-de-développement-et-workflow">Environnements de développement et <em>workflow</em></h3>
<p>On parle “d’environnement de développement” ou d’<abbr title="Integrated development environment">IDE</abbr> pour désigner l’ensemble des outils employés par un programmeur pour développer un programme informatique. Un IDE est généralement un logiciel dont l’interface propose un ensemble d’outils et de fonctions : le plus généralement, on trouve un éditeur de texte où le programmeur saisit des lignes de codes. Celui-ci est généralement accompagné d’un débugger – pour débusquer et corriger les <em>bugs</em> – ou encore, si le langage l’implique, d’un compilateur – utilisé pour “traduire” le langage de programmation en <em>langage machine</em>, c’est-à-dire en instructions exécutables par l’ordinateur. Le choix de tel ou tel logiciel de programmation – de tel ou tel environnement – dépend généralement du langage utilisé dans le cadre d’un projet, ainsi que des goûts personnels du développeur. Certains outils, ayant une communauté plus active, se développent particulièrement grâce à la contribution collective – lorsque le logiciel est <em>open-source</em> – tandis que d’autres tombent en désuétude, les années passant et les technologies évoluant en conséquence.</p>
<p><code>@TODO</code> : screen d’un IDE</p>
<p>Les méthodes de travail d’un développeur sont souvent bien maîtrisées. On parle de <em>workflow</em> – “flux de travaux” – pour désigner les méthodes d’organisation systématiques qu’il applique afin de fluidifier le processus de programmation et de se prévenir de complications diverses – notamment lorsque d’importantes quantités de données sont manipulées, et que l’erreur humaine peut intervenir à tout moment. Une des solutions les plus couramment appliquées de nos jours et la gestion de version – le <em>versionning</em> en anglais. J’ai déjà mentionné le logiciel <em>git</em>, qui permet d’enregistrer des points clés dans l’avancement d’un projet numérique. Pour comprendre la valeur de cette méthode, il faut noter la nature spécifique de l’écriture algorithmique – écriture au sens large de conception et représentation, pas seulement textuelle. À l’image de l’étudiant – ou de l’auteur récompensé – qui écrit un paragraphe d’un écrit, revient en arrière, effectue des modifications le lendemain, réorganise son plan et finit par rayer des parties, le développeur fait preuve d’une écriture non linéaire. Les projets prenant généralement plusieurs semaines voire plusieurs mois, l’emploi d’un système de gestion de versions semble particulièrement pertinent.</p>
<p><code>@TODO</code> : image diff</p>
<h3 id="lignes-de-code-règles-et-conventions">Lignes de code, règles et conventions</h3>
<p>Le code, tel que le définit l’archéologue et linguiste Clarisse Herrenschmidt, est “un moyen de chiffrer, propre à la machine qui crypte et décrypte.”<sup class="footnote-ref"><a href="#fn50" id="fnref50">50</a></sup> C’est la forme la plus connue et la plus employée. La quasi-intégralité des produits numériques, logiciels et autres applications que nous utilisons aujourd’hui ont été développés dans un éditeur de texte, ligne par ligne, symbole par symbole.  Les langages de programmation emploient une syntaxe – autrement dit un ensemble de contraintes qui régissent la combinaison des symboles – qu’il convient de respecter pour assurer la bonne exécution du programme. Sinon, le compilateur rencontrera une anormalité et le débugger (ou la <em>console</em>) va afficher un message d’erreur.</p>
<p>Afin de faciliter la lisibilité du code, un certain nombre de principes graphiques sont utilisés. Par exemple, l’<em>indentation</em> consiste à ajouter des espaces – ou des <em>tabulations</em> – en début de chaque ligne de code de façon à structurer visuellement l’ensemble du programme. Dans la plupart des langages, les espaces vides sont ignorés lors de l’interprétation par la machine, ils sont donc utilisés selon la convenance pour faciliter la lecture. À l’inverse, dans certains langages – comme le Python –, cette structuration est essentielle car elle définit le fonctionnement même du programme, il n’est donc pas ici question uniquement de style ou de clarté. Un autre principe graphique employé pour la lisibilité : la coloration syntaxique (ou <em>syntax highlighting</em> en anglais), qui formate automatiquement les éléments du texte – notamment par le changement de couleur mais parfois aussi de typographie – afin d’en simplifier la lecture. Ce système répond d’ailleurs à un problème énoncé par Franck Varenne, faisant lui-même référence au philosophe Gilles Gaston Granger : “des symboles qui peuvent être écrits côte à côte dénotent des types d’entités différents”.<sup class="footnote-ref"><a href="#fn51" id="fnref51">51</a></sup></p>
<p>Enfin, les développeurs utilisent de nombreuses conventions, couches supplémentaires permettant d’assurer une compréhension universelle du code de chacun. Voici quelques exemples de conventions :</p>
<ul>
<li>les commentaires, exprimés en langage naturel (souvent en anglais), qui servent à clarifier le fonctionnement du programme à un endroit précis auprès de potentiels futurs lecteurs ;</li>
<li>l’indentation, comme expliqué plus haut, dont on définit les points de retours à la ligne ou le nombre d’espaces ;</li>
<li>la longueur des lignes, pour garantir un affichage de l’ensemble du code dans un éditeur de texte – du moins sur la largeur ;</li>
<li>le nommage des variables, notamment sur la façon de <em>concaténer</em> – mettre bout à bout plusieurs chaînes de caractères – des intitulés. On parle notamment de <em>casse</em>, c’est-à-dire de l’usage des lettres capitales pour assurer la lisibilité d’un mot-valise ;</li>
<li>et d’autres encore, liées au “bonnes pratiques” et principes divers qui permettent l’intelligibilité, l’efficacité, la flexibilité ou encore la sécurité d’un programme.</li>
</ul>
<pre class=" language-javascript"><code class="prism  language-javascript"><span class="token comment" spellcheck="true">/* Ceci est un exemple simplifié de programme dans le langage JavaScript. Ces deux phrases sont des commentaires, elles ne sont pas prises en compte dans l'exécution du script. */</span>

<span class="token keyword">var</span> text <span class="token operator">=</span> <span class="token string">"Hello world!"</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">/* Ici, on attribue une valeur (dans ce cas une chaîne de caractères) à une variable nommée "text". */</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">/* Cette fonction permet d'afficher une variable dans la console (par exemple celle d'un navigateur web). */</span>
</code></pre>
<h3 id="programmation-visuelle">Programmation visuelle</h3>
<p>La programmation peut également prendre une forme graphique, visuelle. C’est le cas notamment des représentations algorithmiques en diagrammes, aussi appelées <em>algorigrammes</em> – ou <em>flowcharts</em> en anglais. Les instructions sont divisées dans autant de formes géométriques normalisés – un rectangle pour une opération, un losange pour un test, etc. – qui sont ensuite reliées entres elles pour symboliser l’enchaînement des instructions. Apparue il y a un siècle dans le domaine de l’ingénierie industrielle, cette représentation est utilisée dans certains logiciels de programmation comme Flowgorithm, qui est un intermédiaire entre la conception algorithmique visuelle et la programmation textuelle : le diagramme créé par l’utilisateur peut être traduit en un des langages de programmation les plus courants. Ces types d’outils est notamment utilisé pour l’éducation, auprès de novices, afin de leur faire assimiler sans introduire les langages de programmation comme difficulté supplémentaire.</p>
<p><code>@TODO</code> : image flowchart</p>
<p>La programmation visuelle peut aussi s’affranchir de la représentation normalisée d’un algorigramme. L’exemple le plus connu est le logiciel Scratch, développé par le <abbr title="Massachusetts Institute of Technology">MIT</abbr> depuis une quinzaine d’années. Scratch propose de voir la programmation algorithmique comme un jeu de puzzle, constitué de “blocs” représentant chacun un type d’opération particulier, imbriqués pour constituer la structure du programme. Son interface simple et colorée et son intuitivité en font l’outil parfait pour les plus jeunes créatifs, et un excellent moyen d’appréhender la réflexion logisticienne et mathématique.</p>
<p><code>@TODO</code> : image Scratch</p>
<p><ins>Le développeur de jeux vidéo indépendant – et d’expériences interactives – Nicky Case travaille en 2017 sur <a href="http://ncase.me/joy-demo/">JOY.js</a>, une interface qui propose de manipuler et visualiser des algorithmes en langage JavaScript grâce à un éditeur de texte interactif et une visualisation en temps réel.
<img src="img/joy-js.png" alt="JOY.js, un outil interactif de manipulation de programmes JavaScript">
<em>JOY.js, un outil interactif de manipulation de programmes JavaScript</em>
</ins></p>
<h3 id="modes-singuliers-de-programmation-algorithmique">Modes singuliers de programmation algorithmique</h3>
<p>Ces exemples transposent l’écriture algorithmique classique vers une démarche plus empirique et plus “physique” : les éléments constitutifs de l’algorithme sont directement <em>manipulés</em> – mentalement. En plus d’être une approche facilitée – car plus concrète – et ainsi souvent mise en œuvre dans l’éducation, ce décalage ouvre de nombreuses possibilités créatives : que serait un algorithmique matérialisé, hors de l’écran ? Quelles opportunités de manipulation – littéralement – cela permettrait-il ? Dans quel but ou quel contexte cette démarche pourrait-elle s’inscrire ? Je donne en exemples ci-après trois expérimentations autour de différents paradigmes de langage : langage naturel, langage iconographique, et enfin langage tangible.</p>
<p><ins>Je m’interroge d’abord sur la dualité entre langage naturel et langage formel. Dans notre manière de communiquer à la machine – notamment des instructions –, ne peut-on pas utiliser d’autres formes de langages qu’un langage de programmation ? J’ai entamé une proposition de réponse à cette question grâce à une expérimentation interactive d’interface qui permet de “coder” en langage naturel, c’est-à-dire en écrivant de l’anglais intelligible par tous – ce qui implique une traduction “cachée” en langage JavaScript, exécutable par un navigateur.<sup class="footnote-ref"><a href="#fn52" id="fnref52">52</a></sup>
<img src="img/text2code.png" alt="text2code, une interface d'écriture algorithmique en langage naturel">
<em>text2code, une interface d’écriture algorithmique en langage naturel</em>
</ins></p>
<p><ins>Dans un second temps, j’ai proposé une autre expérimentation où l’on n’utilise plus du langage textuel mais pictographique : avec “<em>emoji2code</em>”, je propose une syntaxe permettant de programmer un algorithme à partir d’un enchaînement d’emoji. Dans l’exemple ci-dessous, on ordonne simplement de compter de 0 à 9.<img src="img/emoji2code.png" alt="emoji2code, une interface d'écriture algorithmique à l'aide d'emoji">
<em>emoji2code, une interface d’écriture algorithmique à l’aide d’emoji</em>
</ins></p>
<p><ins>En 2017, le collectif d’arts numériques transdisciplinaire <em>[foam]</em> travaille sur un langage de programmation tangible, avec une installation intitulée “<em>Pattern Matrix</em>”. Le langage a littéralement été créé de toute pièces : on opère l’installation en tournant une série de “jetons” qui cachent des senseurs magnétiques. Des informations visuelles sont superposées grâce à la <em>réalité augmentée</em>. Un premier essai du dispositif a été fait dans le cadre d’une performance musicale live à Brighton.<sup class="footnote-ref"><a href="#fn53" id="fnref53">53</a></sup>
<img src="img/pattern-matrix.png" alt="Pattern Matrix, un langage de programmation tangible">
<em>Pattern Matrix, un langage de programmation tangible</em>
</ins></p>
<h1 id="algorithmes-et-design">Algorithmes et design</h1>
<h2 id="la-place-du-designer">La place du designer</h2>
<h3 id="rapport-de-lhomme-à-la-machine">Rapport de l’homme à la machine</h3>
<ul>
<li>Back Office</li>
</ul>
<h3 id="créer-ses-outils">Créer ses outils</h3>
<ul>
<li>John Maeda</li>
</ul>
<h2 id="contextes-dapplication">Contextes d’application</h2>
<h3 id="problématiques-possibles">Problématiques possibles</h3>
<ul>
<li>création</li>
<li>apprentissage</li>
<li>visualiser</li>
<li>jouer</li>
</ul>
<h3 id="quel-environnement-quel-terrain-">Quel environnement, quel terrain ?</h3>
<ul>
<li>Creative coding</li>
<li>Live coding</li>
<li>…</li>
</ul>
<h3 id="deux-approches">Deux approches</h3>
<ul>
<li>Que permet tel catégorie d’interface/d’écriture algorithme (pour, but, objectif)</li>
<li>Questionner l’interface en soi (pourquoi on écrit en lignes, et pourquoi pas autrement). Travailler le matériau.</li>
</ul>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>Serge Abiteboul et Gilles Dowek sont chercheurs à l’<abbr title="Institut national de recherche en informatique et en automatique">INRIA</abbr> et professeur à l’<abbr title="École normale supérieure">ENS</abbr> de Paris-Saclay. <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>La recherche par force brute, aussi connue sous le nom “générer et tester” est une technique générale de résolution de problème qui consiste à énumérer tous les candidats possibles à une solution et vérifier chacun d’eux afin de déterminer lequel répond le mieux au problème. L’efficacité de cette méthode est liée à la puissance des ordinateurs modernes, capables d’effectuer des calculs infiniment plus rapidement que le cerveau humain. <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>Le sociologue français Dominique Cardon propose une classification des typologies d’algorithmes qui régissent notre quotidien – notamment sur le web. Il distingue quatre familles, qu’il illustre spatialement : “les mesures peuvent se trouver <em>à côté</em>, <em>au-dessus</em>, <em>dans</em> ou <em>en dessous</em> des données numériques”. <cite>2:17–18</cite> <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>Différents exemples d’interventions et d’usages des algorithmes dans le champ du design sont énumérés sur le site <a href="http://algorithms.design/">algorithms.design</a>, notamment les algorithmes d’intelligence artificielle, champ de recherche au cœur de l’actualité. <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p><cite>1:11</cite> <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p>Muhammad Ibn Mūsā al-Khuwārizmī, généralement appelé <em>Al-Khwarizmin</em> (latinisé en <em>Algoritmi</em>), était un mathématicien, géographe, astrologue et astronome perse, notamment auteur d’un ouvrage classifiant les procédés algébriques existants à son époque. <a href="#fnref6" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn7" class="footnote-item"><p>Le terme <em>abaque</em> désigne tout instrument mécanique plan facilitant le calcul. <a href="#fnref7" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn8" class="footnote-item"><p>Blaise Pascal était un mathématicien, physicien, inventeur et philosophe français. À 19 ans, il invente la première machine à calculer, dénommée <em>machine d’arithmétique</em>, puis <em>pascaline</em>. <a href="#fnref8" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn9" class="footnote-item"><p>Gottfried Leibniz était un philosophe, scientifique, mathématicien et logicien allemand. <a href="#fnref9" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn10" class="footnote-item"><p>Charles Babbage était un mathématicien et inventeur britannique du XIX<sup>ème</sup> siècle. Il fut l’un des principaux précurseurs de l’informatique. <a href="#fnref10" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn11" class="footnote-item"><p><a href="https://fr.wikipedia.org/wiki/Machine_analytique">Machine analytique</a> sur Wikipédia <a href="#fnref11" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn12" class="footnote-item"><p>En mathématiques, les nombres de Bernoulli constituent une suite de nombres rationnels. Ces nombres ont d’abord été étudiés par Jacques Bernoulli, mathématicien et physicien suisse du XVII<sup>ème</sup>siècle. <a href="#fnref12" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn13" class="footnote-item"><p>Alan Turing était un mathématicien et cryptologue britannique, dont les travaux ont fondé l’informatique moderne. Après l’invention de la machine de Turing – qui contribue à la thèse de Church-Turing autour de la notion de problème <em>calculable</em> –, il participe au décryptage des codes secrets de la machine allemande Enigma pendant la Seconde Guerre Mondiale – ce qui joua un rôle essentiel dans la victoire des Alliés. Turing poursuit des recherches en informatique et formule le “test de Turing”, fondamental dans le champ de l’intelligence artificielle. Poursuivi judiciairement pour homosexualité, Turing choisit la castration chimique pour éviter la prison. Il décède en 1954 d’un empoisonnement au cyanure, vraisemblablement par suicide. <a href="#fnref13" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn14" class="footnote-item"><p><cite>3:16–18</cite> <a href="#fnref14" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn15" class="footnote-item"><p><a href="https://fr.wikipedia.org/wiki/Architecture_de_von_Neumann#Architecture">Architecture de von Neumann</a> sur Wikipédia <a href="#fnref15" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn16" class="footnote-item"><p>La cybernétique est l’approche transdisciplinaire d’exploration des machines et systèmes auto-régulés. Elle met en parallèle les principes qui régissent les êtres vivants avec des machines. <a href="#fnref16" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn17" class="footnote-item"><p><cite>6:46–47</cite> <a href="#fnref17" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn18" class="footnote-item"><p>Le programme <em>SHRDLU</em>, développé par Terry Winograd en 1968, était un des premiers programmes de compréhension du langage naturel. Voir <a href="https://en.wikipedia.org/wiki/SHRDLU#Excerpt">un extrait de la démonstration de SHRDLU</a> sur Wikipédia <a href="#fnref18" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn19" class="footnote-item"><p>Clics, vues, fréquences des visites, les algorithmes n’analysent pas seulement notre comportement en ligne mais également celui que nous avons dans le “monde réel” : déplacements, achats de produits en tous genres, échanges sociaux, etc. En se basant sur ces montagnes de données, les algorithmes savent à présent calculer les probabilités statistiques que chacun réalise une action donnée dans un futur proche. <a href="#fnref19" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn20" class="footnote-item"><p>Ce qui n’était qu’une prédiction en 1965 (revisitée en 1975) s’avéra étonnement proche de la réalité sur les 30 ans qui suivirent : entre 1971 et 2001, la densité des transistors a doublé chaque 1,96 année. <a href="#fnref20" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn21" class="footnote-item"><p>Pour comprendre en détail le fonctionnement d’un réseau neuronal, visionner la playlist <a href="https://www.youtube.com/watch?v=aircAruvnKk">Neural Networks</a> de <em>3Blue1Brown</em> sur YouTube <a href="#fnref21" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn22" class="footnote-item"><p><cite>6:104, 110–119</cite> <a href="#fnref22" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn23" class="footnote-item"><p><cite>1:18–19</cite> <a href="#fnref23" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn24" class="footnote-item"><p>Un booléen est un type de variable à deux états. Cette terminologie fait référence aux travaux de George Boole, célèbre logicien et mathématicien  britannique, qui en 1845 a établit les bases de la “logique booléenne”, n’acceptant que deux valeurs numériques : 0 et 1. Cet algèbre connaîtra une importance capitale dans l’informatique et est encore énormément employée de nos jours. <a href="#fnref24" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn25" class="footnote-item"><p><cite>7:15</cite> <a href="#fnref25" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn26" class="footnote-item"><p><cite>7:26</cite> <a href="#fnref26" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn27" class="footnote-item"><p><cite>8:7–8</cite> <a href="#fnref27" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn28" class="footnote-item"><p>La notion de “signifiant et signifié” a été théorisée par le linguiste suisse Ferdinand de Saussure dans son ouvrage “<em>Cours de linguistique générale</em>”. Tel qu’il les définit, le <em>signifié</em> désigne le concept, et le <em>signifiant</em> désigne l’image sonore : de Saussure exclut donc les autres formes de représentation – graphique, gestuelle, etc. <a href="#fnref28" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn29" class="footnote-item"><p><a href="http://classes.bnf.fr/dossiecr/sys-ecri.htm">“<em>Les systèmes d’écriture</em>”</a> sur <abbr title="Bibliothèque Nationale de France">BNF</abbr> <a href="#fnref29" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn30" class="footnote-item"><p>Voici une liste non exhaustive énumérant quelques grandes catégories de genre littéraires : poétiques (poésies, poèmes, haïkus, chansons mais aussi calligrammes), narratifs (romans, comptes, nouvelles, biographie), théâtraux (pièces de théâtre de tous registres), épistolaires (constitués de lettres échangées), argumentatifs (essais, pensées ou même pamphlets), graphiques (roman graphique, bande dessinée), ou encore formes brèves (proverbes, aphorisme, énigme, blague, etc.) <a href="#fnref30" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn31" class="footnote-item"><p><cite>8:10</cite> <a href="#fnref31" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn32" class="footnote-item"><p>Le groupe µ – prononcer “mu” – est un collectif interdisciplinaire de chercheurs en linguistique, sociologie ou encore sémiotique, fondé en 1967. <a href="#fnref32" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn33" class="footnote-item"><p>Les auteurs décrivent quatre opérations fondamentales qui peuvent constituer une métabole : l’addition, la suppression, la substitution ou la permutation d’unités phonétiques ou morphologiques. Il la distingue d’une autre catégorie appelée “<em>iconographies nouménalisantes et explicatives</em>” parmi lesquelles il compte notamment la représentation des molécules en chimie, ou le dessin des volumes géométriques. <a href="#fnref33" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn34" class="footnote-item"><p>Voir quelques exemples visuels et animés sur le site <a href="http://code-poetry.com/"><em>./code --poetry</em></a> <a href="#fnref34" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn35" class="footnote-item"><p><a href="https://fr.wikipedia.org/wiki/Programme_informatique">Programme informatique</a> sur Wikipédia <a href="#fnref35" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn36" class="footnote-item"><p><cite>3:46</cite> <a href="#fnref36" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn37" class="footnote-item"><p><cite>4</cite> <a href="#fnref37" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn38" class="footnote-item"><p><a href="https://fr.wikipedia.org/wiki/What_you_see_is_what_you_get"><em>What you see is what you get</em></a> sur Wikipédia <a href="#fnref38" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn39" class="footnote-item"><p>Le <em>bit</em>, abréviation de <em>binary digit</em> (chiffre binaire) est l’unité d’information la plus basique : un chiffre binaire ne peut avoir que deux valeurs, et ainsi être représenté avec un dispositif à deux états. Ces valeurs d’états sont le plus souvent représentés comme 0 ou 1. <a href="#fnref39" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn40" class="footnote-item"><p>International Business Machines Corporation, connue sous l’abréviation IBM, est une société multinationale américaine fondée en 1911. Il s’agit d’un des leaders mondiaux en informatique – parallèlement sur le matériel, les services, les logiciels et la recherche. <a href="#fnref40" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn41" class="footnote-item"><p><cite>5</cite> <a href="#fnref41" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn42" class="footnote-item"><p><cite>3:67</cite> <a href="#fnref42" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn43" class="footnote-item"><p><a href="https://fr.wikipedia.org/wiki/Liste_de_langages_de_programmation">Liste de langages de programmation</a> sur Wikipédia <a href="#fnref43" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn44" class="footnote-item"><p>Stack Overflow est une plateforme web où chacun peut poser des questions ou apporter des réponses sur de nombreux de thèmes liés à la programmation informatique. Il fait partie du réseau de sites Stack Exchange, qui intègre de nombreux services basés sur le même principe d’entraide communautaire, dans des disciplines variées. <a href="#fnref44" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn45" class="footnote-item"><p><a href="https://stackoverflow.blog/2015/07/29/why-are-there-so-many-programming-languages/">“<em>Why are there so many programming languages?</em>”</a> sur StackOverflow <a href="#fnref45" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn46" class="footnote-item"><p><a href="https://octoverse.github.com/">GitHub Octoverse 2017</a> <a href="#fnref46" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn47" class="footnote-item"><p>GitHub est une plateforme d’hébergement de gestion de versions collaborative. Basé sur le logiciel <em>git</em>, qui permet d’enregistrer des versions de son travail à différentes étapes de l’avancement du projet, GitHub est communautaire et chacun peut dupliquer le code d’autrui – si celui-ci est <em>ouvert</em>, ou <em>open-source</em> –, y apporter des modifications ou des remarques. <a href="#fnref47" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn48" class="footnote-item"><p>Le site <a href="http://esoteric.codes/">esoteric.codes</a> regroupe plusieurs exemples créatifs mettant en jeu des langages ésotériques. <a href="#fnref48" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn49" class="footnote-item"><p>En programmation, “obsfuquer” signifie rendre un programme illisible, en transformant notamment le nom des variables afin de rendre la structure globale de l’algorithme incompréhensible et inexploitable. <a href="#fnref49" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn50" class="footnote-item"><p><cite>9:395</cite> <a href="#fnref50" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn51" class="footnote-item"><p><cite>3:39</cite> <a href="#fnref51" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn52" class="footnote-item"><p>Voir une <a href="https://twitter.com/Ashugeo/status/927947488950177793">démonstration en vidéo du prototype “<em>test2code</em>”</a> sur Twitter <a href="#fnref52" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn53" class="footnote-item"><p><a href="https://fo.am/blog/2017/11/27/pattern-matrix-algomech2/">“<em>How to design a tangible programming language</em>”</a> sur <em>[foam]</em> <a href="#fnref53" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

    </div>
  </div>
</body>

</html>
