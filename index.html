<!DOCTYPE html>
<html lang="fr">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>IDE AS IDEAS</title>
  <link rel="icon" type="image/png" href="icon.png" />
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
  <link rel="stylesheet" href="css/main.min.css" />
  <script src="js/jquery-3.2.1.min.js"></script>
  <script src="js/main.js"></script>
</head>

<body class="stackedit">
    <div class="header-wrap">
        <div class="header">
            <h1>IDE AS<br>IDEAS</h1>
            <h2>Designer les outils numériques<br>d’écriture algorithmique<br>pour le travail de création</h2>
            <h3>Hugo Sainte-Marie<br>Mémoire de recherche professionnel – 2018<br>DSAA Design interactif<br>Pôle supérieur de Design – Villefontaine</h3>
        </div>
    </div>
    <div class="content">

  <div class="stackedit__left">
    <div class="stackedit__toc">

<ul>
<li><a href="#préface">Préface</a></li>
<li><a href="#introduction">Introduction</a>
<ul>
<li><a href="#la-place-de-lalgorithme">La place de l’algorithme</a>
<ul>
<li><a href="#quest-ce-quun-algorithme-">Qu’est-ce qu’un algorithme ?</a></li>
<li><a href="#les-algorithmes-dans-la-société">Les algorithmes dans la société</a></li>
</ul>
</li>
<li><a href="#lalgorithme-et-le-designer">L’algorithme et le designer</a>
<ul>
<li><a href="#bricodage">Bricodage</a></li>
<li><a href="#concevoir-ses-outils">Concevoir ses outils</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#le-matériau-algorithme">Le matériau algorithme</a>
<ul>
<li><a href="#algorithme-et-instruction">Algorithme et instruction</a>
<ul>
<li><a href="#linstruction-comme-action-dinstruire">L’instruction comme action d’instruire</a></li>
<li><a href="#linstruction-comme-ordre">L’instruction comme ordre</a></li>
</ul>
</li>
<li><a href="#quatre-instructions-fondamentales">Quatre instructions fondamentales</a>
<ul>
<li><a href="#séquence">Séquence</a></li>
<li><a href="#affectation">Affectation</a></li>
<li><a href="#itération">Itération</a></li>
<li><a href="#condition">Condition</a></li>
</ul>
</li>
<li><a href="#concrétisation-techniques-et-historiques">Concrétisation techniques et historiques</a>
<ul>
<li><a href="#de-la-main-à-la-machine">De la main à la machine</a></li>
<li><a href="#jacquard-ou-le-tissage-programmé">Jacquard, ou le tissage programmé</a></li>
<li><a href="#la-machine-analytique-de-babbage">La machine analytique de Babbage</a></li>
<li><a href="#la-révolution-turing">La révolution Turing</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#lécriture-algorithmique">L’écriture algorithmique</a>
<ul>
<li><a href="#quest-ce-quécrire-">Qu’est-ce qu’écrire ?</a>
<ul>
<li><a href="#lécriture-formalisation-du-langage">L’écriture, formalisation du langage</a></li>
<li><a href="#trois-typologies-décriture">Trois typologies d’écriture</a></li>
<li><a href="#la-littérature-ou-lart-écrit">La littérature, ou l’art écrit</a></li>
</ul>
</li>
<li><a href="#lécriture-algorithmique-1">L’écriture algorithmique</a>
<ul>
<li><a href="#de-lordinateur-à-linformatique">De l’ordinateur à l’informatique</a></li>
<li><a href="#de-lalgorithme-au-programme">De l’algorithme au programme</a></li>
<li><a href="#langages-informatiques">Langages informatiques</a></li>
<li><a href="#langages-naturels-et-langages-formels">Langages naturels et langages formels</a></li>
<li><a href="#lignes-de-code-règles-et-conventions">Lignes de code, règles et conventions</a></li>
</ul>
</li>
<li><a href="#outils-décriture-algorithmique">Outils d’écriture algorithmique</a>
<ul>
<li><a href="#ide-et-éditeurs-de-texte">IDE et éditeurs de texte</a></li>
<li><a href="#programmation-visuelle">Programmation visuelle</a></li>
<li><a href="#workflow--loutil-adapté-à-lusage">Workflow : l’outil adapté à l’usage</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#modes-singuliers-de-programmation-algorithmique">Modes singuliers de programmation algorithmique</a>
<ul>
<li><a href="#pratiques-singulières">Pratiques singulières</a>
<ul>
<li><a href="#le-code-auto-modifiant">Le code auto-modifiant</a></li>
<li><a href="#langages-ésotériques">Langages ésotériques</a></li>
<li><a href="#esthétiques-du-code">Esthétiques du code</a></li>
<li><a href="#programmation-tangible--la-réflexion-par-la-main">Programmation tangible : la réflexion par la main</a></li>
</ul>
</li>
<li><a href="#modes-de-représentation">Modes de représentation</a>
<ul>
<li><a href="#représenter-les-algorithmes">Représenter les algorithmes</a></li>
<li><a href="#visualiser-au-sein-de-lide">Visualiser au sein de l’IDE</a></li>
<li><a href="#manipuler-au-sein-de-lide">Manipuler au sein de l’IDE</a></li>
</ul>
</li>
<li><a href="#deux-typologie-doutils">Deux typologie d’outils</a>
<ul>
<li><a href="#outils-qui-se-rapprochent">Outils qui se rapprochent</a></li>
<li><a href="#outils-qui-séloignent">Outils qui s’éloignent</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#conclusion">Conclusion</a></li>
<li><a href="#ressources">Ressources</a>
<ul>
<li><a href="#bibliographie">Bibliographie</a></li>
<li><a href="#webographie">Webographie</a></li>
</ul>
</li>
<li><a href="#remerciements">Remerciements</a></li>
<li><a href="#à-propos">À propos</a></li>
</ul>

    </div>
  </div>
  <div class="stackedit__right">
    <div class="stackedit__html">
<h1 id="préface">Préface</h1>
<p>Lorsque je préparais, il y a deux ans, ma soutenance de diplôme en design graphique, une professeure m’a permis de comprendre la spécificité de ma pratique en tant que designer : j’ai un profil résolument technicien. Cela m’a amené à répondre à des sujets d’une façon assez personnelle, parfois alternative, en développant par exemple des outils générateurs de logotypes, ou encore en réalisant des expérimentations graphiques à l’aide d’algorithmes. J’aborde donc ce travail de recherche en assumant une démarche  très empirique : comme beaucoup, je dois expérimenter pour comprendre. Compte tenu de la dimension relativement technique de l’écriture algorithmique, sa pratique constitue pour moi l’approche de recherche en design la plus adaptée à mon profil, et permet de concrétiser l’étude théorique en proposant des solutions appliquées.</p>
<p>Dans ce mémoire, je ne cherche pas à répondre à une question récurrente notamment sur les réseaux sociaux : “les designers devraient-ils coder ?”<sup class="footnote-ref"><a href="#fn1" id="fnref1">1</a></sup> En effet, je ne vois pas la pratique du code comme une compétence dont la nécessité devrait être débattue. Selon moi, il s’agit plutôt d’un outil dont le designer peut s’emparer, voire d’un <em>matériau</em> dont la manipulation – l’écriture algorithmique – met en jeu des outils. Ce mémoire s’intéresse donc à ces outils, les interfaces d’écriture de programmes, en particulier dans les pratiques créatives telles que le design.</p>
<h1 id="introduction">Introduction</h1>
<h2 id="la-place-de-lalgorithme">La place de l’algorithme</h2>
<h3 id="quest-ce-quun-algorithme-">Qu’est-ce qu’un algorithme ?</h3>
<p><strong>Un algorithme est une séquence d’instructions qui vise à être exécutée afin de produire un résultat.</strong> Pour comprendre ou enseigner la notion d’algorithme, on fait bien souvent appel à des cas concrets que l’on rencontre dans la vie quotidienne. Une recette de cuisine, par exemple, constitue un algorithme : on y trouve des paramètres variables (les ingrédients, quantités, ustensiles utilisés) ainsi que des <em>instructions</em> (casser en morceaux, cuire au bain-marie, couper en dés). Enfin, le <em>résultat</em> obtenu lorsqu’on suit minutieusement cette recette de cuisine est le plat qu’on a alors préparé. Cette vision nous fournit une première définition du concept d’algorithme, donnée par Serge Abiteboul et Gilles Dowek<sup class="footnote-ref"><a href="#fn2" id="fnref2">2</a></sup> dans leur ouvrage “<em>Le temps des algorithmes</em>”.</p>
<blockquote>
<p>Un algorithme est un procédé qui permet de résoudre un problème, sans avoir besoin d’inventer une solution à chaque fois. Avec cette définition, il est clair que, depuis l’aube de l’humanité, nous inventons, utilisons et transmettons des algorithmes : cuisine, taille du silex, pêche à la ligne, culture des lentilles et du blé, etc.<sup class="footnote-ref"><a href="#fn3" id="fnref3">3</a></sup></p>
</blockquote>
<h3 id="les-algorithmes-dans-la-société">Les algorithmes dans la société</h3>
<p>Nous entretenons donc une relation quotidienne avec les algorithmes, et ce depuis l’aube de l’humanité. Toutefois, avec l’apparition de l’informatique au siècle dernier, les algorithmes se sont ancrés encore plus profondément dans nos vies. Au fil des années, ils se sont répandus de telle sorte qu’on les rencontre aujourd’hui partout, sans même nous en apercevoir. Abiteboul et Dowek établissent une liste d’usages variés d’algorithmes, qui existent aujourd’hui sous forme de programmes embarqués dans nos équipements numériques :</p>
<ul>
<li>le calcul : transformer des données – généralement des nombres –, résoudre des équations algébriques, encoder ou décoder un message ;</li>
<li>la gestion de l’information : stocker, archiver et indexer des données ;</li>
<li>la communication : faire circuler l’information via des <em>protocoles</em> de communication ;</li>
<li>l’exploration : parcourir un grand nombre de possibilités afin de définir celle qui correspond le mieux à un problème donné – plus court chemin, meilleure répartition, etc. – on appelle aussi cette méthode la recherche exhaustive ou “recherche par force brute”<sup class="footnote-ref"><a href="#fn4" id="fnref4">4</a></sup> ;</li>
<li>l’analyse des données : agréger des statistiques et les classifier, afin par exemple de prédire des comportements – suggestions, recommandations ou encore publicité ciblée grâce au <em>big data</em><sup class="footnote-ref"><a href="#fn5" id="fnref5">5</a></sup> ;</li>
<li>mais aussi : le traitement du signal (transformer, amplifier ou compresser une image ou un son), la commande d’un objet (établir la conduite d’une voiture autonome à partir des données captées), la fabrication de biens (automatiser la production industrielle), la modélisation et la simulation (dans la recherche scientifique, en établissant des théories) ;</li>
<li>et enfin, dans le champ du design, comme dans le cas d’intelligences artificielles mises au profit de la création.<sup class="footnote-ref"><a href="#fn6" id="fnref6">6</a></sup></li>
</ul>
<p>La présence croissante des algorithmes dans nos vies peut soulever des craintes – pour certaines justifiées – et en font aujourd’hui l’objet de débats sociétaux. <strong>Dans ce contexte, on tend toutefois à oublier une caractéristique fondamentale des algorithmes : ils sont écrits par des êtres humains</strong>. Les programmes que nous utilisons au quotidien sont conçus par des développeurs, qui emploient des outils spécifiques à leur tâche et mobilisent des savoirs associés à ces outils : mathématiques, connaissance des langages, gestion de projet, etc. Ce sont ces outils qui forment le domaine d’étude précis de ce mémoire, que je mène avec une approche dite “de design”, c’est-à-dire centrée sur les utilisateurs et les usages.</p>
<h2 id="lalgorithme-et-le-designer">L’algorithme et le designer</h2>
<h3 id="bricodage">Bricodage</h3>
<p>Les contextes d’application et problématiques envisageables liés à la programmation algorithmique – ou <em>code</em> – sont infiniment variés : conception de systèmes, développement d’objets numériques, création artistique, visualisation de l’immatériel, etc. <strong>En tant que designer, je souhaite m’intéresser plus particulièrement aux diverses pratiques mobilisant l’écriture de programmes informatiques dans un but créatif, aujourd’hui regroupées sous le terme de <em>creative coding</em></strong><sup class="footnote-ref"><a href="#fn7" id="fnref7">7</a></sup>.</p>
<p><strong>Mon étude concerne le codeur <em>amateur</em>, situé à mi-chemin entre le codeur néophyte et le développeur confirmé.</strong> En effet, je ne me concentre pas sur la question de l’apprentissage du code, qui concerne des novices – souvent des enfants. Ce contexte est au cœur de l’actualité, car l’enseignement du code se fait de plus en plus entendre comme un besoin essentiel de nos jours. De nombreux projets et programmes existent ou se développent, avec le souci commun de proposer une découverte pédagogique et accessible des nombreuses possibilités qu’offre la pratique du code, ce n’est pas l’objectif de ma recherche. Je ne traite pas non plus des méthodes de travail de développeurs confirmés, notamment car les domaines dans lesquels ils exercent, très pointus techniquement, ne relèvent que rarement d’une forme de créativité artistique – mais plutôt d’une créativité technique caractérisée par la recherche d’une méthode logicielle optimale pour répondre à un objectif donné. Le champ d’étude de ce mémoire se concentre donc sur le niveau médian à ces deux extrêmes : celui des développeurs créatifs hybrides, des designers-codeurs amateurs. J’appellerai cette catégorie de pratiquants les “bricodeurs”, pour reprendre le terme de “bricodage” que David-Olivier Lartigaud propose dans son article du même nom, paru dans l’ouvrage Art++.</p>
<blockquote>
<p>Le jeu de mot “bricoder” […] pourrait décrire l’attitude “esthétique” qui consiste à bricoler/programmer “l’objet informatique”. Le “bricodage” serait cette curiosité, ce désir d’ouvrir la “boîte noire” à des fins réflexives, artistiques ou esthétiques. Une approche de l’informatique “au-delà” du simple bidouillage qui offre “prise” sur la machine.<sup class="footnote-ref"><a href="#fn8" id="fnref8">8</a></sup></p>
</blockquote>
<p><img src="img/bricodeur.png" alt="Champ d’étude du mémoire"><em>Fig. 1 : Champ d’étude du mémoire</em></p>
<p>Lartigaud base sa définition du bricodage sur celle du bricolage, proposée par Claude Lévi-Strauss. Dans “<em>La pensée sauvage</em>”, celui-ci établit une distinction entre bricoleur et ingénieur.</p>
<blockquote>
<p>On pourrait être tenté de dire que [l’ingénieur] interroge l’univers, tandis que le bricoleur s’adresse à une collection de résidus d’ouvrages humains, c’est-à-dire à un sous-ensemble de la culture. […] La différence n’est donc pas aussi absolue qu’on serait tenté de l’imaginer ; elle demeure réelle, cependant, dans la mesure où […] l’ingénieur cherche toujours à s’ouvrir un passage et à se situer au delà, tandis que le bricoleur, de gré ou de force, demeure en deçà, ce qui est une autre façon de dire que le premier opère au moyen de concepts, le second au moyen de signes.<sup class="footnote-ref"><a href="#fn9" id="fnref9">9</a></sup></p>
</blockquote>
<p>Ainsi, l’ingénieur est, selon Lévi-Strauss, extérieur au monde dans lequel il développe son projet, tandis que le bricoleur, au contraire, fait partie du monde dans lequel il doit construire avec des “résidus d’ouvrages humains”, ou “moyens du bord”.</p>
<blockquote>
<p>Le bricoleur est apte à exécuter un grand nombre de tâches diversifiées ; mais […] son univers instrumental est clos, et la règle de son jeu est de toujours s’arranger avec les “moyens du bord”, c’est-à-dire un ensemble à chaque instant fini d’outils et de matériaux […].<sup class="footnote-ref"><a href="#fn10" id="fnref10">10</a></sup></p>
</blockquote>
<p>Par ailleurs, Lévi-Strauss voit le bricoleur comme une sorte d’esthète, prenant plaisir dans la simple combinaison nouvelle qu’il réalise : le résultat obtenu demeure secondaire, et la satisfaction du succès éventuel n’est pas primordiale. Ainsi, le bricoleur ne fait pas que résoudre des problèmes : il est également créateur, puisqu’il compose à partir d’éléments disparates. Il est donc à la fois technicien et créatif : une description qui convient tout autant au designer, se laissant surprendre et inspirer par l’inconnu et l’inattendu.</p>
<h3 id="concevoir-ses-outils">Concevoir ses outils</h3>
<p>Le bricodeur est donc un praticien pour qui le code n’est pas seulement un outil mais également un <em>matériau</em>, au même titre que le bois ou le métal pour un bricoleur. En manipulant ce matériau, il exerce une prise de recul consciente sur ses outils et sa propre pratique. Cette démarche permet de questionner ces mêmes outils, de les détourner, voire, en supposant que la variété des outils existants est parfois insuffisante – lorsque ceux-ci s’avèrent inadaptés à un objectif donné –, de concevoir ses propres outils.</p>
<p>Les logiciels traditionnels du design – par exemple la suite Adobe, dont la maîtrise est enseignée dans les écoles de design – contiennent et mettent à disposition des algorithmes rendus “invisibles”, délivrés sous la forme d’outils et fonctions, souvent métaphoriques : tracé, duplication, transformation ou encore processus passent par l’usage d’une “plume”, d’un “pinceau” ou d’un “lasso”. Cet ensemble de fonctionnalités, souvent regroupés dans des “barres d’outils”, peuvent être remis en question par le bricodeur qui conçoit ses propres alternatives. Les processus algorithmiques sont ainsi rendus visibles, ce qui est une première étape vers leur modification en tant que matériau<sup class="footnote-ref"><a href="#fn11" id="fnref11">11</a></sup>.</p>
<p>Cette philosophie peut être illustrée par la démarche de John Maeda. À la fois artiste, graphiste, enseignant et chercheur au MIT<sup class="footnote-ref"><a href="#fn12" id="fnref12">12</a></sup>, Maeda a acquis une renommée mondiale en tant que pionnier d’une discipline mêlant les arts plastiques, le design, la typographie et l’interactivité, avec pour moyens récurrents l’ordinateur et la programmation : il a particulièrement contribué au développement du <em>creative coding</em> avec la création du logiciel <em>Design By Numbers</em><sup class="footnote-ref"><a href="#fn13" id="fnref13">13</a></sup>, qui donna naissance à <em>Processing</em><sup class="footnote-ref"><a href="#fn14" id="fnref14">14</a></sup>. Ainsi, le cœur de la démarche de Maeda est de créer les dispositifs avec lesquels il produit ensuite des œuvres, notamment graphiques. Comme l’écrit Paola Antonelli dans la préface de l’ouvrage de Maeda “<em>Design By Numbers</em>”, “la partie la plus importante de sa production, et celle dont il est le plus fier, n’est pas l’objet final, mais plutôt le processus.” L’auteure italienne précise l’idée fondamentale de Maeda : <strong>“pour bien <em>designer</em> avec un ordinateur, il faut créer soi-même le programme que l’on utilise – ou à défaut, le comprendre.”</strong><sup class="footnote-ref"><a href="#fn15" id="fnref15">15</a></sup></p>
<p>Parue en 2012, la dix-huitième édition de la publication “<em>Graphisme en France</em>”, intitulée “<em>code &lt;&gt; outils &lt;&gt; design</em>”, traite dans une série d’interviews, menée par Casey Reas et Chandler McWilliams,  de cette question spécifique de la création d’outils individuels.</p>
<blockquote>
<p>Nous avons posé deux questions […] :</p>
<ul>
<li>Pourquoi écrivez-vous vos logiciels plutôt que d’utiliser des outils existants ?</li>
<li>En quoi le fait d’écrire vos propres logiciels affecte-t-il votre processus de création et les qualités visuelles de l’œuvre finale ?</li>
</ul>
<p>[…] Réponse la plus courante : le fait d’écrire soi-même ses programmes permet un meilleur contrôle, lequel est souvent présenté comme une <em>liberté</em> individuelle. Autre thème récurrent : écrire ses logiciels est un moyen de s’éloigner des solutions <em>génériques</em>. Les nouveaux outils sont synonymes de nouvelles opportunités. […] En créant de tels outils, uniques, les créateurs s’ouvrent de nouveaux horizons.<sup class="footnote-ref"><a href="#fn16" id="fnref16">16</a></sup></p>
</blockquote>
<p>Quels sont donc les outils génériques qui constituent l’environnement technique du designer-codeur amateur, ou <em>bricodeur</em>, et quels sont les outils innovants ? Comment le créatif interagit-il avec ces interfaces numériques ? Quels sont les cadres conventionnels de l’écriture du code, et quels autres cadres alternatifs, peuvent exister ? Et pour quels bénéfices ? Telles sont les questions qui animent ce mémoire, qui s’inscrit dans la continuité des initiatives de Maeda et s’articule autour d’une question similaire : <strong>comment faciliter<sup class="footnote-ref"><a href="#fn17" id="fnref17">17</a></sup> et encourager<sup class="footnote-ref"><a href="#fn18" id="fnref18">18</a></sup> l’intégration de processus algorithmiques dans une pratique créative ?</strong></p>
<h1 id="le-matériau-algorithme">Le matériau algorithme</h1>
<p>Je reviens à la définition d’un algorithme donnée en introduction : “un algorithme est une séquence d’instructions qui vise à être exécutée afin de produire un résultat”. Dans cette vision générique s’inscrit une catégorie plus réduite d’algorithmes spécifiques, un ensemble que l’on nomme “algorithmes <em>symboliques</em>”.<sup class="footnote-ref"><a href="#fn19" id="fnref19">19</a></sup> <strong>La spécificité des algorithmes symboliques est qu’ils <em>manipulent</em> des symboles <em>écrits</em></strong> : chiffres, lettres, assemblés en nombres, en mots et en phrases, et vecteurs de sens.<sup class="footnote-ref"><a href="#fn20" id="fnref20">20</a></sup> Deux notions clés se dessinent ici :</p>
<ul>
<li>celle de l’écriture, d’abord, qui s’impose comme le moyen, le processus de manipulation du matériau algorithmique – j’y reviendrai dans un second temps ;</li>
<li>et celle de la manipulation, exercée par le biais d’instructions : si un algorithme est une séquence d’instructions, qu’est-ce qu’une instruction ?</li>
</ul>
<h2 id="algorithme-et-instruction">Algorithme et instruction</h2>
<p>Le sens du terme “instruction” est double : il s’agit à la fois de l’action d’<em>instruire</em>, au sens de “former l’esprit”, et dans un second temps, de l’<em>ordre</em> donné, qui dispose – qui met quelque chose dans une disposition en vue d’un résultat.</p>
<h3 id="linstruction-comme-action-dinstruire">L’instruction comme action d’instruire</h3>
<p>Selon le <abbr title="Centre National de Ressources Textuelles et Lexicales">CNRTL</abbr>, le premier sens du terme “instruction” fait donc référence à l’enseignement, au fait de “former l’esprit, la personnalité de quelqu’un par une somme de connaissances liées à l’expérience, à la vie, aux événements”. Cette notion de <em>formation</em> de l’esprit découle directement de l’étymologie latine du verbe “instuire” : <em>instruere</em> signifie “assembler, élever, bâtir, munir, outiller”. Ainsi, <em>s’instruire</em> veut dire “acquérir la connaissance, l’expérience”. Dans un sens métonymique, une instruction fait également référence à son contenu, à ce qui doit être fait, voire au fait même de suivre l’instruction. Cela nous amène au second sens du terme “instruction”, celui de l’<em>ordre</em>.</p>
<h3 id="linstruction-comme-ordre">L’instruction comme ordre</h3>
<p>L’instruction est, dans un sens métonymique, un discours indiquant <em>ce qui doit être fait</em>. L’instruction comme <em>ordre</em> soulève donc un sens presque militaire : instruire des soldats signifie leur faire acquérir les connaissances théoriques et pratiques, les qualités physiques et morales nécessaires à l’accomplissement de leur mission. Chez l’animal, on parle de “dresser”. L’ordre fait appel à une procédure protocolaire d’actions : on met quelqu’un ou quelque chose dans une disposition en vue d’un résultat défini.</p>
<p>Selon cette définition, un algorithme peut ainsi être perçu comme un ensemble d’instructions qui disposent – ou <em>gouvernent</em> selon le philosophe américain Alexander R. Galloway<sup class="footnote-ref"><a href="#fn21" id="fnref21">21</a></sup> – des actions, mais surtout des opérations. <strong>Quelles sont alors les instructions fondamentales d’un algorithme ?</strong></p>
<h2 id="quatre-instructions-fondamentales">Quatre instructions fondamentales</h2>
<p>Les algorithmes se ressemblent : ils sont constitués d’un nombre restreint d’expressions structurantes similaires, que l’on retrouve fréquemment, agencées différemment selon la finalité recherchée. <strong>Selon Abiteboul et Dowek, n’importe quel algorithme symbolique peut être exprimé à partir de quatre instructions élémentaires : la séquence, l’affectation, l’itération et la condition.</strong><sup class="footnote-ref"><a href="#fn22" id="fnref22">22</a></sup> Je développe et illustre ci-après ces quatre instructions sous le prisme de leur usage en programmation informatique.</p>
<h3 id="séquence">Séquence</h3>
<p><img src="img/sequence.png" alt="Séquence"><em>Fig. 2 : Séquence</em></p>
<p><strong>La <em>séquence</em> est l’ordre même dans lequel les instructions sont agencées, c’est-à-dire la structure de l’algorithme elle-même : “fait <em>ceci</em>, puis <em>cela</em>”.</strong> Lorsqu’il est représenté – c’est-à-dire écrit ou dessiné –, on lit classiquement un algorithme de haut en bas, conformément au sens de lecture de nombreux langages.<sup class="footnote-ref"><a href="#fn23" id="fnref23">23</a></sup> Il est possible de s’émanciper, d’une certaine manière, de cette séquence, notamment en spécifiant expressément à l’algorithme d’éluder une partie des instructions dans certains cas précis. On groupe alors les instructions en ensembles – que l’on peut appeler des <em>fonctions</em> –, auxquels on peut ensuite faire référence. La “tête de lecture” de l’algorithme, ou son <em>positionnement</em> à un instant donné de son exécution – qui est extrêmement rapide mais pas instantanée –, ne déroule donc pas nécessairement la structure de cet algorithme de manière linéaire : elle peut effectuer des aller-retours, sauter des parties, y revenir, etc.</p>
<h3 id="affectation">Affectation</h3>
<p><img src="img/affectation.png" alt="affectation"><em>Fig. 3 : Affectation</em></p>
<p><strong>L’affectation est le fait d’attribuer une valeur à une <em>variable</em> – par exemple, “<em>a</em> prend la valeur de <em>b</em>”.</strong> Une variable est constituée d’un nom (son identifiant) et d’une valeur unique à chaque instant. Cette valeur peut être numérique (un nombre entier ou décimal, naturel ou relatif), textuelle (un caractère ou une chaîne de caractères) ou encore un booléen : vrai (<em>true</em>) ou faux (<em>false</em>).<sup class="footnote-ref"><a href="#fn24" id="fnref24">24</a></sup> Une variable peut également accueillir un ensemble de données comme un tableau (<em>array</em> en anglais). Comme son nom l’indique, une <em>variable</em> peut prendre plusieurs valeurs au cours du temps, à l’exception des constantes – dont la valeur est figée.</p>
<h3 id="itération">Itération</h3>
<p><img src="img/iteration.png" alt="Itération"><em>Fig. 4 : Itération</em></p>
<p><strong>L’itération, communément appelé <em>boucle</em>, est le fait de répéter une série d’instructions</strong>. Ce concept est fondamental, puisque les algorithmes ont généralement pour but d’automatiser des tâches répétitives. On trouve plusieurs types de boucles, en voici une liste non exhaustive :</p>
<ul>
<li>la boucle “pour” (<em>for loop</em> en anglais), qui exécute les instructions pour un nombre donné d’itérations : “répète 10 fois <em>ceci</em>” ;</li>
<li>la boucle “tant que” (<em>while</em> en anglais), qui exécute les instructions tant qu’un énoncé est valide : “tant que <em>ceci</em> est vrai, fait <em>cela</em>” ;</li>
<li>la boucle “pour chaque” (<em>for each</em> en anglais), qui exécute les instructions pour chaque entité d’une liste (des contacts dans un annuaire par exemple) : “<em>pour</em> chaque <em>ceci</em>, fait <em>cela</em>”.</li>
</ul>
<h3 id="condition">Condition</h3>
<p><img src="img/condition.png" alt="Condition"><em>Fig. 5 : Condition</em></p>
<p><strong>Enfin, la condition, ou <em>test conditionnel</em>, permet d’effectuer ou non une instruction – ou série d’instructions – selon la valeur d’une variable donnée : par exemple, “si <em>ceci</em> est vrai, faire <em>cela</em>”.</strong> On appelle généralement <em>expression conditionnelle</em> le schéma “si, alors, sinon” (<em>if, then, else</em>). De plus, on trouve parfois dans ces structures un nombre plus ou moins important d’expressions du type <em>sinon si</em> (<em>else if</em>), qui permettent des conditions imbriquées. Ici encore, cette notion est extrêmement importante, en cela qu’elle permet à un algorithme de prendre des chemins différents, de s’adapter à la complexité éclectique des données réelles qui lui sont fournies, et ainsi d’être plus polyvalent. À noter qu’on peut faire prendre des chemins différents à un algorithme en prenant comme conditions des valeurs générées aléatoirement : “choisis un nombre entre 1 et 10, s’il est supérieur à 5, fais <em>ceci</em>, sinon, fais <em>cela</em>”.</p>
<p>Puisque l’algorithme dispose de ces quatre opérations fondamentales, qui peuvent être instruites, celles-ci peuvent être concrétisées et réalisées par une machine. Ansi, le sens de l’algorithme est virtuel tant qu’il n’a pas été actualisé par la machine, qui exécutera les instructions initialement abstraites : <strong>quelles sont ces concrétisations techniques, ces machines qui exécutent des algorithmes ?</strong></p>
<h2 id="concrétisation-techniques-et-historiques">Concrétisation techniques et historiques</h2>
<p>Je propose à présent une approche chronologique : <strong>quelles machines capables d’exécuter des algorithmes l’Homme a-t-il inventées ?</strong> Comment, et via quels progrès techniques, les algorithmes – symboliques – ont-ils évolué ? Cette question sera particulièrement traitée en focalisant l’étude sur les outils mis en œuvre au fil des époques.</p>
<h3 id="de-la-main-à-la-machine">De la main à la machine</h3>
<p>Remontons aux origines des algorithmes symboliques, il y a 5&nbsp;000 ans. À cette époque, les mathématiciens ont déjà mis au point des algorithmes servant à résoudre des calculs algébriques simples tels que des additions et des multiplications, mais ceux-ci sont exécutés à la main par les scribes. <strong>Des tâches répétitives qu’on aurait tout intérêt à déléguer aux machines, afin que celles-ci s’effectuent <em>mécaniquement</em>.</strong></p>
<p>S’ensuivent cinq millénaires d’innovations techniques. Les premiers abaques<sup class="footnote-ref"><a href="#fn25" id="fnref25">25</a></sup>, suivis quelques siècles plus tard de leurs proches dérivés, les bouliers, assistent les hommes dans ces calculs mais ne sont pas encore autonomes. Au Moyen Âge, les cloches au sommet des cathédrales sonnent chaque heure sans intervention humaine : ce sont les premières machines capables d’exécuter des algorithmes symboliques. En 1642, l’inventeur français Blaise Pascal<sup class="footnote-ref"><a href="#fn26" id="fnref26">26</a></sup> met au point la première machine à calculer, qu’il nomme “machine arithmétique” ; elle est retravaillée quelques 30 ans plus tard par Gottfried Leibniz<sup class="footnote-ref"><a href="#fn27" id="fnref27">27</a></sup> qui y ajoute une interface permettant de réaliser de façon automatique des multiplications et des divisions. Leibniz définit formellement la machine arithmétique par sa caractéristique universelle au sein du <em>calculus ratiocinator</em>, une machine calculatoire théorique.</p>
<h3 id="jacquard-ou-le-tissage-programmé">Jacquard, ou le tissage programmé</h3>
<p>En 1801, l’inventeur lyonnais Joseph Jacquard met au point un système de métier à tisser qui portera son nom : le fameux “métier Jacquard”. Celui-ci combine les métiers à tisser classiques avec le principe de cartes perforées inventé en 1728 par Jean-Baptiste Falcon – qui lui-même reprenait l’idée des rubans perforés que Basile Bouchon, son maître, proposait trois ans plus tôt. En perçant ou non un trou à un emplacement spécifique d’une carte, on peut programmer la machine : une fois insérée en <em>entrée</em> de la machine,  les cartes guident les crochets qui soulèvent les “fils de chaînes” – dont l’agencement produit le motif sur le textile tissé. <strong>Ce dispositif est souvent considéré comme la première forme de stockage d’informations binaires (<em>tout</em> ou <em>rien</em>, <em>vrai</em> ou <em>faux</em>), et le métier Jacquard comme l’ancêtre de l’ordinateur.</strong></p>
<p>Ce procédé laborieux de perforation est peut-être une des raisons pour lesquelles certaines personnes non initiées s’imaginent qu’un “informaticien” code en tapant des séries de 0 et de 1. Il semble toutefois important de distinguer l’unité d’information <em>binaire</em> “un trou ou un plein” de celle qui constitue la base de l’informatique moderne : le <em>bit</em><sup class="footnote-ref"><a href="#fn28" id="fnref28">28</a></sup>. En effet, une nuance importante s’observe sur la dimension physique de ces deux types d’unités : le trou et le plein peuvent être vus, touchés, respectivement rebouché ou perforé : en bref, ils sont tangibles. Le bit informatique, lui, nous est invisible et impalpable – à notre échelle, “à l’œil”. Par ailleurs, un trou ou un plein, dans la conscience du tisserand, est interprété comme un résultat : il peut être visualisé comme la présence ou l’absence d’une maille à un endroit précis du motif. <strong>Dans le cas des cartes perforées, une parfaite connaissance et maîtrise du matériel est donc essentielle à la programmation.</strong> À l’inverse en informatique, le programmeur ne se soucie – généralement – pas du stockage et de la transmission de l’information binaire.</p>
<h3 id="la-machine-analytique-de-babbage">La machine analytique de Babbage</h3>
<p>Si le métier Jacquard est parfois considéré comme l’ancêtre de l’ordinateur, ces machines ne sont pas encore des ordinateurs à proprement parler. Il leur manque pour atteindre ce statut une caractéristique majeure : l’universalité. En effet,  les machines citées plus haut en exemples sont chacune destinée à une unique fonction ; là où un ordinateur est polyvalent, <em>universel</em>, capable d’exécuter n’importe quel algorithme symbolique imaginable : en résumé, une “machine à tout faire”.</p>
<p><strong>Au cours du XX<sup>ème</sup> siècle, l’apparition des premières <em>machines analytiques</em> va transformer les usages des algorithmes.</strong> En 1834, le visionnaire britannique Charles Babbage<sup class="footnote-ref"><a href="#fn29" id="fnref29">29</a></sup> débute le développement d’une machine d’un concept alors nouveau, qu’il qualifie de “machine analytique”. Celle-ci reprend le principe des machines à calculer mécaniques qui existent alors depuis plusieurs siècles déjà. Mais l’inventeur a l’idée d’ajouter à ces systèmes le principe des cartes perforées apparues avec les métiers Jacquard. Les composants de cette machine sont similaires à ceux qui équipent un ordinateur moderne.<sup class="footnote-ref"><a href="#fn30" id="fnref30">30</a></sup></p>
<p>Pendant qu’il travaille sur ce projet, Babbage entre en correspondance avec Ada Lovelace. Pionnière de la science informatique, c’est elle qui, en 1843, sera à l’origine du premier algorithme destiné à être exécuté sur une machine : la machine à différences de Charles Babbage. Cet algorithme, considéré comme le premier programme informatique à proprement parler, sert alors à calculer la suite des nombres de Bernouilli<sup class="footnote-ref"><a href="#fn31" id="fnref31">31</a></sup>. Ada Lovelace est ainsi connue comme la première programmeuse de l’histoire.</p>
<h3 id="la-révolution-turing">La révolution Turing</h3>
<p>Les travaux de Lovelace et Babbage trouvent écho un siècle plus tard, dans les années 1930, grâce notamment aux recherches d’Alan Turing<sup class="footnote-ref"><a href="#fn32" id="fnref32">32</a></sup>. Cet inventeur, figure emblématique de la recherche mathématico-scientifique du XX<sup>ème</sup> siècle, conçoit en 1936 la “machine de Turing”, en vue de donner une définition précise au concept d’algorithme et à sa représentation formelle et technique de “procédure mécanique”.</p>
<blockquote>
<p>[La machine de Turing] consiste en deux éléments principaux :</p>
<ol>
<li>une machine représentée par une tête de lecture/écriture susceptible de se trouver dans un nombre fini d’états,</li>
<li>une bande (magnétique par exemple) de longueur infinie […] devant laquelle se meut la tête de lecture et qui alimente en données cette machine. […]</li>
</ol>
<p>Turing montre qu’une partie de la bande peut contenir la description de la table d’actions élémentaires d’une autre machine de Turing : une machine peut en simuler une autre. C’est grâce à cette construction schématique […] que Turing peut démontrer qu’il existe des machines de Turing dites universelles capables d’imiter toute autre machine de Turing.<sup class="footnote-ref"><a href="#fn33" id="fnref33">33</a></sup></p>
</blockquote>
<p>Turing illustre ainsi la notion d’<em>universalité</em> telle qu’elle avait été formulée par Lovelace et Babbage : après la machine de Turing, il illustre la machine <em>universelle</em> de Turing, considérée comme la genèse des travaux de John von Neumann. En effet, ce mathématicien et physicien américano-hongrois propose en 1945  un modèle utilisé encore aujourd’hui dans nos ordinateurs modernes : l’architecture de von Neumann<sup class="footnote-ref"><a href="#fn34" id="fnref34">34</a></sup>.</p>
<p><img src="img/neumann.png" alt="Architecture de von Neumann"><em>Fig. 6 : Architecture de von Neumann</em></p>
<p>En transposant ces composantes dans notre vocabulaire matériel contemporain, on confirme la proximité entre ce modèle, vieux de plus de 70 ans, et les ordinateurs que nous utilisons au quotidien :</p>
<ul>
<li>le processeur effectue les opérations ;</li>
<li>la mémoire vive (<abbr title="Random Access Memory">RAM</abbr>) stocke les données en cours d’utilisation ; et les disques durs – ou autres supports de stockage – contiennent des données pérennes ;</li>
<li>les périphériques en tout genre permettent l’interaction en <em>entrée</em> (clavier, souris, écran tactile, microphone, caméra, port <abbr title="Universal Serial Bus">USB</abbr>, lecteur de disque, etc.) et en <em>sortie</em> (écran, haut-parleurs, etc.)</li>
</ul>
<p>Nous arrivons à ce stade à l’ordinateur tel que nous le connaissons, appareil nécessaire à la programmation algorithmique, capable d’exécuter des logiciels. <strong>On pourra donc considérer que l’ordinateur est la machine du programmeur, mais une machine universelle, capable de simuler elle-même un <em>environnement</em> d’outils – les logiciels de programmation.</strong></p>
<p>Or, ce sont ces logiciels de programmation qui permettant la manipulation du matériau algorithmique, et cette manipulation passe par l’action de programmer : <strong>pour être exécutés par la machine, les algorithmes doivent être écrits.</strong> Cette remarque conclut cette première partie sur ce qu’est le matériau algorithme, et me permet de me focaliser à présent sur sa manipulation : l’écriture algorithmique.</p>
<h1 id="lécriture-algorithmique">L’écriture algorithmique</h1>
<p>Afin d’être exécutés par une machine, les algorithmes doivent être transposés de l’intelligence du programmeur vers un support pérenne et interprétable par cette machine. <strong>Parce que les ordinateurs ont été conçus pour manipuler des symboles, la méthode de communication qui s’est naturellement imposée est l’écriture.</strong> Programmer, vu de l’extérieur, c’est avant tout taper une succession de lettres et de chiffres sur un clavier : dans cette partie, je m’intéresse donc à cette action d’écriture.</p>
<h2 id="quest-ce-quécrire-">Qu’est-ce qu’écrire ?</h2>
<h3 id="lécriture-formalisation-du-langage">L’écriture, formalisation du langage</h3>
<p><strong>L’écriture est une méthode de communication qui consiste à représenter un langage via l’inscription de signes graphiques sur des supports variés.</strong> En cela, elle est une forme d’inscription, tel que le terme est défini par Bruno Bachimont.</p>
<blockquote>
<p>L’écriture, que nous prenons de manière large comme un système graphique permettant de constituer des inscriptions visant à véhiculer une signification. Elle associe donc un substrat matériel à une forme d’expression : de l’encre sur du papier mobilisé conformément à la forme textuelle par exemple.<sup class="footnote-ref"><a href="#fn35" id="fnref35">35</a></sup></p>
</blockquote>
<p>L’écriture est née quatre millénaires avant notre ère, en Mésopotamie, afin de conserver des traces d’échanges – notamment commerciaux –, la mémoire humaine n’étant pas infaillible et encore moins illimitée. Le philosophe François Dagognet nous rappelle l’adage latin : “<em>Verba volant, scripta manent</em>” – les paroles s’envolent, les écrits restent.<sup class="footnote-ref"><a href="#fn36" id="fnref36">36</a></sup> Mais Dagognet souligne aussi que dans ce transfert de la parole à l’écrit, le discours n’est pas forcément transcrit scrupuleusement, mais peut au contraire subir des modifications.</p>
<blockquote>
<p>De ce que le vocalisé s’insinue dans le texte et aide à le comprendre, il ne s’ensuit pas que l’imprimé ne le dépasse pas. Si le graphisme ne supprime pas entièrement le gestuel, il l’amoindrit, tend à l’éloigner, voire à l’enjamber.<sup class="footnote-ref"><a href="#fn37" id="fnref37">37</a></sup></p>
</blockquote>
<p>En résumant sa pensée, je retiendrai ceci : si l’écriture découle de la parole comme une nouvelle forme d’échange communicationnel, elle n’en est pas une forme strictement identique. Un énoncé vocal ne transmet pas seulement la nature de l’énoncé, mais également sa forme – la tonalité, la prononciation, l’attitude –, au même titre que la représentation graphique joue sur des variations de représentation – graphie, tracé, composition, contraste – pour véhiculer une information qui enrichit le contenu même de l’écrit. Ce propos rejoint la thèse d’Anne-Marie Christin, professeure spécialiste de l’écriture et des relations entre texte et image. Selon elle, l’écriture ne reproduit pas la parole, mais la rend visible : <strong>elle est le résultat de la fusion entre le langage, qui régit les échanges à l’intérieur d’un groupe, et l’image, composée de figures et de supports.</strong><sup class="footnote-ref"><a href="#fn38" id="fnref38">38</a></sup></p>
<p><strong>L’écriture présuppose donc un emploi du langage.</strong> Selon le <abbr title="Trésor de la Langue Française informatisé">TLFi</abbr>, le terme <em>langage</em> implique une définition multiple, selon que l’on parle du langage comme faculté et comme système, ou bien comme moyen d’expression, comme usage. Un langage est généralement doté d’une sémantique, et fréquemment d’une syntaxe – deux branches de la linguistique symétriquement opposées. La sémantique étudie les <em>signifiés</em> : ce dont on parle, ce que l’on cherche à transmettre – en résumé, le <em>fond</em> de l’énoncé. La syntaxe, pour sa part, se concentre sur le <em>signifiant</em> : la langue, la représentation graphique, la grammaire employée, etc. – en résumé, la <em>forme</em> de l’énoncé.<sup class="footnote-ref"><a href="#fn39" id="fnref39">39</a></sup></p>
<p>En conclusion de la définition de l’écriture, je citerai à nouveau Bruno Bachimont qui distingue l’écriture algorithmique comme singulière. Il établit trois <em>raisons</em> – méthodes de raisonnements – : la raison orale, la raison graphique et la raison computationelle. L’écriture algorithmique appartient à cette troisième catégorie.</p>
<blockquote>
<p>L’hypothèse que nous formulons est que l’informatique, sous la forme des systèmes formels automatiques, fournit précisément un nouveau type de support, les supports dynamiques, auquel doit correspondre un type spécifique de synthèse, et par conséquent une rationalité spécifique, que nous proposons de baptiser “raison computationnelle”.</p>
</blockquote>
<h3 id="trois-typologies-décriture">Trois typologies d’écriture</h3>
<p>La notion d’écrit, au sens large, désigne donc les diverses formes que peuvent prendre la traduction graphique de l’information communiquée : dessins, symboles, chiffres, lettres, etc. Toutefois, <strong>le sens généralement admis du terme <em>écrit</em> désigne trois grandes catégories de systèmes : logographique, syllabique et alphabétique.</strong></p>
<ul>
<li><strong>l’écriture logographique</strong> emploie des <em>logogrammes</em>, caractères – ou <em>glyphes</em> – représentant un mot ou un <em>morphème</em> – une fraction de mot. Plus précisément, on parle d’un <em>pictogramme</em> lorsqu’on représente directement un objet (par exemple, le blé), et d’un idéogramme lorsqu’on cherche à symboliser une idée (par exemple, la vitalité).</li>
<li><strong>l’écriture syllabique</strong> emploie un <em>syllabaire</em>, composés de symboles exprimant chacun une syllabe. Les différentes formes d’écritures chinoises et japonaises en sont les exemples les plus courants.</li>
<li>enfin, <strong>l’écriture alphabétique</strong> est celle que nous connaissons le mieux, pour l’utiliser quotidiennement. Elle utilise un ensemble de symboles, dont chacun représente un phonème – plus petite entité linguistique –, composés de manière à former des mots. Une trentaine de signes alphabétiques suffisent généralement à écrire une langue.<sup class="footnote-ref"><a href="#fn40" id="fnref40">40</a></sup></li>
</ul>
<p><ins>L’écriture algorithmique appartient classiquement à cette troisième catégorie : <strong>quelle forme prendrait la programmation si l’on changeait de catégorie, en préférant par exemple une écriture logographique ?</strong> Je propose une première réponse à cette question avec une expérimentation intitulée “<em>emoji2code</em>”, permettant de coder à partir d’un enchaînement d’emoji. Ici, l’écriture n’est pas <em>classique</em> – on ne tape pas sur les touches du clavier pour former des mots et des phrases –, il est d’avantage question de <em>composition</em><sup class="footnote-ref"><a href="#fn41" id="fnref41">41</a></sup> : il suffit de cliquer sur un emoji pour le voir apparaître dans la zone de saisie. Chaque emoji correspond à une instruction (par exemple “boucler”, “écrire dans la console”) ou un élément (une variable, une opération mathématique). Dans l’exemple ci-dessous, je réalise simplement une boucle permettant de compter de 0 à 9.
<img src="img/emoji2code.png" alt="emoji2code, une interface d’écriture algorithmique à l’aide d’emoji"><em>Fig. 7 : emoji2code, une interface d’écriture algorithmique à l’aide d’emoji</em></ins></p>
<h3 id="la-littérature-ou-lart-écrit">La littérature, ou l’art écrit</h3>
<p>La pratique de l’écriture se place comme acte fondateur de la littérature. Par “littérature”, j’entends la conception de l’écriture comme une forme d’art. Cet art recouvre de nombreux genres et styles : genre pictural, genre narratif, genre dramatique, contenu, ou encore registre.<sup class="footnote-ref"><a href="#fn42" id="fnref42">42</a></sup></p>
<p>Nul besoin de traiter en détail les formes d’écritures que nous connaissons le mieux : page par page, alignant des mots dans un alphabet latin, de la gauche vers la droite et du haut vers le bas. <strong>Pour questionner le potentiel créatif de la pratique de l’écriture, je m’intéresse plus particulièrement à ses représentations alternatives, non-conventionnelles.</strong> Pour Anne-Marie Christin, l’exemple le plus pertinent qui a libéré l’écriture occidentale est une œuvre de Stéphane Mallarmé, poète français du XIX<sup>ème</sup>siècle. On le décrit aujourd’hui comme un des premiers “poèmes typographiques”.</p>
<blockquote>
<p>Tout a changé dans la pensée occidentale de l’écrit avec le <em>Coup de Dés</em> de Mallarmé. Pour la première fois de leur histoire, les héritiers de l’alphabet que nous sommes ont pris conscience du fait qu’ils ne disposaient pas simplement, avec ces quelques signes, d’un moyen plus ou moins commode de transcrire graphiquement leur parole mais d’un instrument complexe, double, auquel il suffisait de réintégrer la part visuelle – spatiale – dont il avait été privé pour lui restituer sa plénitude active d’écriture.<sup class="footnote-ref"><a href="#fn43" id="fnref43">43</a></sup></p>
</blockquote>
<p><img src="img/mallarme.png" alt="Extrait du &quot;Coup de Dés&quot; de Mallarmé"><em>Fig. 8 : Extrait du "Coup de Dés" de Mallarmé</em></p>
<p>Ici, le fait de <em>voir</em> le poème participe à sa lecture et à sa compréhension : l’ordonnancement du poème figure le poème même. Sur le même principe, le poète français Guillaume Apollinaire publie en 1918 un ouvrage intitulé “<em>Calligrammes</em>”, terme qu’il invente à partir de la contraction de <em>calligraphie</em> – l’art graphique du dessin de caractères – et d’<em>idéogramme</em>. Cette forme particulière de poésie est parfois nommée “poésie graphique”.</p>
<p><img src="img/calligramme-apollinaire.png" alt="Calligramme &quot;Il Pleut&quot; d’Apollinaire"><em>Fig. 9 : Calligramme "Il Pleut" d’Apollinaire</em></p>
<p>On notera que François Dagognet classe le travail d’Apollinaire dans une catégorie qu’il intitule “<em>iconographies ordinatrices et inventives</em>”. Celle-ci est constituée de productions graphiques et littéraires qui font usage de <em>métaboles</em>, terme qu’il emprunte au groupe µ<sup class="footnote-ref"><a href="#fn44" id="fnref44">44</a></sup> dans son ouvrage “<em>Réthorique Générale</em>” : un métabole désigne tout espèce de changement du langage.<sup class="footnote-ref"><a href="#fn45" id="fnref45">45</a></sup> Comme dans beaucoup de pratiques créatives, la nouveauté passe donc par le changement, l’émancipation des artistes vis-à-vis des formes ordinaires, au profit de formes nouvelles, alternatives.</p>
<p><ins><strong>En reportant ces distinctions au champ des algorithmes, on pourrait facilement s’interroger sur la forme que pourrait prendre une “écriture alternative” d’un algorithme, comme par exemple une écriture <em>poétique</em></strong>, c’est-à-dire une écriture qui privilégie l’expressivité de la forme – les mots disant plus qu’eux-mêmes par leur choix et leur agencement. Le livre “<em>./code --poetry</em>” de Daniel Holden et Chris Kerr, ainsi que le site web associé<sup class="footnote-ref"><a href="#fn46" id="fnref46">46</a></sup>, présentent des exemples de programmes s’affranchissant des conventions habituelles – j’y reviendrai – et dont le résultat est essentiellement esthétique : en résumé, du “code poétique” qui ouvre la voie à une <em>littérature algorithmique</em><sup class="footnote-ref"><a href="#fn47" id="fnref47">47</a></sup>, qui traite le code comme matière. On peut notamment citer pour exemple <a href="http://code-poetry.com/flocking"><em>Flocking.go</em></a>, un programme dans le langage Go, mêlant poésie classique et algorithmique, pour un résultat animé qui fait écho avec la sémantique du texte.<br>
<img src="img/code-poetry.png" alt="Flocking.go, un programme poétique animé dans le langage Go"><em>Fig. 10 : Flocking.go, un programme poétique animé dans le langage Go</em></ins></p>
<h2 id="lécriture-algorithmique-1">L’écriture algorithmique</h2>
<p>Attardons-nous davantage sur la spécificité de l’écriture dans le cas d’un programme informatique : <strong>quelle différence y a-t-il entre l’action de coder et la rédaction d’un article ou d’un poème ?</strong> On notera tout d’abord que dans ce contexte informatique, les algorithmes prennent la forme de programmes, rédigés dans un langage de programmation spécifique, grâce à un ordinateur. Toutefois, <em>algorithme</em> et <em>programme</em> sont deux notions différentes bien qu’étroitement liées, tout comme <em>informatique</em> et <em>ordinateur</em> : il convient donc de les clarifier.</p>
<h3 id="de-lordinateur-à-linformatique">De l’ordinateur à l’informatique</h3>
<p>La définition du terme “ordinateur”, dans son sens admis populairement, se base sur les travaux d’Alan Turing.</p>
<blockquote>
<p>Un ordinateur est un système de traitement de l’information programmable tel que défini par Turing et qui fonctionne par la lecture séquentielle d’un ensemble d’instructions, organisées en programmes, qui lui font exécuter des opérations logiques et arithmétiques.</p>
</blockquote>
<p>Les composants technologiques des ordinateurs modernes traitent des informations <em>binaires</em>. Là où les cartes perforées de Falcon utilisaient des trous ou des pleins pour signifier un des deux états uniques qui composent un <em>bit</em>, nos ordinateurs, dont le fonctionnement est basé sur l’électricité, utilisent pour signifier une valeur la présence ou l’absence de courant, de charge ou de tension électrique – suivant qu’il soit question de stocker ou de transmettre une donnée.</p>
<p>Les racines mathématiques de l’<em>ordinateur</em> se retrouvent dans l’étymologie même du terme. En 1955, Fançois Girard, responsable du service publicité d’<abbr title="International Business Machines">IBM</abbr> France, fait appel à son ancien professeur de lettres, Jacques Perret, afin de trouver ensemble une traduction au mot anglais “computer”. Perret propose alors l’appellation “ordinatrice électronique”, inspirée de l’<em>ordonnateur</em>, ce composant de la machine décrit par Babbage comme celui qui “prend et reporte les nombres, et les soumet à l’opération demandée”. L’intitulé est ensuite simplifié en <em>ordinateur</em> et entre rapidement dans le langage populaire.</p>
<p>La notion d’informatique est intimement liée à l’univers des ordinateurs. Si en anglais, ordinateur se dit “computer”, la notion d’informatique est tout simplement désignée par la formule “computer science” – <em>to compute</em> signifiant <em>calculer</em> en français. Certains penseurs affirment toutefois que l’on ne peut pas définir l’informatique comme “la science des ordinateurs”. On attribue notamment à Edsger Dijkstra, informaticien néerlandais reconnu, l’aphorisme suivant : <strong>“L’informatique n’est pas plus la science des ordinateurs que l’astronomie n’est celle des télescopes.”</strong> Les auteurs de cette phrase sont en réalité Michael Fellows et Ian Perberry, et la citation complète – traduite – est la suivante :</p>
<blockquote>
<p>L’informatique n’est pas plus la science des ordinateurs que l’astronomie n’est celle des télescopes, la biologie celle des microscopes, ou la chimie celle des <em>béchers</em> et des tubes à essais. La science ne traite pas des outils. Elle traite de notre manière de les utiliser, et de ce que l’on découvre en les utilisant.<sup class="footnote-ref"><a href="#fn48" id="fnref48">48</a></sup></p>
</blockquote>
<p>Dans “<em>Qu’est-ce que l’informatique ?</em>”, l’universitaire français Franck Varenne propose et critique de nombreuses ébauches définitionnelles – c’est là le cœur de l’ouvrage – avant de conclure par la description suivante :</p>
<blockquote>
<p>[L’informatique est] une technologie (dans son caractère instumental et de délégation opératoire) et une discipline (dans ses versants cognitifs et réthoriques) de démultiplication, d’entrelacement, d’application […] et/ou de confrontation des voies de la référence. Plus brièvement : elle est une technologie d’entrecroisement automatique et programmable des voies de la référence.<sup class="footnote-ref"><a href="#fn49" id="fnref49">49</a></sup></p>
</blockquote>
<p>Varenne nomme “voies de la référence” la faculté des <em>symboles</em> utilisés en informatique (nombres, lettres, signes, etc.) à faire référence à un ou plusieurs autres symboles. En ce qui concerne le calcul numérique, les <em>voies</em> sont au nombre de deux : la <em>concrétisation</em> ou l’<em>abstraction</em>. La concrétisation est le fait de rapprocher le théorique de l’expérience, et l’abstraction est le phénomène inverse : celui de tirer l’expérience vers le théorique. Varenne synthétise cette dualité inhérente à l’ordinateur dans une interview donnée suite à la parution de “<em>Qu’est-ce que l’informatique ?</em>”.</p>
<blockquote>
<p>En ce sens, l’ordinateur est une machine particulière, une machine qu’on peut dire mi-matérielle, mi-formelle, ou encore mi-concrète, mi-abstraite. L’informatique passe ainsi pour une technologie de conciliation extraordinaire.</p>
</blockquote>
<p><strong>Si elle en est fondamentalement inspirée, l’informatique va au-delà du calcul et joue sur les niveaux de symboles mis en œuvre : les symboles sont hybridés via des procédés de sous-symbolisation et de simulation.</strong> On pourrait illustrer cette distinction par un phénomène de “couches” superposées, où chacune est une symbolisation de celle sur laquelle elle s’appuie : cette superposition constitue ainsi une forme de <em>simulation</em> récursive, chaque strate jouant le rôle de la précédente sous une autre forme.</p>
<p><img src="img/couches.png" alt="Schéma de la simulation récursive"><em>Fig. 11 : Schéma de la simulation récursive</em></p>
<h3 id="de-lalgorithme-au-programme">De l’algorithme au programme</h3>
<p>Un programme informatique est une suite d’instructions qui effectue une ou plusieurs tâches spécifiques lorsqu’elle est exécutée par un ordinateur.<sup class="footnote-ref"><a href="#fn50" id="fnref50">50</a></sup> Franck Varenne attire notre attention sur une possible origine de la confusion entre algorithmes et programmes. Il cite Charles Hoare, professeur et informaticien britannique, également connu pour la conception de nombreux algorithmes encore utilisés aujourd’hui. Hoare déclare que “la programmation informatique est une science exacte en ce que toutes les propriétés d’un programme […] peuvent être découvertes à partir du texte du programme lui-même au moyen de raisonnement purement déductif.” Varenne y oppose l’argumentation de James Fetzer, philosophe américain spécialisé notamment en informatique : la vision de Hoare amène à confondre les algorithmes et les programmes. <strong>Selon Varenne, rien n’implique une exacte similitude entre le comportement supposé du programme – à la lecture donc – et les conséquences réelles de son exécution sur la machine.</strong></p>
<blockquote>
<p>Les algorithmes sont des solutions formelles (abstraites en ce sens) et effectives pour certains problèmes bien formulés. Les programmes chargés en mémoire (exécutables) sont en revanche des modèles causaux (car physiques) de ces algorithmes. Alors que les algorithmes sont des modèles abstraits des programmes exécutables, les programmes exécutables sont des modèles causaux des algorithmes.<sup class="footnote-ref"><a href="#fn51" id="fnref51">51</a></sup></p>
</blockquote>
<p>Varenne qualifie donc ces modèles d’<em>imparfaits</em> : le programme ne peut jamais être vérifié formellement, mais seulement de façon empirique. En effet, on peut établir la validité d’un programme, notamment en développant une sémantique qui régule le <em>code</em> écrit par le programmeur. On résout alors les erreurs de programmation : variables sans valeur définie, fautes de syntaxe, structure erronée ou illogique, etc. Toutefois, la machine peut elle-même faire preuve de dysfonctionnement du fait même de sa dimension physique : processeur défectueux, espace de stockage corrompu, mémoire vive saturée, etc.</p>
<p>Cette marge d’incertitude entre le programme que l’on voit et ce que l’on obtient lorsqu’il est exécuté a été baptisée WYSINWYX, pour <em>What You See Is Not What You eXecute</em> – littéralement “ce que vous voyez n’est pas ce que vous exécutez”.<sup class="footnote-ref"><a href="#fn52" id="fnref52">52</a></sup> Cet acronyme est une référence au paronyme duquel il est inspiré : le terme WYSIWYG —<em>What You See Is What You Get</em>, soit “ce que vous voyez est ce que vous obtenez” – désigne, en informatique, les interfaces utilisateurs où l’on compose directement le résultat final souhaité.<sup class="footnote-ref"><a href="#fn53" id="fnref53">53</a></sup></p>
<p>Cet écart entre ce que l’on pense avoir programmé et ce qui se produit réellement est une caractéristique propre à la programmation, qu’on ne retrouve pas dans les outils de création classiques, tels que ceux de la suite Adobe – qui sont justement des outils WYSIWYG. Dans sa thèse “<em>Designing Design Tools</em>”, Nolwenn Maudet définit ces deux catégories comme les extrêmes d’un panel d’outils potentiels, hybrides, à concevoir.</p>
<blockquote>
<p>Aujourd’hui, la programmation et les interfaces  graphiques sont deux ensembles d’outils mutuellement exclusifs. Nous pouvons les considérer comme deux limites opposées d’un large éventail d’outils de conception possibles. Je soutiens que nous devons inventer de nouveaux objets interactifs et de nouvelles interactions pour remplir cette gamme.<sup class="footnote-ref"><a href="#fn54" id="fnref54">54</a></sup></p>
</blockquote>
<p>Par ailleurs, les programmes informatiques impliquent d’être écrits dans les langages spécifiques, appelés langages de programmation – ou langages informatiques –, sur lesquels je me penche à présent.</p>
<h3 id="langages-informatiques">Langages informatiques</h3>
<p>Il existe une grande variété de langages de programmation, comme en témoigne la liste établie sur Wikipédia<sup class="footnote-ref"><a href="#fn55" id="fnref55">55</a></sup>. <strong>Tous possèdent des règles de syntaxe, un vocabulaire, une sémantique, un vocabulaire et des identifiants qui leur sont propres</strong> – mais ils partagent également de nombreux points communs. À la vue de cette liste de plus de 600 langages référencés, on peut se poser la question suivante : pourquoi y a-t-il autant de langages de programmation ? Sur le site communautaire de programmation StackOverflow<sup class="footnote-ref"><a href="#fn56" id="fnref56">56</a></sup>, l’ingénieur Matt Sherman propose dans un article<sup class="footnote-ref"><a href="#fn57" id="fnref57">57</a></sup> plusieurs éléments de réponse :</p>
<ul>
<li>les différents langages constituent une multitude d’outils, chacun plus ou moins adapté à des usages précis – il s’agit de choisir pour chaque finalité le langage qui sera le plus efficace, sûr et rapide à manier ;</li>
<li>les programmeurs ont des goûts personnels – et des compétences qui leur sont propres. Tel ou tel langage est souvent choisi en fonction des connaissances de l’équipe de programmation ;</li>
<li>la variété des langages de programmation est ainsi riche, en ce qu’elle permet plus de flexibilité en fonction des tâches à accomplir et des personnes qui vont employer ces langages.</li>
</ul>
<p>Il faut aussi prendre en compte la faculté qu’ont les langages à disparaître – tels des langues mortes –, et le fait que certains ne soient que très peu utilisés, car trop spécifiques, ou tout simplement conçus pour le divertissement plutôt que dans l’optique d’une application logicielle concrète. Par ailleurs, on peut catégoriser les langages de programmation en paradigmes<sup class="footnote-ref"><a href="#fn58" id="fnref58">58</a></sup> de programmation : en résumé, un paradigme désigne la façon que le programmeur a d’envisager la structure et le fonctionnement du programme.</p>
<p>Les langages de programmations les plus populaires de nos jours sont JavaScript, Python, Ruby, Java, PHP ou encore C++ – d’après une étude<sup class="footnote-ref"><a href="#fn59" id="fnref59">59</a></sup> menée par la plateforme de développement collaboratif GitHub<sup class="footnote-ref"><a href="#fn60" id="fnref60">60</a></sup>. Je m’attarde un instant sur un autre langage qui me semble s’en démarquer : le <em>pseudo-code</em>. Il s’agit d’une façon de décrire un algorithme dans un langage <em>naturel</em>, sans faire référence à un langage de programmation particulier. <strong>Sans réelle règle ou convention établie, l’écriture en pseudo-code permet de mesurer la difficulté de la conception d’un algorithme</strong>, et ainsi d’anticiper une structure flexible et adaptée au développement réel qui a lieu dans un second temps : ici, un exemple de pseudo-code décrivant un algorithme de résolution du problème <a href="http://wiki.c2.com/?FizzBuzzTest"><em>FizzBuzz</em></a>.</p>
<p><img src="img/pseudo-code.png" alt="Un exemple de pseudo-code"><em>Fig. 12 : Un exemple de pseudo-code</em></p>
<p>Il existe des points communs entre ces langages – notamment dans l’exercice de leur écriture – mais également des différences évidentes. Qu’est-ce qui distingue un langage informatique du langage courant que nous utilisons au quotidien ? Comment est-il régi ? Comment s’écrit-il ? En résumé, <strong>quelle est la particularité du langage informatique ?</strong></p>
<h3 id="langages-naturels-et-langages-formels">Langages naturels et langages formels</h3>
<p>En linguistique, on appelle <strong>“langage naturel”</strong> un langage qui a évolué naturellement au travers de l’utilisation humaine et de sa répétition, sans planification particulière ou préméditation consciente de la part du peuple qui l’utilise – comme le français ou l’anglais par exemple. On y oppose la notion de <strong>“langage formel”</strong>, parfois également appelé “langage construit” ou encore “langage artificiel”.<sup class="footnote-ref"><a href="#fn61" id="fnref61">61</a></sup> À l’inverse, il s’agit ici d’un langage créé de toutes pièces dans un temps relativement court, par une population bien plus restreinte – éventuellement l’œuvre d’un seul auteur. On peut distinguer trois catégories parmi ces langages construits :</p>
<ul>
<li>les langages conçus, ou <em>engelangs</em> (de l’anglais <em>engineered</em>), à nouveau divisés en langages logiques (par exemple les langages de programmation informatique), philosophiques ou expérimentaux  ;</li>
<li>les langages auxiliaires, ou <em>auxlangs</em>, créés pour la communication internationale – un des plus célèbres étant l’Esperanto ;</li>
<li>les langages artistiques, ou <em>artlangs</em>, comme ceux inhérents à une œuvre de science-fiction ou de fantaisie – par exemple les langues créées par l’auteur J.R.R. Tolkien.</li>
</ul>
<p>Le terme de langage <em>formel</em> fait davantage référence au champ des mathématiques et de l’informatique : <strong>cette notion intègre à la fois l’ensemble des séquences de caractères et des symboles qui sont employés et les différentes règles qui déterminent leurs usages</strong>. C’est donc à cette catégorie que je m’intéresse en particulier dans la suite de cet exposé, centrée sur les langages informatiques.</p>
<p><ins>En m’interrogeant sur la dualité entre langage naturel et langage formel dans notre manière de communiquer à la machine – notamment des instructions –, je propose la question suivante : <strong>ne peut-on pas utiliser d’autres formes de langage qu’un langage de programmation ?</strong> J’ai entamé une proposition de réponse grâce à une interface intitulée <em>text2code</em><sup class="footnote-ref"><a href="#fn62" id="fnref62">62</a></sup>, qui permet de “coder” en langage naturel, c’est-à-dire en écrivant de l’anglais intelligible par tous – ce qui implique une traduction “cachée” en langage JavaScript, exécutable par un navigateur.<br>
<img src="img/text2code.png" alt="text2code, une interface d’écriture algorithmique en langage naturel"><em>Fig. 13 : text2code, une interface d’écriture algorithmique en langage naturel</em><br>
Cette expérimentation rejoint la notion de pseudo-code : les instructions sont données en langage naturel, mais doivent ensuite être <em>concrétisées</em>, pour reprendre le terme de Varenne, en un langage de programmation. En réalisant cette expérience, je me suis rendu compte que la richesse d’un langage naturel pouvait donner lieu à des résultats inattendus lorsqu’on cherchait à le “simplifier” en un langage exécutable.<br>
</ins></p>
<h3 id="lignes-de-code-règles-et-conventions">Lignes de code, règles et conventions</h3>
<p><strong>Le code, tel que le définit l’archéologue et linguiste Clarisse Herrenschmidt, est “un moyen de chiffrer, propre à la machine qui crypte et décrypte.”</strong><sup class="footnote-ref"><a href="#fn63" id="fnref63">63</a></sup> C’est la forme de programmation la plus classique : la quasi-intégralité des produits numériques, logiciels et autres applications que nous utilisons aujourd’hui ont été écrits, ligne par ligne, symbole par symbole. Les langages de programmation emploient une syntaxe – un ensemble de contraintes qui régissent la combinaison des symboles – qu’il convient de respecter pour assurer la bonne exécution du programme. Sinon, le compilateur rencontrera une anormalité et le “<em>debugger</em>” (ou la “console”) va afficher un message d’erreur. Le respect des règles imposé par un langage de programmation assure que celui-ci pourra être décrypté par la machine, et ainsi exécuté : le code est dit “valide”.</p>
<p>Outre la dimension fonctionnelle, un programmeur se doit de respecter un certain nombre de conventions afin d’être compris par d’éventuels autres programmeurs qui viendraient à lire ce code : <strong>la question n’est plus seulement “ce code est-il lisible par la machine ?”, mais “ce code est-il lisible par un humain ?”</strong>. On intègre alors à son écriture des principes visuels, de composition, ou encore de choix sémantiques. Un certain nombre de principes graphiques sont utilisés. Par exemple, l’<em>indentation</em> consiste à ajouter des espaces – ou des <em>tabulations</em> – en début de chaque ligne de code de façon à structurer visuellement l’ensemble du programme.<sup class="footnote-ref"><a href="#fn64" id="fnref64">64</a></sup> Dans certains langages, les espaces vides sont ignorés lors de l’interprétation par la machine, ils sont donc utilisés selon la convenance pour faciliter la lecture. À l’inverse, dans d’autres langages – comme le Python –, cette structuration est essentielle car elle définit le fonctionnement même du programme, il n’est donc pas ici question uniquement de style ou de clarté. Un autre principe graphique employé pour la lisibilité est la coloration syntaxique (ou <em>syntax highlighting</em> en anglais), qui formate automatiquement les éléments du texte – notamment par le changement de couleur mais parfois aussi de typographie – afin d’en simplifier la lecture. Ce système répond d’ailleurs à un problème énoncé par Franck Varenne, faisant lui-même référence au philosophe Gilles Gaston Granger : “des symboles qui peuvent être écrits côte à côte dénotent des types d’entités différents”.<sup class="footnote-ref"><a href="#fn65" id="fnref65">65</a></sup></p>
<p>Voici d’autres exemples de conventions courantes :</p>
<ul>
<li>les commentaires, exprimés en langage naturel (souvent en anglais), non pris en compte dans l’exécution du script : ils servent à clarifier le fonctionnement du programme à un endroit précis auprès de potentiels futurs lecteurs ;</li>
<li>l’indentation, comme expliqué plus haut, dont on définit les points de retours à la ligne ou le nombre d’espaces ;</li>
<li>la longueur des lignes, pour garantir l’affichage complet en largeur du code au sein d’un éditeur de texte ;</li>
<li>le nommage des variables, notamment sur la façon de <em>concaténer</em> – mettre bout à bout plusieurs chaînes de caractères – des intitulés. On parle notamment de <em>casse</em>, c’est-à-dire de l’usage des lettres capitales pour assurer la lisibilité d’un mot-valise<sup class="footnote-ref"><a href="#fn66" id="fnref66">66</a></sup> ;</li>
<li>et d’autres encore, liées aux “bonnes pratiques” et principes divers qui permettent l’intelligibilité, l’efficacité, la flexibilité ou encore la sécurité d’un programme.</li>
</ul>
<img src="img/javascript.png" alt="Un exemple de programme simple dans le langage JavaScript"><em>Fig. 14 : Un exemple de programme simple dans le langage JavaScript</em>
<p>L’action de programmer relève donc d’une écriture. Celle-ci se fait dans des langages informatiques, sous forme de lignes de codes, régies par des règles et des conventions. <strong>Quels sont les outils qui permettent cette pratique ?</strong></p>
<h2 id="outils-décriture-algorithmique">Outils d’écriture algorithmique</h2>
<p>Il existe différents outils employés dans les processus de conception algorithmique. Ceux-ci présentent des points communs et des différences, et tous conditionnent le travail de programmation d’une manière qui leur est propre. Quels sont ces outils, ces interfaces, et quels sont leurs impacts sur la pratique du bricodeur ?</p>
<h3 id="ide-et-éditeurs-de-texte">IDE et éditeurs de texte</h3>
<p>On parle “d’environnement de développement” ou d’<abbr title="Integrated development environment">IDE</abbr> pour désigner l’ensemble des outils employés par un programmeur pour développer un programme informatique. <strong>Un IDE est généralement un logiciel dont l’interface propose un ensemble d’outils et de fonctions</strong> : le plus généralement, on trouve un éditeur de texte où le programmeur saisit des lignes de codes. Celui-ci est généralement accompagné d’un <em>debugger</em> – pour débusquer et corriger les <em>bugs</em> – ou encore, si le langage l’implique, d’un compilateur – utilisé pour “traduire” le langage de programmation en <em>langage machine</em>, c’est-à-dire en instructions exécutables par l’ordinateur. Le choix de tel ou tel logiciel de programmation – de tel ou tel environnement – dépend généralement du langage utilisé dans le cadre d’un projet, ainsi que des goûts personnels du développeur. Certains outils, ayant une communauté plus active, se développent particulièrement grâce à la contribution collective – lorsque le logiciel est <em>open-source</em> – tandis que d’autres tombent en désuétude, les années passant et les technologies évoluant en conséquence.</p>
<p>La définition stricte d’IDE désigne donc ces outils composés, multiples, et les oppose aux simples “éditeurs de texte”. <strong>Un éditeur de texte – <em>text editor</em> en anglais – est un programme permettant l’écriture ou la modification de texte <em>brut</em>, c’est-à-dire dénué de mise en forme</strong> : ces logiciels utilisent souvent une typographie monochasse, permettant l’alignement vertical des caractères et favorisant ainsi la lisibilité du code. Les fonctions les plus courantes sont le copier/coller, la recherche et remplacement, la coloration syntaxique, etc. Par abus de langage, ces éditeurs de texte sont généralement inclus dans la définition au sens large d’IDE, à juste titre : ils font bel et bien partie de l’environnement de développement du programmeur.</p>
<p><img src="img/atom-ide.png" alt="Capture d’écran du logiciel de programmation Atom"><em>Fig. 15 : Capture d’écran du logiciel de programmation Atom</em></p>
<h3 id="programmation-visuelle">Programmation visuelle</h3>
<p><strong>La programmation peut également prendre une forme graphique, visuelle. C’est le cas notamment des représentations algorithmiques en diagrammes, aussi appelées <em>algorigrammes</em> – ou <em>flowcharts</em> en anglais.</strong> Les instructions sont divisées dans autant de formes géométriques normalisées – un rectangle pour une opération, un losange pour un test, etc. – qui sont ensuite reliées entre elles pour symboliser l’enchaînement des instructions. Apparue il y a un siècle dans le domaine de l’ingénierie industrielle, cette représentation est utilisée dans certains logiciels de programmation comme <em>Flowgorithm</em>, qui est un intermédiaire entre la conception algorithmique visuelle et la programmation textuelle : le diagramme créé par l’utilisateur peut être traduit en un des langages de programmation les plus courants. Cette catégorie d’outils est notamment utilisée dans l’éducation, auprès de novices, afin de leur faire assimiler la logique sans introduire les langages de programmation comme difficulté supplémentaire.</p>
<p><img src="img/flowgorithm.png" alt="Capture d’écran du logiciel Flowgorithm"><em>Fig. 16 : Capture d’écran du logiciel Flowgorithm</em></p>
<p><strong>La programmation visuelle peut aussi s’affranchir de la représentation normalisée d’un algorigramme.</strong> L’exemple le plus connu est le logiciel <em>Scratch</em>, développé par le <abbr title="Massachusetts Institute of Technology">MIT</abbr> depuis une quinzaine d’années. <em>Scratch</em> propose de voir la programmation algorithmique comme un jeu de puzzle, constitué de “blocs” représentant chacun un type d’opération particulier, imbriqués pour constituer la structure du programme. Son interface simple et colorée et son intuitivité en font l’outil parfait pour les plus jeunes créatifs, et un excellent moyen d’appréhender la réflexion logique et mathématique.</p>
<p><img src="img/scratch-ide.png" alt="Capture d’écran du logiciel Scratch"><em>Fig. 17 : Capture d’écran du logiciel Scratch</em></p>
<h3 id="workflow--loutil-adapté-à-lusage">Workflow : l’outil adapté à l’usage</h3>
<p><strong>Les méthodes de travail d’un développeur sont souvent bien maîtrisées.</strong> On parle de <em>workflow</em> – “flux de travail” – pour désigner les méthodes d’organisation systématiques qu’il applique afin de fluidifier le processus de programmation et de se prévenir de complications diverses – notamment lorsque d’importantes quantités de données sont manipulées, et que l’erreur humaine peut intervenir à tout moment. Une des solutions les plus couramment appliquées de nos jours est la gestion de versions – le <em>versionning</em> en anglais. J’ai déjà mentionné le logiciel <em>git</em>, qui permet d’enregistrer des points clés – des <em>commits</em> – dans l’avancement d’un projet numérique. Pour comprendre la valeur de cette méthode, il faut noter la nature spécifique de l’écriture algorithmique. À l’image de l’auteur qui écrit un paragraphe, revient en arrière, effectue des modifications le lendemain et finit par rayer des passages, le développeur a une écriture non linéaire. Les <em>commits</em> assurent une traçabilité de cette évolution d’un projet dans le temps, et permettent de revenir à une version antérieure lorsque l’on fait fausse route. Les outils de programmation, mais également les plateformes d’hébergement comme GitHub par exemple, permettent de comparer deux versions d’un même extrait de code en visualisant leurs différences, grâce aux <em>diffs</em> : les parties ajoutées sont surlignées en vert, les parties supprimées en rouge.</p>
<p><img src="img/github-diff.png" alt="Visualisation d’un diff sur GitHub"><em>Fig. 18 : Visualisation d’un diff sur GitHub</em></p>
<p>Par ailleurs, lorsqu’on souhaite aborder une nouvelle fonctionnalité ou une modification majeure au sein d’un projet, on utilise un principe de <em>branches</em> : créer une branche signifie diverger de la version principale, et continuer à travailler sur une version différente. Tout comme on peut revenir en arrière dans son travail grâce aux <em>commits</em>, on peut passer librement de branche en branche, afin de travailler sur des fonctionnalités en parallèle tout en conservant une autonomie totale de chaque branche : indépendantes, elles n’entrent pas en collision les unes avec les autres. Elles peuvent cependant être fusionnées à n’importe quel moment, afin par exemple d’appliquer les modifications apportées par une branche à la version principale du projet. <strong>Les outils de gestion de versions sont donc particulièrement adaptés aux méthodes de travail spécifiques des développeurs, mais qu’en est-il des méthodes de travail du bricodeur ?</strong></p>
<p>On peut observer différents modes de travail chez les développeur comme chez le créatif, ainsi que dans les profils mixtes qui s’inscrivent entre les deux. Un premier mode est celui de l’efficacité : il s’agit de planifier, de procéder avec méthode, de chercher des solutions techniques avec un objectif fonctionnel précis, d’optimiser, de rationaliser. On trouve à l’opposé une démarche plus créative, basée sur l’expérimentation : il est question d’ouverture, on cherche des alternatives, propose des hypothèses, les abandonne, y revient plus tard. Dans un logiciel de création graphique classique, le créatif crée des formes, les duplique pour les modifier individuellement, déplace, rapproche, réutilise des éléments… Comment le bricodeur pourrait-il s’adapter à la logique de <em>git</em> dans son processus créatif ? Ou, plus intéressant encore, comment la logique de <em>git</em> pourrait s’adapter au processus créatif du bricodeur ? Cette question me laisse imaginer une interface permettant de visualiser différentes versions, différentes propositions envisagées par le créatif, et de naviguer entre elles. Et en s’écartant de <em>git</em>, la question reste centrale : <strong>comment la programmation algorithmique en général peut-elle se singulariser afin de s’adapter aux spécificités du processus créatif propre au bricodeur ?</strong></p>
<h1 id="modes-singuliers-de-programmation-algorithmique">Modes singuliers de programmation algorithmique</h1>
<p>Lorsqu’un designer utilise la programmation dans une recherche formelle ou conceptuelle, il adopte une démarche créative qui bouscule le matériau qu’est l’écriture algorithmique : le créatif a une pratique singulière du code, ses outils doivent donc être adaptés à cet usage, voire le favoriser.</p>
<h2 id="pratiques-singulières">Pratiques singulières</h2>
<p>Comment s’émanciper de la programmation “classique” ? Quelles sont les pratiques singulières du code, à la fois champ de questionnements et méthodes de recherche pratique de ce mémoire ? Comment le designer se comporte-il face au code, avec sa capacité à remettre en question des acquis ? Voici quelques éléments de réponse.</p>
<h3 id="le-code-auto-modifiant">Le code auto-modifiant</h3>
<p><strong>Et si le code n’était plus seulement <em>clos</em>, modifiable uniquement par l’homme en vue d’un résultat externe, mais qu’il accueillait lui-même un résultat, une modification ?</strong> Qu’adviendrait-il d’un programme capable d’éditer sa propre teneur, avant de s’exécuter à nouveau en prenant en compte les modifications apportées ?</p>
<p>Cette idée m’a inévitablement motivé à me lancer dans une expérimentation fonctionnelle. C’était sans compter la complexité technique et intellectuelle d’un tel programme, comme l’expliquent Geoff Cox, Alex McLean et Adrian Ward dans un article paru dans <em>Art++</em>, intitulé “<em>Praxis de la programmation : reconsidérer "L’esthétique du code génératif"</em>”.</p>
<blockquote>
<p>Dans notre exemple […], un éditeur de texte produit un code qui a la propriété de se modifier lui-même durant son exécution. […] Bien entendu, cela a des répercussions majeures sur l’acte de programmation. Le programmeur doit à présent réfléchir non seulement à ce que le logiciel fera et à la façon dont il interagira, mais aussi à la façon dont il se modifiera tout en restant fonctionnel et actif. Un code qui réfléchit à sa propre création ne peut être considéré comme un simple outil – il est réflexif.<sup class="footnote-ref"><a href="#fn67" id="fnref67">67</a></sup></p>
</blockquote>
<p>Par complexité technique et intellectuelle, j’ai donc abandonné cette expérimentation, tout en gardant à l’esprit la particularité de cette démarche, et l’idée d’un outil s’auto-façonnant.</p>
<h3 id="langages-ésotériques">Langages ésotériques</h3>
<p><strong>Il existe une catégorie de langages de programmation tout à fait particulière, celle des langages dits “ésotériques”,</strong> parfois appelés langages <em>exotiques</em> – <em>esoteric languages</em> en anglais, ou <em>esolangs</em> dans la forme contractée. Le terme “ésotérique” désigne une forme d’enseignement secret ou hermétique, réservé à des initiés. En effet, qu’ils se présentent comme des œuvres logicielles, des exercices intellectuels ou même de simples plaisanteries<sup class="footnote-ref"><a href="#fn68" id="fnref68">68</a></sup>, ces langages nécessitent une certaine maîtrise antérieure des langages de programmation classiques pour être compris, voire manipulés. Parmi les plus connus se trouve le <em>Brainfuck</em> : en n’employant que 8 caractères distincts, ce langage amène à produire du code particulièrement <em>obfusqué</em>.<sup class="footnote-ref"><a href="#fn69" id="fnref69">69</a></sup> Un autre exemple particulièrement intéressant d’<em>esolang</em> est le Piet, nommé d’après le célèbre peintre néerlandais Piet Mondrian. Ce langage n’est pas textuel mais graphique : les programmes prennent la forme d’images semblables à de l’art abstrait – librement inspiré des travaux du peintre éponyme.</p>
<p><img src="img/esolangs.png" alt="Exemples de langages ésotériques"><em>Fig. 19 : Exemples de langages ésotériques</em></p>
<p><strong>Ici, l’écriture algorithmique n’est plus seulement un outil au service de la création d’une œuvre, mais elle est une œuvre en soi</strong><sup class="footnote-ref"><a href="#fn70" id="fnref70">70</a></sup> : l’opération devient l’<em>opus</em>. D’aucuns affirmeraient que le code étant une production humaine, sa pratique est nécessairement créative, voire artistique : cette thèse soulève des considérations esthétiques, qui m’intéressent naturellement en tant que designer.</p>
<h3 id="esthétiques-du-code">Esthétiques du code</h3>
<p><strong>Qu’est-ce que le “beau” code ?</strong> <em>Beau</em> code, <em>bon</em> code, code <em>propre</em>… Ces adjectifs font partie du langage du programmeur, mais font référence à un type de “beau” bien précis : on parle ici en réalité de code astucieux, bien pensé, réfléchi. Dans <em>Art++</em>, l’informaticienne Sylvie Tissot est interrogée sur sa définition d’un “beau” programme, elle cite un certain nombre de principes qui permettent d’évaluer la <em>qualité</em> d’un programme : une condition “si” doit toujours être suivie d’un “sinon”, les <em>sorties exceptionnelles</em> – type <em>exit</em> – sont prohibées, la limite d’imbrication de conditions ou de boucles est fixée à 7, etc.<sup class="footnote-ref"><a href="#fn71" id="fnref71">71</a></sup></p>
<p>Mais l’exemple cité plus haut des langages ésotériques peut aussi répondre au qualificatif de “beau” code – non pas sur un plan intellectuel, mais émotionnel. Le code poétique est, par ce statut, une forme de <em>beau</em> code.<sup class="footnote-ref"><a href="#fn72" id="fnref72">72</a></sup> <strong>On distinguera ici deux catégories : l’art logiciel – <em>software art</em> – et l’art algorithmique, aussi appelé art génératif.</strong> Le discernement est fait à deux reprises dans l’ouvrage <em>Art++</em>, d’abord par le chercheur doctorant en littérature Florian Cramer dans son article “<em>Dix hypothèses au sujet de l’art logiciel</em>”. La sixième est intitulée “<em>L’art logiciel n’est pas synonyme d’art algorithmique</em>”. Il cite d’abord l’artiste chercheur Philip Galanter pour clarifier la notion d’art génératif.</p>
<blockquote>
<p>L’art génératif renvoie à toute pratique artistique dans laquelle l’artiste crée un processus […] mis en œuvre ensuite avec un certain degré d’autonomie et contribuant ou aboutissant à une œuvre artistique achevée.<sup class="footnote-ref"><a href="#fn73" id="fnref73">73</a></sup></p>
</blockquote>
<p>Puis, Florian Cramer compare cette définition avec celle de l’art logiciel et montre ainsi leur écart.</p>
<blockquote>
<p>L’art logiciel, pour sa part, ne satisfait pas aux critères de l’art génératif, ou du moins n’est en mesure d’y satisfaire que dans un sens métaphorique et non technique, c’est-à-dire lorsqu’il produit un logiciel dysfonctionnel et imaginaire. C’est le cas des codeworks<sup class="footnote-ref"><a href="#fn74" id="fnref74">74</a></sup>, par exemple.</p>
</blockquote>
<p>Plus loin dans l’ouvrage, il reprend et approfondit cette distinction dans un chapitre au titre sans équivoque : “<em>Art génératif ≠ Software art</em>”. Il le conclut à l’aide d’un tableau comparatif<sup class="footnote-ref"><a href="#fn75" id="fnref75">75</a></sup> que je synthétiserai ici.</p>

<table>
<thead>
<tr>
<th>Art génératif</th>
<th>Software art</th>
</tr>
</thead>
<tbody>
<tr>
<td>S’attache avant tout à la <em>surface</em> créée par un processus génératif.</td>
<td>S’attache au processus génératif susceptible de générer des surfaces ou d’autres résultats.</td>
</tr>
<tr>
<td>Considère le logiciel comme un outil pragmatique/neutre servant à produire un certain résultat : l’outil lui-même n’est pas questionné.</td>
<td>Aborde le logiciel comme une culture qu’il s’agit de questionner ; s’intéresse aux significations esthétiques et politiques sous-jacentes ; le logiciel peut être “expérimental” et “non pragmatique”.</td>
</tr>
<tr>
<td>Le logiciel en tant qu’<em>outil</em> pragmatico-génératif.</td>
<td>Le logiciel ou le code en tant qu’<em>œuvre à part entière</em> (éventuellement expérimentale).</td>
</tr>
<tr>
<td>Code <em>efficace</em> (“de beaux algorithmes”).</td>
<td>Le code comme excès, le code comme extravagance, <em>pas nécessairement efficace</em>.</td>
</tr>
<tr>
<td>Fascination du génératif.</td>
<td>S’intéresse à la “performativité” du code.</td>
</tr>
</tbody>
</table><p>Le code assume donc un double rôle : il est à la fois <em>outil</em> et <em>matière</em>. Or, ces deux notions se rapportent à une dimension physique, tangible : <strong>l’outil et la matière sont <em>manipulés</em>.</strong> Ce terme, dont l’étymologie latine <em>manipulare</em> signifie “conduire par la main”, implique donc une première définition liée au fait de manier une substance ou un instrument, en vue d’une opération technologique ou scientifique. Au sens figuré, <em>manipuler</em> peut également désigner un ensemble d’actions mené sur quelque chose – ou le plus souvent, quelqu’un – par des moyens détournés, occultes, voire suspects, pour l’amener à ce qu’on souhaite. Enfin, on peut considérer que ce qui peut être manipulé est donc tangible, vérifiable.<sup class="footnote-ref"><a href="#fn76" id="fnref76">76</a></sup> <strong>Comment manipule-t-on, au sens physique, l’outil-matière algorithmique ?</strong></p>
<h3 id="programmation-tangible--la-réflexion-par-la-main">Programmation tangible : la réflexion par la main</h3>
<p>En déportant la réflexion distanciée qu’implique l’usage d’une interface – métaphorique – de programmation classique, à une manipulation – non métaphorique – plus directe, tangible,  on permet une nouvelle façon de penser et d’imaginer des options créatives : <strong>on ne pense pas de la même manière avec sa tête ou avec ses mains</strong>. Le philosophe français Henri Bergson soulignait d’ailleurs dans son “<em>Essai sur les données immédiates de la conscience</em>”, la place centrale de la manipulation dans un processus scientifique – par exemple une création algorithmique.</p>
<blockquote>
<p>Il est de l’essence de la science, en effet, de manipuler des signes qu’elle substitue aux objets eux-mêmes.</p>
</blockquote>
<p>Cette notion de manipulation est la genèse d’un projet intitulé <em>Dynamicland</em><sup class="footnote-ref"><a href="#fn77" id="fnref77">77</a></sup>, initié notamment par Bret Victor<sup class="footnote-ref"><a href="#fn78" id="fnref78">78</a></sup>. <em>Dynamicland</em> est un concept d’ordinateur alternatif, nouveau médium informatique collaboratif, où les utilisateurs travaillent à plusieurs en manipulant des objets physiques réels plutôt que des objets virtuels au travers d’écrans.</p>
<blockquote>
<p>Pas d’écrans, pas d’appareils. Simplement des matériaux physiques ordinaires – papier et pâte à modeler, jetons et voitures en plastique – rendus vivants grâce à une technologie dissimulée au plafond. […] Dynamicland est un ordinateur avec lequel on travaille <em>ensemble</em>, en face-à-face, les yeux dans les yeux et avec les mains – beaucoup de mains. […] On pense avec nos mains. On pense avec nos corps. On s’étale, on se déplace, on compare différentes possibilités. On improvise, on expérimente, avec <em>tout</em>.</p>
</blockquote>
<p><img src="img/dynamicland.png" alt="Des utilisateurs interagissant avec Dynamicland"><em>Fig. 20 : Des utilisateurs interagissant avec Dynamicland</em></p>
<p>Dans le cas de <em>Dynamicland</em>, on manipule des objets, captés par des caméras et reconnus grâce à un système de points colorés : ils sont ainsi interprétés par des algorithmes “classiques”.<sup class="footnote-ref"><a href="#fn79" id="fnref79">79</a></sup> Si le mode d’interaction est nouveau, la matière algorithmique, dissimulée, n’est pas directement tangibilisée et manipulée. <strong>Quelle forme prendrait un langage de programmation tangible ?</strong> Le collectif d’arts numériques transdisciplinaire <em>[foam]</em> propose une réponse : ils travaillent en 2017 sur une installation nommée “<em>Pattern Matrix</em>”, qui n’est autre qu’un langage de programmation matériel, tangible. Celui-ci a littéralement été créé de toutes pièces : on opère l’installation en tournant une série de “jetons” qui cachent des senseurs magnétiques. Des informations visuelles sont superposées grâce à la réalité augmentée, permettant de visualiser – et ainsi de comprendre – les états de chaque composant et les échanges qui s’exercent entre eux. Un premier essai du dispositif a été fait dans le cadre d’une performance musicale live à Brighton : bien qu’expérimentale et particulièrement singulière, cette interface-outil peut nourrir une pratique créative.<sup class="footnote-ref"><a href="#fn80" id="fnref80">80</a></sup></p>
<p><img src="img/pattern-matrix.png" alt="Pattern Matrix, un langage de programmation tangible"><em>Fig. 21 : Pattern Matrix, un langage de programmation tangible</em></p>
<p><ins><strong>Je me suis interrogé sur la nature qu’aurait une interface de programmation “hors de l’écran”, au travers d’une expérimentation mettant en jeu la manipulation</strong> : en utilisant la surface tactile d’un smartphone, et en transmettant les données en temps réel à un ordinateur connecté, un algorithme de reconnaissance de formes permet de comprendre une forme “tracée” du doigt, et attribuée à une fonction précise. Par exemple, le dessin d’une boucle peut faire apparaître une boucle itérative dans le code, ou l’exécuter de façon éphémère. On peut également faire réagir des variables ou des objets virtuels grâce à cette interaction : modification d’une valeur, déplacement dans un espace en deux ou trois dimensions. On peut également tirer parti des fonctionnalités technique du smartphone, notamment l’accéléromètre et le gyroscope. L’appareil devient alors une extension de l’interface de programmation, à l’instar d’une télécommande programmable.</ins></p>
<h2 id="modes-de-représentation">Modes de représentation</h2>
<p><strong>Les différents modes de représentation des algorithmes permettent donc de s’emparer de la programmation comme matière.</strong> Quels écarts de perception existent entre la lecture d’un algorithme au sein d’un éditeur de texte, la visualisation de sa transcription visuelle, ou encore la manipulation, simulée ou tangible, de celui-ci ?</p>
<h3 id="représenter-les-algorithmes">Représenter les algorithmes</h3>
<p><strong>La représentation visuelle d’un processus algorithmique permet d’appréhender l’algorithme en question d’une manière plus intuitive, car sensorielle, que dans le cas d’une lecture réfléchie du code.</strong> Dans le monde scientifique et informatique, c’est un véritable exercice de style. Ces visualisations permettent en effet de comprendre en profondeur la démarche et l’efficacité d’un algorithme pour répondre à un problème donné : génération aléatoire de points dans un espace, tri de données<sup class="footnote-ref"><a href="#fn81" id="fnref81">81</a></sup>, <em>pathfinding</em> – recherche du chemin le plus rapide entre deux points –, etc. Le designer de visualisations Michael Bostock illustre ces exemples au sein d’un article intitulé <a href="https://bost.ocks.org/mike/algorithms/"><em>Visualizing Algorithms</em></a>. Il cite en introduction le professeur en sciences cognitives Donald Norman, qui témoigne de l’importance de ces outils qui “aident” à la compréhension :</p>
<blockquote>
<p>Les capacités de l’esprit sans aide extérieure sont fortement surestimées. Les facultés réelles proviennent de la conception d’aides externes qui améliorent les capacités cognitives.</p>
</blockquote>
<p>Dans un essai intitulé “<em>Learnable Programming</em>”<sup class="footnote-ref"><a href="#fn82" id="fnref82">82</a></sup>, Bret Victor réfléchit au design de systèmes de programmation permettant de mieux comprendre les programmes. Il introduit son propos avec une théorie qui rejoint celle de Donald Norman :</p>
<blockquote>
<p><strong>On comprend ce que l’on peut voir.</strong> Si un programmeur ne peut pas voir ce qu’un programme est en train de faire, il ne peut pas le comprendre.</p>
</blockquote>
<p>Cet essai est donc construit autour d’une question au cœur de mon sujet : <strong>comment peut-on <em>voir</em> le résultat de ce que l’on code, au moment exact où on le code ?</strong></p>
<h3 id="visualiser-au-sein-de-lide">Visualiser au sein de l’IDE</h3>
<p>Dans une conférence donnée au <abbr title="The Canadian University Software Engineering Conference">CUSEC</abbr> de 2012, Bret Victor dénonce le délai, qui, dans un processus créatif, peut séparer l’apparition d’une idée et sa matérialisation.</p>
<blockquote>
<p>Il est essentiel, dans un processus créatif, de pouvoir essayer une idée à l’instant où l’on y pense. S’il y a le moindre délai dans cette boucle de <em>feedback</em><sup class="footnote-ref"><a href="#fn83" id="fnref83">83</a></sup> entre la conception d’une chose, sa visualisation et sa réalisation, alors un monde entier d’opportunités créatives disparaît. <em>Ce sont des pensées que l’on ne peut penser</em>.<sup class="footnote-ref"><a href="#fn84" id="fnref84">84</a></sup></p>
</blockquote>
<p>Pour illustrer son propos, Bret Victor prend l’exemple d’un dessin algorithmique, programmé en JavaScript et restitué visuellement dans un <em>canvas</em> – une toile numérique – au sein d’un explorateur web.</p>
<blockquote>
<p>Voici comment fonctionne la programmation : vous tapez un tas de code dans un éditeur de texte, en essayant d’imaginer ce que chaque ligne de code va faire. Puis, vous compilez et exécutez ce code, et quelque chose en sort. […] Mais s’il y a une erreur, ou si vous souhaitez faire des modifications, vous devez retourner dans le code, le modifier, compiler et exécuter à nouveau, et voir à quoi il ressemble. La majeure partie de ce processus se passe dans l’éditeur, où l’on travaille <em>aveuglément</em>, sans connexion immédiate avec ce que l’on cherche réellement à produire.<sup class="footnote-ref"><a href="#fn85" id="fnref85">85</a></sup></p>
</blockquote>
<p>Victor dénonce ici ce que l’on pourrait qualifier de “niveau zéro” de la créativité algorithmique : <strong>lorsque la conception et la réalisation d’une œuvre implique de passer constamment du code au résultat, cela impose un délai dans le <em>feedback</em>, et la fluidité que suppose une démarche créative en est mécaniquement impactée.</strong> Il propose donc une interface binaire, scindée verticalement : à gauche le résultat, à droite l’éditeur de texte avec le programme. Lorsqu’on modifie une ligne ou une valeur dans le code, le résultat est directement visible, en temps réel – en cela, sa proposition ressemble beaucoup à <em>Processing</em>. L’expérience de la programmation est améliorée, facilitée : on est au “niveau un”. Un autre exemple pourrait être celui de la superposition du code et du résultat, comme le propose <a href="https://github.com/fand/vedajs">VedaJS</a>, un <em>framework</em><sup class="footnote-ref"><a href="#fn86" id="fnref86">86</a></sup> adapté à la création de <em>shaders</em> – images de synthèse simulant graphiquement de la lumière, des textures et des animations.</p>
<h3 id="manipuler-au-sein-de-lide">Manipuler au sein de l’IDE</h3>
<p>Mais Bret Victor va plus loin que la simple juxtaposition du programme et du résultat produit. Pour simplifier l’édition des valeurs – notamment chiffrées – utilisées dans un algorithme, il propose un nouveau type d’interaction : au lieu de devoir effacer des caractères pour les remplacer, chaque valeur devient <em>draggable</em><sup class="footnote-ref"><a href="#fn87" id="fnref87">87</a></sup>, ce qui permet de faire évoluer ces variables. On peut également modifier les couleurs via une palette. Cet usage innovant est aussi disponible dans <em>Processing</em> via le mode “<a href="https://vimeo.com/74028935">Tweak Mode</a>”, ainsi que dans la librairie JavaScript <em>dat.GUI</em><sup class="footnote-ref"><a href="#fn88" id="fnref88">88</a></sup> pour un usage sur le web.</p>
<p>Dans sa conférence <em>Inventing on Principle</em>, Bret Victor applique cette interaction à une variable liée au positionnement des feuilles dans un dessin d’arbre. Cela permet de révéler une opportunité d’animation : en faisant varier en continu une valeur, les feuilles semblent s’agiter comme si le vent soufflait, et le designer souligne l’apparition d’un nouveau champ de possibles créatifs : <strong>“comment aurais-je découvert cela si j’avais dû compiler et exécuter le code entre chaque changement ?”</strong>.</p>
<p>Bret Victor propose en ce sens diverses interventions au sein d’outils de programmation dans son essai “<em>Learnable Programming</em>”, ponctué d’expérimentations démonstratives. Il conçoit de nombreuses fonctionnalités et autant d’interactions liées, qu’il illustre dans des vidéos que je présente en partie ici.</p>
<div class="video">Vocab13.mp4</div>
<p><em>Fig. 22 : Mise en évidence du résultat précis d’une expression en la survolant</em></p>
<div class="video">Flow5.mp4</div>
<p><em>Fig. 23 : Exploration de l’exécution du programme à chaque étape grâce à un <em>slider</em><sup class="footnote-ref"><a href="#fn89" id="fnref89">89</a></sup></em></p>
<div class="video">Flow8.mp4</div>
<p><em>Fig. 24 : Visualisation de l’évolution dans le temps du programme, via une <em>timeline</em> – frise chronologique – interactive</em></p>
<div class="video">React2.mp4</div>
<p><em>Fig. 25 : Auto-complétion<sup class="footnote-ref"><a href="#fn90" id="fnref90">90</a></sup> des expressions et fonctions fréquentes, avec valeurs par défaut</em></p>
<div class="video">Abstract10.mp4</div>
<p><em>Fig. 26 : Mise en relation des variables par drag and drop – glisser-déposer – et création de fonctions et introduction de variables “intelligentes”</em></p>
<p>Bien d’autres micro-interactions sont à découvrir dans son article illustré. Dans un registre similaire, le développeur indépendant de jeux vidéo et d’expériences interactives Nicky Case travaille en 2017 sur <a href="http://ncase.me/joy-demo/">JOY.js</a>, une interface qui propose de manipuler et visualiser des algorithmes en langage JavaScript grâce à un éditeur de texte interactif et une visualisation en temps réel. En survolant du haut vers le bas le numéro d’une ligne initiant une boucle, on peut par exemple avancer pas à pas dans les itérations. De plus, chaque paramètre survolé dans le code “vacille” pendant une demi-seconde – elle varie légèrement, positivement et négativement – afin de montrer immédiatement son impact dans le dessin final.</p>
<p><img src="img/joy-js.png" alt="JOY.js, un outil interactif de manipulation de programmes JavaScript"><em>Fig. 27 : JOY.js, un outil interactif de manipulation de programmes JavaScript</em></p>
<p>Ces interactions concordent avec deux observations énoncées plus haut : on comprend ce que l’on peut voir, mais on comprend aussi ce que l’on peut manipuler<sup class="footnote-ref"><a href="#fn91" id="fnref91">91</a></sup>. Et c’est précisément en <em>comprenant</em> le comportement de son programme que le bricodeur gagne un plus grand contrôle sur le résultat qu’il cherche à produire : <strong>en quelque sorte, l’outil est là pour lui simplifier la tâche, mais également pour lui ouvrir des possibilités créatives</strong>.</p>
<h2 id="deux-typologie-doutils">Deux typologie d’outils</h2>
<p>On distingue donc deux catégories, deux typologies d’outils, dont un grille de lecture peut être donnée selon leur façon de conditionner le travail :</p>
<ul>
<li><strong>l’outil qui “se rapproche”</strong>, s’adapte, simplifie, rend plus efficace le travail du programmeur ;</li>
<li><strong>l’outil qui “s’éloigne”</strong>, nous déplace, incite, invite à une découverte des potentiels créatifs, nous permet de comprendre mieux et d’imaginer autrement.</li>
</ul>
<h3 id="outils-qui-se-rapprochent">Outils qui se rapprochent</h3>
<p>Les éditeurs de texte les plus connus, comme <em>Atom</em> ou <em>Sublime Text</em>, empruntent aux IDE leur capacité à être un outil professionnel, utilisé par des développeurs. <strong>En questionnant sur Twitter des développeurs et bricodeurs sur les fonctionnalités qu’ils préfèrent au sein de leur outil, j’ai pu discerner plusieurs catégories : l’efficacité, la personnalisation, et la polyvalence.</strong> Je détaille ce-dessous ces trois notions et cite quelques <em>verbatim</em>.</p>
<p><strong>L’efficacité se mesure par l’emploi de raccourcis claviers et de méthodes d’<em>auto-complétion</em>,</strong> qui permettent d’aller plus vite dans l’écriture du code ou de naviguer entre les différents fichiers qui composent un projet.</p>
<blockquote>
<p>Le gros plus : les raccourcis pour les codes de base sur NetBeans :<br>
“sout” + tab =&gt; System.out.println("");<br>
“fori” + tab =&gt; for (int i = 0; i &lt; t.length; i++) { … }<br>
– <em>@AntoineKia</em></p>
</blockquote>
<blockquote>
<p>La faculté de Vim à se déplacer précisément à n’importe quel endroit d’un document en quelques frappes du clavier.<br>
– <em>@GeoffreyFrogeye</em></p>
</blockquote>
<blockquote>
<p>Le “Ctrl + clic” pour la redirection vers les variables, objets ou fonctions directement dans le bon fichier !<br>
– <em>@Sacha_Roxas</em></p>
</blockquote>
<p><strong>La notion de personnalisation, ou <em>customisation</em>, est liée à la faculté d’un outil à intégrer des <em>plugins</em>,</strong> des extensions permettant d’avoir accès à un nouveau lot de fonctionnalités. Outre ces <em>plugins</em>, on retrouve également cette notion de personnalisation dans les paramètres généraux de ces outils : la plupart d’entre eux permet de définir ses préférences liées à l’affichage de l’interface, l’écriture d’un document, et plus encore.</p>
<blockquote>
<p>J’adore les plugins Electron de customisation de l’éditeur comme VedaJS, l’exécution de script depuis l’éditeur, l’intégration de GitHub, tout depuis l’éditeur…<br>
– <em>@MAKIO135</em></p>
</blockquote>
<p>Le retour d’expérience ci-dessus fait également état de <strong>la polyvalence de l’outil, qui s’observe lorsque celui-ci intègre des fonctionnalités <em>a priori</em> externes directement en son sein</strong> – exécution d’un script depuis l’éditeur, panneau <em>git</em> au sein de l’interface, etc.</p>
<blockquote>
<p>J’aime bien aussi une bonne intégration de git, et un bon terminal dans l’UI.<br>
– <em>@Stoltheds</em></p>
</blockquote>
<p><ins><strong>J’ai questionné la notion d’<em>auto-complétion</em> avec une maquette d’un éditeur, suggérant la suite d’une ligne alors qu’elle est tapée.</strong> Ici, j’imagine que l’outil “comprend” que l’on souhaite créer une condition liée à une variable nommée <code>i</code>, et qu’il propose naturellement la valeur suivante par rapport à la condition exprimée au dessus – après 1 vient 2.<br>
<img src="img/else-if-autocompletion.png" alt="Else if autocompletion"><em>Fig. 28 : Maquette d’autocomplétion else/if</em></ins></p>
<h3 id="outils-qui-séloignent">Outils qui s’éloignent</h3>
<p><em>Processing</em>, <em>Scratch</em> ou encore <em>Flowgorithm</em> sont des exemples d’outils alternatifs, qui permettent de penser le code différemment. <strong>En proposant une visualisation et une manipulation virtuelle du code à produire, ils permettent au créatif d’accéder non seulement à une compréhension accrue de l’algorithme, mais à un monde de nouvelles possibilités créatives</strong> : c’est la thèse de Bret Victor, et l’objectif précis des outils qu’il crée lui-même.</p>
<p>J’ai donc cherché à m’inspirer de ses expérimentations, données en exemple plus haut, pour produire moi-même de nouvelles façons de visualiser et manipuler le code. J’imagine un <em>plugin</em> pour l’éditeur de texte <em>Atom</em>, permettant l’affichage d’un panneau intitulé “<em>Visual hints</em>” – indices visuels. Celui-ci donne à voir différentes notions de programmation relativement complexes à se figurer, et permet leur manipulation via diverses interactions.</p>
<p><ins><strong>J’ai d’abord traité l’affectation de variable, afin de prévoir une valeur en fonction des valeurs qui composent son calcul.</strong> Ici, la variable <code>freq</code> dépend de la valeur de <code>a</code>, je propose donc une courbe dans un repère orthogonal. On peut faire varier <code>a</code> grâce à un <em>slider</em>, choisir les valeurs minimale et maximale de cette variation au clic – ici <code>0</code> et <code>1</code> –, et survoler la courbe pour obtenir les valeurs de <code>a</code> sur l’axe des abscisses, et <code>freq</code> sur l’axe des ordonnées. On remplace donc le calcul mental par une visualisation interactive.<br>
<img src="img/variable-affectation.png" alt="Affectation de variable"><em>Fig. 29 : Maquette d’un outil de visualisation d’affectation de variable</em></ins></p>
<p><ins><strong>Une deuxième maquette porte sur la notion de <em>concaténation</em> : il s’agit de la juxtaposition de plusieurs chaînes de caractères pour n’en former qu’une seule.</strong> Cet exercice peut être difficile en raison de la rigourosité syntaxique du code : le moindre caractère manquant produira une erreur. Ici, une boucle à sept étapes génère une expression d’une couleur au format HSL<sup class="footnote-ref"><a href="#fn92" id="fnref92">92</a></sup>. Les sept expressions concaténées sont retranscrites dans un tableau afin de s’assurer de leur validité, et les sept couleurs produites sont prévisualisées via une pastille – on imagine que les expressions de couleur sont ainsi reconnues et interprétées. Je propose également un cercle chromatique permettant de comprendre la répartition des couleurs en fonction de l’angle donné.<br>
<img src="img/string-concatenation.png" alt="Concaténation de chaînes de caractères"><em>Fig. 30 : Maquette d’un outil de visualisation de concaténation de chaînes de caractères</em></ins></p>
<p><ins><strong>Une troisième recherche porte sur les boucles et conditions imbriquées.</strong> Le code ci-dessous génère un tableau en deux dimensions via l’imbrication de deux boucles – une pour les lignes, une pour les colonnes –, et une série de conditions avec quatre valeurs potentielles détermine la valeur de chaque cellule : 64 possibilités sont ainsi générées. Pour naviguer dans ces options, je propose une série de quatre tableaux, chacun correspondant à une option de la chaîne de conditions, dépendant ici de <code>r</code>. Les cellules peuvent ainsi être survolées pour afficher l’expression du calcul de leur valeur avec un maximum de variables remplacées par leur valeur dans cette configuration. En survolant une cellule précise d’un des tableaux <code>board</code>, la cellule concernée est mise en évidence dans le tableau <code>this.data</code>.<br>
<img src="img/nested-loops.png" alt="Boucles et conditions imbriquées"><em>Fig. 31 : Maquette d’un outil de visualisation de boucles et conditions imbriquées</em></ins></p>
<h1 id="conclusion">Conclusion</h1>
<p>Plusieurs questions ont été soulevées dans ce mémoire, mais toutes s’articulent autour d’une problématique commune : <strong>comment faciliter et encourager l’intégration de processus algorithmiques dans une pratique créative ?</strong> D’abord, la programmation s’inscrit en tant qu’outil, qui lui-même génère des outils : la pratique du code permet au bricodeur de concevoir ses propres outils, sous forme d’interfaces de création, de procédés liés à des données en temps réel ou encore de génération algorithmique. Cette capacité à programmer un outil offre un plus grand contrôle sur l’œuvre produite, l’auteur de l’algorithme pouvant à sa guise modifier les paramètres qui interviennent dans le procédé créatif. <strong>En intégrant des processus algorithmiques dans sa pratique, le designer-codeur donne donc lieu à de multiples possibilités créatives.</strong></p>
<p>Bien sûr, cette pratique demande une connaissance suffisante de la programmation : la manipulation des algorithmes est régie par des langages et des règles incontournables, afin de communiquer des instructions à la machine informatique. <strong>Une certaine maîtrise de l’écriture algorithmique est donc nécessaire</strong>, tout comme la maîtrise d’un métier Jacquard est nécessaire à son usage.</p>
<p><strong>Mais le code n’est pas qu’un outil, il est également un matériau</strong> à traiter, voire à jouer. À titre comparatif, si le designer graphique a pour matériau la couleur, la typographie ou encore la composition, et si le designer de produits a pour matériau les formes et les matières, il semble cohérent d’avancer que le bricodeur a, de la même manière, la programmation pour matériau. En percevant ainsi la pratique de l’écriture algorithmique, le créatif peut s’affranchir de certaines conventions, et proposer des approches singulières. <strong>En remettant en question la neutralité initiale du code, le créatif insuffle une notion esthétique dans ce matériau.</strong> Déjà présente dans la production finale d’un art dit “algorithmique”, qui traite exclusivement le logiciel comme outil, elle l’est à présent également dans le matériau initial : on parle alors d’art logiciel, où le code est perçu comme œuvre à part entière.</p>
<p><strong>Les outils du bricodeur doivent donc être polyvalents et adaptés à leur utilisateur.</strong> Ils doivent d’une part correspondre à son niveau technique, en représentant les algorithmes de façon à faire disparaître la latence dans la boucle de <em>feedback</em>, et en proposant des interactions qui permettent de manipuler, virtuellement ou physiquement, la matière algorithmique. D’autre part, ces outils ne doivent pas obstruer de pistes créatives, mais au contraire en favoriser, par les visualisations et manipulations qu’ils permettent. <strong>L’outil conditionne la pensée de l’utilisateur : un outil de créativité doit donc seconder et nourrir une pensée libre et inventive.</strong> On distingue alors deux types de réponses possibles : celle des interfaces qui se “rapprochent” de la pratique pour en favoriser la maîtrise, et celle des interfaces qui “s’éloignent” des modes classiques de représentation afin d’alimenter cette créativité.</p>
<h1 id="ressources">Ressources</h1>
<h2 id="bibliographie">Bibliographie</h2>
<p><cite>1</cite></p>
<p><cite>2</cite></p>
<p><cite>3</cite></p>
<p><cite>6</cite></p>
<p><cite>7</cite></p>
<p><cite>8</cite></p>
<p><cite>9</cite></p>
<p><cite>10</cite></p>
<p><cite>11</cite></p>
<p><cite>12</cite></p>
<p><cite>13</cite></p>
<h2 id="webographie">Webographie</h2>
<p><a href="https://github.com/tayllan/awesome-algorithms">Awesome Algorithms</a>, liste collaborative, GitHub</p>
<p><cite>14</cite></p>
<p><cite>19</cite></p>
<p><cite>20</cite></p>
<p><cite>21</cite></p>
<p><cite>22</cite></p>
<h1 id="remerciements">Remerciements</h1>
<p>Ce mémoire n’aurait pas été possible sans l’implication de mes tuteurs, Jean-Baptiste Joatton et Guillaume Giroud. Je tiens à les remercier grandement pour leur aide, leur expertise et leurs précieux conseils tout au long de ma recherche.</p>
<p>Je remercie également l’ensemble de l’équipe pédagogique du DSAA pour leur accompagnement, et celle du Pôle Supérieur de Design plus généralement pour ces cinq années où j’ai pu m’épanouir pleinement en découvrant le métier de designer.</p>
<p>Enfin, je remercie ma famille pour leur présence indéfectible et mes camarades de promotion sans qui, assurément, mes études n’auraient pas eu la même saveur.</p>
<h1 id="à-propos">À propos</h1>
<p>Ce mémoire a été rédigé en Markdown grâce à l’application web <a href="https://stackedit.io/">StackEdit</a>, et publié régulièrement sur <a href="https://github.com/Ashugeo/ashugeo.github.io">GitHub</a> pour assurer la conservation d’un historique de versions. Les caractères utilisés sont <em>Source Sans Pro</em> et <em>Source Code Pro</em>, dessinés par Paul D. Hunt. Le choix d’une publication web plutôt qu’imprimée a non seulement été motivé par le sujet même de cette recherche, mais s’inspire également des thèses d’<a href="http://www.softphd.com/">Anthony Masure</a> et de <a href="http://www.designing-design-tools.nolwennmaudet.com">Nolwenn Maudet</a>. La mise en page <em>reponsive</em> – adaptée à toutes les tailles d’écrans – a été réalisée en HTML et CSS, et les interactions en JavaScript et jQuery avec l’éditeur de texte Atom : il est possible de changer la taille du texte à la convenance du lecteur, et également de passer en mode "nuit" pour une lecture plus confortable dans un environnement sombre.</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>Alan Cooper, développeur américain reconnu pour ses travaux effectués dans le champ du design <abbr title="User Experience">UX</abbr>, donne son avis sur le sujet dans un article intitulé “<a href="https://medium.com/@MrAlanCooper/should-designers-code-f7b745b8cd03"><em>Should Designers Code?</em></a>”. Il explique surtout pourquoi la question n’est, selon lui, pas vraiment pertinente : dans ce débat, il est moins question de vérité absolue que de goût personnel. <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>Serge Abiteboul et Gilles Dowek sont chercheurs à l’<abbr title="Institut national de recherche en informatique et en automatique">INRIA</abbr> et professeurs à l’<abbr title="École normale supérieure">ENS</abbr> de Paris-Saclay. <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p><cite>1:11</cite> <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>La recherche par force brute (<em>brute force</em> en anglais), aussi connue sous le nom “générer et tester” est une technique générale de résolution de problème qui consiste à énumérer tous les candidats possibles à une solution et vérifier chacun d’eux afin de déterminer lequel répond le mieux au problème. <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p>Le sociologue français Dominique Cardon propose une classification des typologies d’algorithmes qui régissent notre quotidien – notamment sur le web. Il distingue quatre familles, qu’il illustre spatialement : “les mesures peuvent se trouver <em>à côté</em>, <em>au-dessus</em>, <em>dans</em> ou <em>en dessous</em> des données numériques”. <cite>2:17–18</cite> <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p>Divers exemples d’algorithmes d’intelligence artificielle dans le design sont énumérés sur le site <a href="http://algorithms.design/">algorithms.design</a>. <a href="#fnref6" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn7" class="footnote-item"><p>Le <em>creative coding</em> – ou “code créatif” – est un type de programmation informatique où les langages de programmation sont employés à des fins d’innovation expressive – souvent esthétique – plutôt que fonctionnelle. <a href="#fnref7" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn8" class="footnote-item"><p><cite>11:328</cite> <a href="#fnref8" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn9" class="footnote-item"><p><cite>12:29–30</cite> <a href="#fnref9" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn10" class="footnote-item"><p><cite>12:27</cite> <a href="#fnref10" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn11" class="footnote-item"><p>Le terme “matériau” suggère ici une relation de proximité : en se rapprochant du fonctionnement et de la logique d’un algorithme, le bricodeur a une meilleure capacité à le façonner, le transformer, l’adapter selon ses envies. <a href="#fnref11" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn12" class="footnote-item"><p>Le <abbr title="Massachusetts Institute of Technology">MIT</abbr> est un institut de recherche américain spécialisé dans les domaines de la science et de la technologie. <a href="#fnref12" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn13" class="footnote-item"><p><em>Design by Numbers</em>, (parfois noté DBN), est une expérimentation logicielle menée par John Maeda et ses étudiants du MIT en 1999. Il s’agit d’un outil de conception graphique par le code : les choix (formes, tracés, positionnements…) sont matérialisés par une succession d’instructions algorithmiques. <a href="#fnref13" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn14" class="footnote-item"><p><em>Processing</em> est un langage de programmation intégré à un IDE, initié au MIT en 2001 par Casey Reas et Ben Fry – deux élèves de John Maeda. <a href="#fnref14" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn15" class="footnote-item"><p><cite>10:10–11</cite> <a href="#fnref15" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn16" class="footnote-item"><p><cite>13:25</cite> <a href="#fnref16" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn17" class="footnote-item"><p>Par <em>faciliter</em>, j’entends “aider en rendant plus facile” : il s’agit d’ôter les éventuels obstacles ou difficultés qui pourraient empêcher la réalisation d’une chose. <a href="#fnref17" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn18" class="footnote-item"><p>Par <em>encourager</em>, j’entends le fait de donner le désir et les moyens d’entreprendre une action, soutenir quelqu’un dans une démarche intellectuelle ou morale. <a href="#fnref18" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn19" class="footnote-item"><p>Par abus de langage, et en raison de notre contexte technologique contemporain, la notion d’algorithmes symboliques a presque remplacé celle, plus générique, d’algorithmes : l’informatique a orienté l’emploi même du mot. <a href="#fnref19" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn20" class="footnote-item"><p>Étymologiquement, le terme <em>algorithme</em> est d’ailleurs issu de la combinaison du mot grec <em>arithmos</em>, qui signifie “nombre”, et du mot latin <em>algorismus</em>, dérivé du nom du mathématicien Al-Khwarizmi – scientifique perse du VII<sup>ème</sup> siècle, auteur d’un ouvrage classifiant les procédés algébriques de son époque. <a href="#fnref20" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn21" class="footnote-item"><p><cite>24:6–8</cite> <a href="#fnref21" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn22" class="footnote-item"><p><cite>1:18–19</cite> <a href="#fnref22" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn23" class="footnote-item"><p>On pourrait d’ailleurs s’interroger sur ce qu’il adviendrait d’un algorithme lu à l’envers… <a href="#fnref23" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn24" class="footnote-item"><p>Un booléen est un type de variable à deux états. Cette terminologie fait référence aux travaux de George Boole, célèbre logicien et mathématicien  britannique, qui en 1845 a établi les bases de la “logique booléenne”, n’acceptant que deux valeurs numériques : 0 et 1. Cet algèbre connaîtra une importance capitale dans l’informatique et est encore énormément employée de nos jours. <a href="#fnref24" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn25" class="footnote-item"><p>Le terme <em>abaque</em> désigne tout instrument mécanique plan facilitant le calcul. <a href="#fnref25" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn26" class="footnote-item"><p>Blaise Pascal était un mathématicien, physicien, inventeur et philosophe français. À 19 ans, il invente la première machine à calculer, dénommée <em>machine d’arithmétique</em>, puis <em>pascaline</em>. <a href="#fnref26" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn27" class="footnote-item"><p>Gottfried Leibniz était un philosophe, scientifique, mathématicien et logicien allemand. <a href="#fnref27" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn28" class="footnote-item"><p>Le <em>bit</em>, abréviation de <em>binary digit</em> (chiffre binaire) est l’unité d’information la plus basique : un chiffre binaire ne peut avoir que deux valeurs, et ainsi être représenté avec un dispositif à deux états. Ces valeurs d’états sont le plus souvent représentées comme 0 ou 1. <a href="#fnref28" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn29" class="footnote-item"><p>Charles Babbage était un mathématicien et inventeur britannique du XIX<sup>ème</sup> siècle. Il fut l’un des principaux précurseurs de l’informatique. <a href="#fnref29" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn30" class="footnote-item"><p><a href="https://fr.wikipedia.org/wiki/Machine_analytique#Description_et_fonctionnement">Machine analytique – Description et fonctionnement</a> sur Wikipédia <a href="#fnref30" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn31" class="footnote-item"><p>En mathématiques, les nombres de Bernoulli constituent une suite de nombres rationnels. Ces nombres ont d’abord été étudiés par Jacques Bernoulli, mathématicien et physicien suisse du XVII<sup>ème</sup>siècle. <a href="#fnref31" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn32" class="footnote-item"><p>Alan Turing était un mathématicien et cryptologue britannique, dont les travaux ont fondé l’informatique moderne. Après l’invention de la machine de Turing – qui contribue à la thèse de Church-Turing autour de la notion de problème de <em>calculabilité</em> –, il participe au décryptage des codes secrets de la machine allemande Enigma pendant la Seconde Guerre Mondiale – ce qui joua un rôle essentiel dans la victoire des Alliés. Turing poursuit des recherches en informatique et formule le “test de Turing”, fondamental dans le champ de l’intelligence artificielle. <a href="#fnref32" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn33" class="footnote-item"><p><cite>3:16–18</cite> <a href="#fnref33" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn34" class="footnote-item"><p><a href="https://fr.wikipedia.org/wiki/Architecture_de_von_Neumann#Architecture">Architecture de von Neumann</a> sur Wikipédia <a href="#fnref34" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn35" class="footnote-item"><p><cite>23:2</cite> <a href="#fnref35" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn36" class="footnote-item"><p><cite>7:15</cite> <a href="#fnref36" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn37" class="footnote-item"><p><cite>7:26</cite> <a href="#fnref37" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn38" class="footnote-item"><p><cite>8:7–8</cite> <a href="#fnref38" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn39" class="footnote-item"><p>La notion de “signifiant et signifié” a été théorisée par le linguiste suisse Ferdinand de Saussure dans son ouvrage “<em>Cours de linguistique générale</em>”. Tel qu’il les définit, le <em>signifié</em> désigne le concept, et le <em>signifiant</em> désigne l’image sonore : de Saussure exclut donc les autres formes de représentation – graphique, gestuelle, etc. <a href="#fnref39" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn40" class="footnote-item"><p><a href="http://classes.bnf.fr/dossiecr/sys-ecri.htm">“<em>Les systèmes d’écriture</em>”</a> sur <abbr title="Bibliothèque Nationale de France">BNF</abbr> <a href="#fnref40" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn41" class="footnote-item"><p>Le terme de <em>composition</em>, dont l’étymologie signifie “poser ensemble”, peut s’entendre dans deux sens : soit celui de faire un tout à partir d’éléments différents, soit celui d’accorder, de mettre en ordre. Ici, on suppose qu’il existe des règles de composition préalablement définies : un syntaxe permettant à la machine d’interpréter le code. <a href="#fnref41" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn42" class="footnote-item"><p>Voici une liste non exhaustive énumérant quelques grandes catégories de genres littéraires : poétiques (poésies, poèmes, haïkus, chansons mais aussi calligrammes), narratifs (romans, comptes, nouvelles, biographie), théâtraux (pièces de théâtre de tous registres), épistolaires (constitués de lettres échangées), argumentatifs (essais, pensées ou même pamphlets), graphiques (roman graphique, bande dessinée), ou encore formes brèves (proverbes, aphorisme, énigme, blague, etc.) <a href="#fnref42" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn43" class="footnote-item"><p><cite>8:10</cite> <a href="#fnref43" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn44" class="footnote-item"><p>Le groupe µ – prononcer “mu” – est un collectif interdisciplinaire de chercheurs en linguistique, sociologie ou encore sémiotique, fondé en 1967. <a href="#fnref44" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn45" class="footnote-item"><p>Les auteurs décrivent quatre opérations fondamentales qui peuvent constituer une métabole : l’addition, la suppression, la substitution ou la permutation d’unités phonétiques ou morphologiques. Dagonet distingue ces “<em>iconographies ordinatrices et inventives</em>” d’une autre catégorie appelée “<em>iconographies nouménalisantes et explicatives</em>”, parmi lesquelles il compte notamment la représentation des molécules en chimie, ou le dessin des volumes géométriques. <a href="#fnref45" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn46" class="footnote-item"><p>Voir quelques exemples visuels et animés sur le site <a href="http://code-poetry.com/"><em>./code --poetry</em></a> <a href="#fnref46" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn47" class="footnote-item"><p>On distinguera la poétique de l’écriture du code – la manière de l’écrire, sa forme graphique de conditions imbriquées par exemple – et la poétique du code même – ce que fait le programme, ce que ces conditions imbriquées vont produire comme résultat. Dans les exemples cités ici, ces deux formes de “poésie algorithmique” sont volontairement couplées. <a href="#fnref47" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn48" class="footnote-item"><p><cite>5</cite> <a href="#fnref48" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn49" class="footnote-item"><p><cite>3:67</cite> <a href="#fnref49" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn50" class="footnote-item"><p><a href="https://fr.wikipedia.org/wiki/Programme_informatique">Programme informatique</a> sur Wikipédia <a href="#fnref50" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn51" class="footnote-item"><p><cite>3:46</cite> <a href="#fnref51" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn52" class="footnote-item"><p><cite>4</cite> <a href="#fnref52" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn53" class="footnote-item"><p><a href="https://fr.wikipedia.org/wiki/What_you_see_is_what_you_get"><em>What you see is what you get</em></a> sur Wikipédia <a href="#fnref53" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn54" class="footnote-item"><p><cite>25</cite> <a href="#fnref54" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn55" class="footnote-item"><p><a href="https://fr.wikipedia.org/wiki/Liste_de_langages_de_programmation">Liste de langages de programmation</a> sur Wikipédia <a href="#fnref55" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn56" class="footnote-item"><p><a href="https://stackoverflow.com">Stack Overflow</a> est une plateforme web où chacun peut poser des questions ou apporter des réponses sur de nombreux thèmes liés à la programmation informatique. Il fait partie du réseau de sites Stack Exchange, qui intègre de nombreux services basés sur le même principe d’entraide communautaire, dans des disciplines variées. <a href="#fnref56" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn57" class="footnote-item"><p><a href="https://stackoverflow.blog/2015/07/29/why-are-there-so-many-programming-languages/">“<em>Why are there so many programming languages?</em>”</a> sur StackOverflow <a href="#fnref57" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn58" class="footnote-item"><p>Quelques exemples : la programmation <em>orientée objet</em>, où l’on considère le programme comme une collection d’<em>objets</em> en interaction ; la programmation <em>procédurale</em> qui fait appel à une suite de <em>fonctions</em> ; la programmation <em>déclarative</em> qui consiste à déclarer les données d’un problème puis à le faire résoudre par le programme ; etc. On remarquera que certains langages mêlent plusieurs paradigmes : le JavaScript par exemple, créé en 1995 et aujourd’hui un des plus présents notamment sur le web, est multi-paradigme – il est à la fois orienté objet, impératif et déclaratif. <a href="#fnref58" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn59" class="footnote-item"><p><a href="https://octoverse.github.com/">GitHub Octoverse 2017</a> <a href="#fnref59" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn60" class="footnote-item"><p>GitHub est une plateforme d’hébergement de gestion de versions collaborative. Basé sur le logiciel <em>git</em>, qui permet d’enregistrer des versions de son travail à différentes étapes de l’avancement du projet, GitHub est communautaire et chacun peut dupliquer le code d’autrui – si celui-ci est <em>ouvert</em>, ou <em>open-source</em> –, y apporter des modifications ou des remarques. <a href="#fnref60" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn61" class="footnote-item"><p>Ces trois termes – <em>construit</em>, <em>artificiel</em> et <em>formel</em> – soulèvent trois notions. Pour le langage construit, on soulignera son aspect <em>délibéré</em>. Le langage artificiel s’oppose au caractère naturel – au sens de culturel, spontané –, il est donc <em>élaboré</em>. Enfin, le langage formel désigne une forme dénuée de contenu, c’est-à-dire de <em>référence</em>. Ainsi, tout langage artificiel n’est pas nécessairement formel, mais tout langage formel est nécessairement artificiel. <a href="#fnref61" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn62" class="footnote-item"><p>Voir une <a href="https://twitter.com/Ashugeo/status/927947488950177793">démonstration en vidéo du prototype “<em>text2code</em>”</a> sur Twitter, et les réponses à ce tweet : certains de mes contacts se sont emparés de mon expérimentation pour produire leur propre proposition. <a href="#fnref62" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn63" class="footnote-item"><p><cite>9:395</cite> <a href="#fnref63" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn64" class="footnote-item"><p>Le choix entre espaces et tabulations pour l’indentation est depuis de nombreuses années sujet à débats dans la sphère informatique, chaque option ayant son lot d’avantages et d’inconvénients. Des tendances statistiques s’observent selon le langage utilisé, comme le montre <a href="https://ukupat.github.io/tabs-or-spaces/">une recherche menée sur GitHub</a>. <a href="#fnref64" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn65" class="footnote-item"><p><cite>3:39</cite> <a href="#fnref65" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn66" class="footnote-item"><p>Les plus connus sont le <em>camelCase</em>, le <em>PascalCase</em> et le <em>snake_case</em>, dont les intitulés même illustrent leur principe : des capitales au début de chaque mot – incluant ou non le premier –, ou des <em>underscores</em> entre les mots. <a href="#fnref66" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn67" class="footnote-item"><p><cite>17:86–87</cite> <a href="#fnref67" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn68" class="footnote-item"><p>Le site <a href="http://esoteric.codes/">esoteric.codes</a> regroupe plusieurs exemples créatifs mettant en jeu des langages ésotériques. <a href="#fnref68" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn69" class="footnote-item"><p>En programmation, “obsfuquer” signifie rendre un programme illisible, en transformant notamment le nom des variables afin de rendre la structure globale de l’algorithme incompréhensible et inexploitable. <a href="#fnref69" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn70" class="footnote-item"><p>On retrouve d’ailleurs ici un effet similaire à la notion de littérature algorithmique et aux exemples de code poétique cités plus haut. <a href="#fnref70" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn71" class="footnote-item"><p><cite>18:49</cite> <a href="#fnref71" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn72" class="footnote-item"><p>En mathématiques, on parle aussi de “belle” démonstration pour qualifier une preuve dont l’esthétique se caractérise par sa simplicité et son économie de moyens. <a href="#fnref72" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn73" class="footnote-item"><p><cite>16:107</cite> <a href="#fnref73" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn74" class="footnote-item"><p>Le terme de <em>codework</em> – dérivé d’<em>artwork</em>, “œuvre d’art” en français – désigne une écriture poétique dont la syntaxe et le vocabulaire sont empruntés aux langages de programmation. Le projet <a href="https://monoskop.org/images/5/55/Code_Poems_2012.pdf"><em>Code Peoms</em></a> du designer Ishac Bertran regroupe une série d’exemples de <em>codeworks</em>. <a href="#fnref74" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn75" class="footnote-item"><p><cite>15:148–149</cite> <a href="#fnref75" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn76" class="footnote-item"><p>Une définition plus exhaustive comprend également un registre d’état qui mémorise l’état courant de la machine, ainsi qu’une table des transitions pour savoir si la tête de lecture doit aller à gauche ou à droite en fonction de son état et de la bande. <a href="#fnref76" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn77" class="footnote-item"><p>Voir les vidéos sur le site <a href="https://dynamicland.org/">Dynamicland</a>. <a href="#fnref77" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn78" class="footnote-item"><p>Bret Victor est un designer d’interaction et informaticien, dont le travail porte notamment sur les outils et les interfaces permettant de comprendre et de créer. <a href="#fnref78" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn79" class="footnote-item"><p>Ici c’est la forme, la surface, voire la <em>matière</em> de l’interface qui change, mais elle demeure une interface directe, agissant sur une autre interface indirecte qui sera interprétée et retraduite par l’ordinateur. <a href="#fnref79" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn80" class="footnote-item"><p><a href="https://fo.am/blog/2017/11/27/pattern-matrix-algomech2/">“<em>How to design a tangible programming language</em>”</a> sur <em>[foam]</em> <a href="#fnref80" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn81" class="footnote-item"><p>Les méthodes de tri – <em>sorting algorithms</em> – les plus connues sont illustrées sous forme d’animations sur la page <a href="https://www.toptal.com/developers/sorting-algorithms"><em>Sorting Algorithms Animations</em></a> du site d’offre d’emplois <em>toptal</em>. <a href="#fnref81" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn82" class="footnote-item"><p><cite>14</cite> <a href="#fnref82" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn83" class="footnote-item"><p>Le <em>feedback</em> – “rétroaction” en français – est une forme de retour d’information qui, dans le contexte d’une interface numérique, permet à l’utilisateur de prendre conscience de la validité ou non de l’action qu’il entreprend. Ici, on entend plus généralement le terme <em>feedback</em> comme l’échange entre la machine et l’utilisateur. <a href="#fnref83" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn84" class="footnote-item"><p><a href="https://vimeo.com/36579366">Bret Victor - Inventing on Principle</a> sur Vimeo <a href="#fnref84" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn85" class="footnote-item"><p><a href="https://vimeo.com/36579366">Bret Victor - Inventing on Principle</a> sur Vimeo <a href="#fnref85" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn86" class="footnote-item"><p>Un <em>framework</em>, ou “cadre de travail”, désigne un ensemble d’outils de programmation structurant les bases techniques et architecturales d’un projet. <a href="#fnref86" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn87" class="footnote-item"><p>Le qualificatif <em>draggable</em> est ici utilisé comme dérivé de <em>drag and drop</em> – en français glisser-déposer. Un élément d’interface <em>draggable</em> a donc la faculté d’être déplacé à l’écran. Ici, les variables restent fixes, seule leur valeur change en fonction des mouvements de la souris. <a href="#fnref87" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn88" class="footnote-item"><p><a href="https://github.com/dataarts/dat.gui">dat.GUI</a> est une librairie JavaScript qui injecte une interface graphique de contrôle paramétrique au sein d’une page web. Le créateur d’une expérimentation graphique peut par exemple le mettre en place pour faire varier facilement les paramètres de son œuvre, mais également le diffuser tel quel afin que chacun puisse intervenir sur les contrôleurs. <a href="#fnref88" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn89" class="footnote-item"><p>Un <em>slider</em>, ou “curseur de défilement”, est un composant d’interface graphique permettant de faire varier une valeur numérique en déplaçant un curseur sur une échelle graduée. <a href="#fnref89" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn90" class="footnote-item"><p>L’<em>auto-complétion</em> – ou “complètement automatique” – est une fonctionnalité permettant à l’utilisateur de limiter la saisie, en se voyant proposer un complément qui pourrait convenir à la chaîne de caractères qu’il a commencé à taper. Ce principe est souvent rencontré dans les moteurs de recherches, qui affichent un certain nombre de suggestions à la suite des mots-clés tapés. <a href="#fnref90" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn91" class="footnote-item"><p>Un des premiers défenseurs de cette thèse fut Ben Schneiderman, notamment dans son article <em>Direct Manipulation</em> paru en 1997. <a href="#fnref91" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn92" class="footnote-item"><p>Le modèle <em>HSL</em> – pour <em>hue saturation lightness</em>, en français TSL, pour “teinte saturation luminosité” –, est un format d’écriture des couleurs. La teinte est donnée sous forme d’angle autour du cercle chromatique, et la saturation et la luminosité par un indice entre 0 et 100. <a href="#fnref92" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

    </div>
  </div>
  <div class="auto-dark">
      <p><strong>Il se fait tard.</strong> La page est passée automatiquement en mode nuit.<br><a href="#" class="back-light">Revenir au mode jour.</a></p>
      <div class="close">✕</div>
  </div>
  <div class="ctrl">
      <div class="clickable" data-tool="toc" data-tooltip="Sommaire"></div>
      <div class="clickable" data-tool="bigger" data-tooltip="Augmenter la taille des caractères"></div>
      <div class="clickable" data-tool="smaller" data-tooltip="Réduire la taille des caractères"></div>
      <div class="clickable" data-tool="mode" data-tooltip="Mode jour/nuit"></div>
      <div class="spacer">

      </div>
      <div class="lang">
          <span class="active">FR</span><span><a href="./en">EN</a></span>
      </div>
  </div>
</div>

</body>

</html>
