<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mémoire Hugo Sainte-Marie</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
  <link rel="stylesheet" href="../css/main.min.css" />
  <script src="../js/jquery-3.2.1.min.js"></script>
  <script src="../js/main.js"></script>
  <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
</head>

<body class="stackedit">
  <div class="stackedit__left">
    <div class="stackedit__toc">
      
<ul>
<li><a href="#idesbrasbrideas">IDEsASIDEAS</a>
<ul>
<li><a href="#les-outils-de-programmation-algorithmique-au-service-du-designer">Les outils de programmation algorithmique au service du designer</a></li>
</ul>
</li>
<li><a href="#introduction">Introduction</a>
<ul>
<li>
<ul>
<li><a href="#quest-ce-quun-algorithme-">Qu’est-ce qu’un algorithme ?</a></li>
<li><a href="#la-place-des-algorithmes">La place des algorithmes</a></li>
<li><a href="#bricodage">Bricodage</a></li>
<li><a href="#concevoir-ses-outils">Concevoir ses outils</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#le-matériau-algorithme">Le matériau algorithme</a>
<ul>
<li><a href="#approche-technico-historique">Approche technico-historique</a>
<ul>
<li><a href="#de-la-main-à-la-machine">De la main à la machine</a></li>
<li><a href="#jacquard-ou-le-tissage-programmé">Jacquard, ou le tissage programmé</a></li>
<li><a href="#la-machine-analytique-de-babbage">La machine analytique de Babbage</a></li>
<li><a href="#la-révolution-turing">La révolution Turing</a></li>
<li><a href="#les-intelligences-artificielles">Les intelligences artificielles</a></li>
</ul>
</li>
<li><a href="#approche-fondamentale">Approche fondamentale</a>
<ul>
<li><a href="#séquence">Séquence</a></li>
<li><a href="#affectation">Affectation</a></li>
<li><a href="#itération">Itération</a></li>
<li><a href="#condition">Condition</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#manipuler-le-matériau--lécriture-algorithmique">Manipuler le matériau : l’écriture algorithmique</a>
<ul>
<li><a href="#quest-ce-quécrire-">Qu’est-ce qu’écrire ?</a>
<ul>
<li><a href="#écriture--le-langage-imagé">Écriture : le langage imagé</a></li>
<li><a href="#écritures--3-typologies">Écritures : 3 typologies</a></li>
<li><a href="#lécriture-émancipée">L’écriture émancipée</a></li>
</ul>
</li>
<li><a href="#lécriture-algorithmique">L’écriture algorithmique</a>
<ul>
<li><a href="#de-lalgorithme-au-programme">De l’algorithme au programme</a></li>
<li><a href="#de-lordinateur-à-linformatique">De l’ordinateur à l’informatique</a></li>
<li><a href="#langages-naturels-et-langages-formels">Langages naturels et langages formels</a></li>
<li><a href="#langages-informatiques">Langages informatiques</a></li>
<li><a href="#lignes-de-code-règles-et-conventions">Lignes de code, règles et conventions</a></li>
</ul>
</li>
<li><a href="#outils-décriture-algorithmique">Outils d’écriture algorithmique</a>
<ul>
<li><a href="#ide-et-éditeurs-de-texte">IDE et éditeurs de texte</a></li>
<li><a href="#programmation-visuelle">Programmation visuelle</a></li>
<li><a href="#workflow">Workflow</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#modes-singuliers-de-programmation-algorithmique">Modes singuliers de programmation algorithmique</a>
<ul>
<li><a href="#pratiques-singulières">Pratiques singulières</a>
<ul>
<li><a href="#le-code-auto-modifiant">Le code auto-modifiant</a></li>
<li><a href="#langages-ésotériques">Langages ésotériques</a></li>
<li><a href="#esthétiques-du-code">Esthétiques du code</a></li>
<li><a href="#programmation-tangible--la-réflexion-par-la-main">Programmation tangible : la réflexion par la main</a></li>
</ul>
</li>
<li><a href="#modes-de-représentations">Modes de représentations</a>
<ul>
<li><a href="#représenter-visuellement-les-algorithmes">Représenter visuellement les algorithmes</a></li>
<li><a href="#représenter-au-sein-de-lide">Représenter au sein de l’IDE</a></li>
<li><a href="#manipuler-au-sein-de-lide">Manipuler au sein de l’IDE</a></li>
</ul>
</li>
<li><a href="#la-dualité-dans-lexpérience-de-loutil">La dualité dans l’expérience de l’outil</a>
<ul>
<li><a href="#loutil-se-rapprochant">L’outil se rapprochant</a></li>
<li><a href="#loutil-séloignant">L’outil s’éloignant</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#conclusion">Conclusion</a></li>
<li><a href="#ressources">Ressources</a>
<ul>
<li><a href="#bibliographie">Bibliographie</a></li>
<li><a href="#webographie">Webographie</a>
<ul>
<li><a href="#état-de-lart">État de l’art</a></li>
</ul>
</li>
</ul>
</li>
</ul>

    </div>
  </div>
  <div class="stackedit__right">
    <div class="stackedit__html">
      <h1 id="idesbrasbrideas">IDEs<br>AS<br>IDEAS</h1>
<h2 id="les-outils-de-programmation-algorithmique-au-service-du-designer">Les outils de programmation algorithmique au service du designer</h2>
<h1 id="introduction">Introduction</h1>
<h3 id="quest-ce-quun-algorithme-">Qu’est-ce qu’un algorithme ?</h3>
<p><strong>Un algorithme est une séquence d’instructions qui vise à être exécutée afin de produire un résultat.</strong> Pour comprendre ou enseigner la notion d’algorithme, on fait bien souvent appel à des cas concrets que l’on rencontre dans la vie quotidienne. Une recette de cuisine, par exemple, constitue un algorithme : on y trouve des paramètres variables (les ingrédients, quantités, ustensiles utilisés) ainsi que des <em>instructions</em> (casser en morceaux, cuire au bain-marie, couper en dés). Enfin, le <em>résultat</em> obtenu lorsqu’on suit minutieusement cette recette de cuisine est, assurément, le plat qu’on a alors préparé. Cette vision nous fournit une première définition du concept d’algorithme, donnée par Serge Abiteboul et Gilles Dowek<sup class="footnote-ref"><a href="#fn1" id="fnref1">1</a></sup> dans leur ouvrage “<em>Le temps des algorithmes</em>”.</p>
<blockquote>
<p>Un algorithme est un procédé qui permet de résoudre un problème, sans avoir besoin d’inventer une solution à chaque fois. Avec cette définition, il est clair que, depuis l’aube de l’humanité, nous inventons, utilisons et transmettons des algorithmes : cuisine, taille du silex, pêche à la ligne, culture des lentilles et du blé, etc.<sup class="footnote-ref"><a href="#fn2" id="fnref2">2</a></sup></p>
</blockquote>
<h3 id="la-place-des-algorithmes">La place des algorithmes</h3>
<p>Nous entretenons donc une intime relation avec les algorithmes, et ce depuis l’aube de l’humanité. Toutefois, avec l’apparition de l’informatique au siècle dernier, les algorithmes se sont ancrés encore plus profondément dans nos vies. Au fil des années, ils se sont répandus de telle sorte qu’on les rencontre aujourd’hui partout, sans même nous en apercevoir. Abiteboul et Dowek établissent une liste d’usages variés d’algorithmes, qui existent aujourd’hui sous forme de programmes embarqués dans nos équipements numériques :</p>
<ul>
<li>le calcul : transformer des données – généralement des nombres –, résoudre des équations algébriques, encoder ou décoder un message ;</li>
<li>la gestion de l’information : stocker, archiver et indexer des données ;</li>
<li>la communication : faire circuler l’information via des <em>protocoles</em> de communication ;</li>
<li>l’exploration : parcourir un grand nombre de possibilités afin de définir celle qui correspond le mieux à un problème donné – plus court chemin, meilleure répartition, etc. – on appelle aussi cette méthode la recherche exhaustive ou “recherche par force brute”<sup class="footnote-ref"><a href="#fn3" id="fnref3">3</a></sup> ;</li>
<li>l’analyse des données : agréger des statistiques et les classifier, afin par exemple de prédire des comportements – suggestions, recommandations ou encore publicité ciblée grâce au <em>big data</em><sup class="footnote-ref"><a href="#fn4" id="fnref4">4</a></sup> ;</li>
<li>mais aussi : le traitement du signal (transformer, amplifier ou compresser une image ou un son), la commande d’un objet (établir la conduite d’une voiture autonome à partir des données captées), la fabrication de biens (automatiser la production industrielle), la modélisation et la simulation (dans la recherche scientifique, en établissant des théories) ;</li>
<li>et enfin, dans le champ du design, comme dans le cas d’intelligences artificielles mises au profit de la création – dont divers exemples sont énumérés sur le site <a href="http://algorithms.design/">algorithms.design</a>.</li>
</ul>
<p>La présence croissante des algorithmes dans nos vies peut soulever des craintes – pour certaines justifiées – et en font aujourd’hui un objet de débat politique. <strong>Dans ce contexte, on tend toutefois à oublier une caractéristique fondamentale des algorithmes : ils sont écrits par des êtres humains.</strong> Les programmes que nous utilisons au quotidien sont – ou ont été – conçus par des développeurs, qui emploient des outils spécifiques à leur tâche et mobilisent des savoirs associés à ces outils : mathématiques, connaissance des langages, gestion de projet, etc. Ce sont ces outils qui forment le domaine d’étude précis de ce mémoire, que je mène avec une approche dite “de design”, c’est-à-dire centrée sur les utilisateurs et les usages.</p>
<h3 id="bricodage">Bricodage</h3>
<p>Les contextes d’application et problématiques envisageables liés à la programmation algorithmique – ou <em>code</em> – sont infiniment variés : conception de systèmes, développement d’objets numériques, création artistique, visualisation de l’immatériel, etc. <strong>En tant que designer, je souhaite m’intéresser plus particulièrement aux diverses pratiques mobilisant l’écriture de programmes informatiques dans un but créatif, aujourd’hui regroupées sous le terme de <em>creative coding</em></strong><sup class="footnote-ref"><a href="#fn5" id="fnref5">5</a></sup>.</p>
<p>J’aborde ce sujet en assumant une démarche personnelle très empirique : comme beaucoup, je dois expérimenter pour comprendre. Compte tenu de la dimension relativement technique de l’écriture algorithmique, sa pratique constitue pour moi l’approche de recherche en design la plus adaptée à mon profil, et permet de concrétiser l’étude en proposant des solutions applicatives. Aussi, mon profil, avec son niveau de compétence propre, est celui que vise spécifiquement mon projet de recherche : <strong>mon étude concerne le codeur <em>amateur</em>, situé à mi-chemin entre le codeur néophyte et le développeur confirmé.</strong> En effet, je ne me concentre pas sur la question de l’apprentissage du code, qui concerne des novices – souvent des enfants. Ce contexte est au cœur de l’actualité, car l’enseignement du code se fait – à juste titre – de plus en plus entendre comme un besoin essentiel de nos jours. De nombreux projets et programmes existent ou se développent, avec le souci commun de proposer une découverte pédagogique et accessible des nombreuses possibilités qu’offre la pratique du code. Je ne traite pas non plus des méthodes de travail de développeurs confirmés, notamment car les domaines dans lesquels ils exercent, très pointus techniquement, ne relèvent que rarement d’une forme de créativité artistique – mais plutôt d’une créativité technique caractérisée par la recherche d’une méthode logicielle optimale. Le champ d’étude de ce mémoire se concentre donc sur le niveau moyen situé entre ces deux extrêmes : celui des développeurs créatifs hybrides, des designers-codeurs amateurs. J’appellerai cette catégorie de pratiquants les “bricodeurs”, pour reprendre le terme de “bricodage” proposé par David-Olivier Lartigaud dans son article du même nom, paru dans l’ouvrage Art++<sup class="footnote-ref"><a href="#fn6" id="fnref6">6</a></sup>.</p>
<blockquote>
<p>Le jeu de mot “bricoder” […] pourrait décrire l’attitude “esthétique” qui consiste à bricoler/programmer “l’object informatique”. Le “bricodage” serait cette curiosité, ce désir d’ouvrir la “boîte noire” à des fins réflexives, artistiques ou esthétiques. Une approche de l’informatique “au-delà” du simple bidouillage qui offre “prise” sur la machine.</p>
</blockquote>
<p><img src="img/bricodeur.png" alt="Champ d'étude du mémoire"></p>
<p>Lartigaud base sa définition du bricodage sur celle du bricolage, proposée par Claude Lévi-Strauss. Dans “<em>La pensée sauvage</em>”, celui-ci établit une distinction entre bricoleur et ingénieur.</p>
<blockquote>
<p>On pourrait être tenté de dire que [l’ingénieur] interroge l’univers, tandis que le bricoleur s’adresse à une collection de résidus d’ouvrages humains, c’est-à-dire à un sous-ensemble de la culture. […] La différence n’est donc pas aussi absolue qu’on serait tenté de l’imaginer ; elle demeure réelle, cependant, dans la mesure où […] l’ingénieur cherche toujours à s’ouvrir un passage et à se situer au delà, tandis que le bricoleur, de gré ou de force, demeure en deçà, ce qui est une autre façon de dire que le premier opère au moyen de concepts, le second au moyen de signes. <sup class="footnote-ref"><a href="#fn7" id="fnref7">7</a></sup></p>
</blockquote>
<p>Ainsi, l’ingénieur est, selon Lévi-Strauss, extérieur au monde dans lequel il développe son projet, tandis que le bricoleur, au contraire, fait partie du monde dans lequel il doit construire avec des “résidus d’ouvrages humains”, ou “moyens du bord”.</p>
<blockquote>
<p>Le bricoleur est apte à exécuter un grand nombre de tâches diversifiées ; mais […] son univers instrumental est clos, et la règle de son jeu est de toujours s’arranger avec les “moyens du bord”, c’est-à-dire un ensemble à chaque instant fini d’outils et de matériaux […]. <sup class="footnote-ref"><a href="#fn8" id="fnref8">8</a></sup></p>
</blockquote>
<p>Par ailleurs, Lévi-Strauss voit le bricoleur comme une sorte d’esthète, prenant plaisir dans la simple combinaison nouvelle qu’il réalise : le résultat obtenu demeure secondaire, et la satisfaction du succès éventuel n’est pas primordiale. Cette notion rejoint le domaine créatif dans lequel s’inscrit ce mémoire : ici, je parle également du designer en quête de forme, se laissant surprendre et inspirer par l’inconnu et l’inattendu.</p>
<h3 id="concevoir-ses-outils">Concevoir ses outils</h3>
<p>Le bricodeur est donc un praticien pour qui le code est un <em>matériau</em>, au même titre que le bois ou le métal pour un bricoleur. En manipulant ce matériau, il exerce une prise de recul consciente sur ses outils et sa propre pratique : une qualité également très sollicité chez les designers en général. Cette démarche permet de questionner ces mêmes outils, de les détourner, voire, en supposant que la variété des outils existants est parfois insuffisante – lorsque ceux-ci s’avèrent inadaptés à un objectif donné –, de concevoir ses propres outils. Cette philosophie peut être illustrée par la démarche de John Maeda. À la fois artiste, graphiste, enseignant et chercheur au MIT<sup class="footnote-ref"><a href="#fn9" id="fnref9">9</a></sup>, Maeda a acquis une renommée mondiale en tant que pionnier d’une discipline mêlant les arts plastiques, le design, la typographie et l’interactivité, avec pour moyens récurrents l’ordinateur et la programmation : il a particulièrement contribué au développement du <em>creative coding</em> avec la création de Design By Numbers<sup class="footnote-ref"><a href="#fn10" id="fnref10">10</a></sup>, qui donna naissance à Processing<sup class="footnote-ref"><a href="#fn11" id="fnref11">11</a></sup>. Ainsi, le cœur de la démarche de Maeda est de créer les dispositifs avec lesquels il produit ensuite des œuvres, notamment graphiques. Comme l’écrit Paola Antonelli dans la préface de l’ouvrage de Maeda “<em>Design By Numbers</em>”, “la partie la plus importante de sa production, et celle dont il est le plus fier, n’est pas l’objet final, mais plutôt le processus.” L’auteure italienne précise l’idée fondamentale de Maeda : <strong>"pour bien <em>designer</em> avec un ordinateur, il faut créer soi-même le programme que l’on utilise – ou à défaut, le comprendre."</strong><sup class="footnote-ref"><a href="#fn12" id="fnref12">12</a></sup></p>
<p>Parue en 2012, la dix-huitième édition de la publication “<em>Graphisme en France</em>”, intitulée “<em>code &lt;&gt; outils &lt;&gt; design</em>”, traite dans une série d’interviews de cette question spécifique de la création d’outils individuels.</p>
<blockquote>
<p>Nous avons posé deux questions […] :</p>
<ul>
<li>Pourquoi écrivez-vous vos logiciels plutôt que d’utiliser des outils existants ?</li>
<li>En quoi le fait d’écrire vos propres logiciels affecte-t-il votre processus de création et les qualités visuelles de l’œuvre finale ?</li>
</ul>
<p>[…] Réponse la plus courante : le fait d’écrire soi-même ses programmes permet un meilleur contrôle, lequel est souvent présenté comme une <em>liberté</em> individuelle. Autre thème récurrent : écrire ses logiciels est un moyen de s’éloigner des solutions <em>génériques</em>. Les nouveaux outils sont synonymes de nouvelles opportunités. […] En créant de tels outils, uniques, les créateurs s’ouvrent de nouveaux horizons.<sup class="footnote-ref"><a href="#fn13" id="fnref13">13</a></sup></p>
</blockquote>
<p>Quels sont donc les outils génériques qui constituent l’environnement technique du designer-codeur amateur, ou <em>bricodeur</em>, et quels sont les outils innovants ? Comment le créatif interagit-il avec ces interfaces numériques ? Quels sont les cadres conventionnels de l’écriture du code, et quels autres cadres alternatifs, peuvent exister ? Et pour quels bénéfices ? Telles sont les questions qui animent ce mémoire, qui s’inscrit dans la continuité des initiatives de Maeda et s’articule autour d’une question similaire : <strong>comment faciliter et encourager l’intégration de processus algorithmiques dans une pratique créative ?</strong></p>
<p>Par ailleurs, la définition du terme “algorithme” donnée plus haut implique la notion d’<em>instruction</em>, dont la définition est double : il s’agit à la fois de l’action de disposer – mettre quelque chose dans une disposition en vue d’un résultat –, et, dans un sens métonymique, d’un discours indiquant <em>ce qui doit être fait</em>. Cette seconde vision, qui fait état de la <em>transmission</em> d’une information, implique une forme de langage : celui-ci peut prendre plusieurs formes, notamment l’écriture. <strong>J’étudierai donc les différentes formes que peut prendre l’écriture algorithmique.</strong></p>
<p>Après avoir défini et illustré l’ensemble des notions mises en jeu par le sujet – algorithme et écriture algorithmique –, j’essaierai de déterminer quelle sont les différentes catégories d’interfaces d’écriture algorithmique et ce qu’elles permettent. Enfin, je m’appliquerai à questionner l’interface en soi, à travailler ce <em>matériau</em> que devient, dans cette conception, l’écriture algorithmique.</p>
<h1 id="le-matériau-algorithme">Le matériau algorithme</h1>
<p>Je reviens à la première phrase de ce mémoire : “un algorithme est une séquence d’instructions qui vise à être exécutée afin de produire un résultat”. Dans cette définition générique s’inscrit une catégorie plus réduite d’algorithmes spécifiques, un ensemble que l’on nomme <em>algorithmes symboliques</em>. Par abus de langage, et en raison de notre contexte technologique contemporain, la notion d’algorithmes symboliques a presque remplacé celle, plus générique, d’algorithmes : l’informatique a orienté l’emploi même du mot. <strong>La spécificité des algorithmes symboliques est qu’ils manipulent des symboles écrits : chiffres, lettres, assemblés en nombres, en mots et en phrases, et vecteurs de sens.</strong><sup class="footnote-ref"><a href="#fn14" id="fnref14">14</a></sup></p>
<p>Cette proximité entre les notions d’algorithmique et de mathématiques s’est confirmé grâce aux progrès techniques des deux siècles passés. Pour définir plus en détail la notion d’algorithme, j’ai donc choisi une approche chronologique : comment, et via quels progrès techniques, les algorithmes – symboliques – ont-ils évolué dans l’Histoire ? Cette question sera particulièrement traitée en focalisant sur les outils mis en œuvre au fil des époques.</p>
<h2 id="approche-technico-historique">Approche technico-historique</h2>
<h3 id="de-la-main-à-la-machine">De la main à la machine</h3>
<p>Remontons aux origines des algorithmes symboliques, il y a 5&nbsp;000 ans. À cette époque, les mathématiciens ont déjà mis au point des algorithmes servant à résoudre des calculs algébriques simples tels que des additions et des multiplications, mais ceux-ci sont exécutés à la main par les scribes. <strong>Des tâches répétitives qu’on aurait tout intérêt à déléguer aux machines, afin que celles-ci s’effectuent <em>mécaniquement</em>.</strong></p>
<p>S’ensuivent cinq millénaires d’innovations techniques. Les premiers abaques<sup class="footnote-ref"><a href="#fn15" id="fnref15">15</a></sup>, suivis quelques siècles plus tard de leurs proches dérivés, les bouliers, assistent les hommes dans ces calculs mais ne sont pas encore autonomes. Au Moyen Âge, les cloches au sommet des cathédrales sonnent chaque heure sans intervention humaine : ce sont les premières machines capables d’exécuter des algorithmes symboliques. En 1642, l’inventeur français Blaise Pascal<sup class="footnote-ref"><a href="#fn16" id="fnref16">16</a></sup> met au point la première machine à calculer, qu’il nomme “machine arithmétique” ; elle est retravaillée quelques 30 ans plus tard par Gottfried Leibniz<sup class="footnote-ref"><a href="#fn17" id="fnref17">17</a></sup> qui y ajoute une interface permettant de réaliser de façon automatique des multiplications et des divisions.</p>
<h3 id="jacquard-ou-le-tissage-programmé">Jacquard, ou le tissage programmé</h3>
<p>En 1801, l’inventeur lyonnais Joseph Jacquard met au point un système de métier à tisser qui portera son nom : le fameux “métier Jacquard”. Celui-ci combine les métiers à tisser classiques avec le principe de cartes perforées inventé en 1728 par Jean-Baptiste Falcon – qui lui-même reprenait l’idée des rubans perforés que Basile Bouchon, son maître, proposait trois ans plus tôt. En perçant ou non un trou à un emplacement spécifique d’une carte, on peut programmer la machine : une fois insérée en <em>entrée</em> de la machine,  les cartes guident les crochets qui soulèvent les “fils de chaînes” – dont l’agencement produit le motif sur le textile tissé. <strong>Ce dispositif est souvent considéré comme la première forme de stockage d’informations binaires (<em>tout</em> ou <em>rien</em>, <em>vrai</em> ou <em>faux</em>), et le métier Jacquard comme l’ancêtre de l’ordinateur.</strong></p>
<p>Ce procédé laborieux de perforation est peut-être une des raisons pour lesquelles certaines personnes non initiées s’imaginent qu’un “informaticien” code en tapant des séries de 0 et de 1. Il semble toutefois important de distinguer l’unité d’information <em>binaire</em> “un trou ou un plein” de celle qui constitue la base de l’informatique moderne : le <em>bit</em><sup class="footnote-ref"><a href="#fn18" id="fnref18">18</a></sup>. En effet, une nuance importante s’observe sur la dimension physique de ces deux types d’unités : le trou et le plein peuvent être vus, touchés, respectivement rebouché ou perforé : en bref, ils sont tangibles. Le bit informatique, lui, nous est invisible et impalpable – à notre échelle, “à l’œil”. Par ailleurs, un trou ou un plein, dans la conscience du tisserand, est interprété comme un résultat : il peut être visualisé comme la présence ou l’absence d’une maille à un endroit précis du motif. <strong>Dans le cas des cartes perforées, une parfaite connaissance et maîtrise du matériel est donc essentielle à la programmation.</strong> À l’inverse en informatique, le programmeur ne se soucie – généralement – pas du stockage et de la transmission de l’information binaire.</p>
<h3 id="la-machine-analytique-de-babbage">La machine analytique de Babbage</h3>
<p>Si le métier Jacquard est parfois considéré comme l’ancêtre de l’ordinateur, ces machines ne sont pas encore des ordinateurs à proprement parler. Il leur manque pour atteindre ce statut une caractéristique majeure : l’universalité. En effet,  les machines cités plus haut en exemples sont chacune destinée à une unique fonction ; là où un ordinateur est polyvalent, <em>universel</em>, capable d’exécuter n’importe quel algorithme symbolique imaginable : en résumé, une “machine à tout faire”.</p>
<p><strong>Au cours du XX<sup>ème</sup> siècle, l’apparition des premières <em>machines analytiques</em> va transformer les usages des algorithmes.</strong> En 1834, le visionnaire britannique Charles Babbage<sup class="footnote-ref"><a href="#fn19" id="fnref19">19</a></sup> débute le développement d’une machine d’un concept alors nouveau, qu’il qualifie de “machine analytique”. Celle-ci reprend le principe des machines à calculer mécaniques qui existent alors depuis plusieurs siècles déjà. Mais l’inventeur a l’idée d’ajouter à ces systèmes le principe des cartes perforées apparues avec les métiers Jacquard. Les composants de cette machine sont similaires à ceux qui équipent un ordinateur moderne.<sup class="footnote-ref"><a href="#fn20" id="fnref20">20</a></sup></p>
<p>Pendant qu’il travaille sur ce projet, Babbage entre en correspondance avec Ada Lovelace. Pionnière de la science informatique, c’est elle qui, en 1843, sera à l’origine du premier algorithme destiné à être exécuté sur une machine : la machine à différences de Charles Babbage. Cet algorithme, considéré comme le premier programme informatique à proprement parler, sert alors à calculer la suite des nombres de Bernouilli<sup class="footnote-ref"><a href="#fn21" id="fnref21">21</a></sup>. Ada Lovelace est ainsi connue comme la première programmeuse de l’histoire.</p>
<h3 id="la-révolution-turing">La révolution Turing</h3>
<p>Les travaux de Lovelace et Babbage trouvent écho un siècle plus tard, dans les années 1930, grâce notamment aux recherches d’Alan Turing<sup class="footnote-ref"><a href="#fn22" id="fnref22">22</a></sup>. Cet inventeur, figure emblématique de la recherche mathématico-scientifique du XX<sup>ème</sup> siècle, conçoit en 1936 la “machine de Turing”, en vue de donner une définition précise au concept d’algorithme et à sa représentation formelle et technique de “procédure mécanique”.</p>
<blockquote>
<p>[La machine de Turing] consiste en deux éléments principaux :</p>
<ol>
<li>une machine représentée par une tête de lecture/écriture susceptible de se trouver dans un nombre fini d’états,</li>
<li>une bande (magnétique par exemple) de longueur infinie […] devant laquelle se meut la tête de lecture et qui alimente en données cette machine. […]</li>
</ol>
<p>Turing montre qu’une partie de la bande peut contenir la description de la table d’actions élémentaires d’une autre machine de Turing : une machine peut en simuler une autre. C’est grâce à cette construction schématique […] que Turing peut démontrer qu’il existe des machines de Turing dites universelles capables d’imiter toute autre machine de Turing. <sup class="footnote-ref"><a href="#fn23" id="fnref23">23</a></sup></p>
</blockquote>
<p>Turing illustre ainsi la notion d’<em>universalité</em> telle qu’elle avait été formulée par Lovelace et Babbage. La machine de Turing universelle est considérée comme la genèse des travaux de John von Neumann, qui en 1945 propose un modèle utilisé encore aujourd’hui dans nos ordinateurs modernes : l’architecture de von Neumann<sup class="footnote-ref"><a href="#fn24" id="fnref24">24</a></sup>.</p>
<p><img src="img/neumann.png" alt="Architecture de von Neumann"></p>
<p>En transposant ces composantes dans notre vocabulaire matériel contemporain, on confirme la proximité entre ce modèle, vieux de plus de 70 ans, et les ordinateurs que nous utilisons au quotidien :</p>
<ul>
<li>le processeur effectue les opérations ;</li>
<li>la mémoire vive (<abbr title="Random Access Memory">RAM</abbr>) stocke les données en cours d’utilisation ; et les disques durs – ou autres supports de stockage – contiennent des données pérennes ;</li>
<li>les périphériques en tout genre permettent l’interaction en <em>entrée</em> (clavier, souris, écran tactile, microphone, caméra, port <abbr title="Universal Serial Bus">USB</abbr>, lecteur de disque, etc.) et en <em>sortie</em> (écran, haut-parleurs, etc.)</li>
</ul>
<p>Nous arrivons à ce stade à l’ordinateur tel que nous le connaissons, appareil nécessaire à la programmation algorithmique, capable d’exécuter des logiciels. <strong>On pourra donc considérer que l’ordinateur est la machine du programmeur, mais une machine universelle, capable de simuler elle-même un <em>environnement</em> d’outils – les logiciels de programmation.</strong> Ici, le programmeur maîtrise l’intégralité de le production d’un algorithme, indépendamment d’une connaissance plus ou moins parfait de ces outils. Toutefois, les progrès techniques les plus récents dérogent à cette règle : il s’agit des algorithmes relevant de l’intelligence artificielle.</p>
<h3 id="les-intelligences-artificielles">Les intelligences artificielles</h3>
<p><strong>Phénomène au cœur de l’actualité scientifique et sociale<sup class="footnote-ref"><a href="#fn25" id="fnref25">25</a></sup>, les “intelligences artificielles” sont constituées d’algorithmes dont la conception relève d’une divergence notable dans la façon de programmer.</strong> Le domaine de l’intelligence artificielle est extrêmement vaste et met en relation de nombreuses disciplines : informatique, mathématiques, psychologie, linguistique, philosophie, neurosciences, psychologie et bien d’autres encore. Pour cette raison, la question de l’intelligence artificielle ne sera pas traitée en détail ici. Toutefois, pour comprendre l’accroissement inédit de ce domaine au cours de la dernière décennie – et l’explosion médiatique qui en a suivi –, il est important de noter le décalage de notre contexte culturel et technique actuel, par rapport à celui en place aux débuts de la recherche en intelligence artificielle<sup class="footnote-ref"><a href="#fn26" id="fnref26">26</a></sup>. Celui-ci est notamment lié au phénomène des <em>big data</em> : nous sommes de plus en plus équipés de dispositifs connectés, et les plateformes numériques collectent ainsi de plus en plus de données sur nos comportements. C’est cette immense masse de données qui permet l’accomplissement de ces algorithmes nouveaux qui composent les intelligences artificielles.<sup class="footnote-ref"><a href="#fn27" id="fnref27">27</a></sup></p>
<p>On trouve dans le champ de l’intelligence artificielle la notion “d’apprentissage machine” (<em>machine learning</em> en anglais). Qu’il soit supervisé – assisté par un être humain qui valide ou non les propositions de la machine – ou non, ce principe permet à des algorithmes d’extraire et analyser des données afin d’y discerner des schémas, structures, ou tout autres éléments constitutifs de catégories. La notion d’apprentissage réside dans le fonctionnement en deux temps de ces programmes : ils doivent d’abord être entraînés avec des échantillons de données “labellisées”, c’est-à-dire accompagnées de l’information que le programme devra ensuite chercher à trouver dans d’autres données. Par exemple en proposant quelques dizaines de chiffres calligraphiés – chacun labellisé de 0 à 9 – à un algorithme de reconnaissance d’image, celui-ci “apprend” à quoi ressemble chaque chiffre – en distinguant des patterns dans leurs tracés – et sera capable d’en trouver avec une certitude plus ou moins grande dans d’autres images non labellisées à l’avenir.</p>
<p><img src="img/digit-recognition.png" alt="Système de reconnaissance de chiffres"></p>
<p>Parmi les systèmes et modèles propres à l’apprentissage machine, on trouve notamment les réseaux neuronaux<sup class="footnote-ref"><a href="#fn28" id="fnref28">28</a></sup>. Ceux-ci sont librement inspirés du fonctionnement des neurones biologiques, ceux qui composent le cerveau d’un être vivant – typiquement, des êtres humains.<sup class="footnote-ref"><a href="#fn29" id="fnref29">29</a></sup> <strong>Ce nouveau paradigme s’affranchit de la conception classique d’un algorithme, qui jusqu’alors était entièrement conçu par un programmeur : ici, la machine détermine elle-même les moyens et méthodes qu’elle met en jeu afin d’atteindre les objectifs spécifiés.</strong> Malgré leur incompréhension des symboles mêmes qu’ils manipulent, ces algorithmes conçoivent, modélisent, simulent et classifient ainsi les données d’une manière obscure pour l’auteur même du programme.</p>
<h2 id="approche-fondamentale">Approche fondamentale</h2>
<p>Les algorithmes se ressemblent : ils sont constitués d’un nombre restreint d’expressions structurantes similaires, que l’on retrouve fréquemment, agencées différemment selon la finalité recherchée. <strong>Selon Abiteboul et Dowek, n’importe quel algorithme symbolique peut être exprimé à partir de quatre instructions élémentaires : la séquence, l’affectation, l’itération et la condition.</strong><sup class="footnote-ref"><a href="#fn30" id="fnref30">30</a></sup></p>
<h3 id="séquence">Séquence</h3>
<p><img src="img/sequence.png" alt="Séquence"></p>
<p><strong>La <em>séquence</em> est l’ordre même dans lequel les instructions sont agencées, c’est-à-dire la structure de l’algorithme elle-même : “fait <em>ceci</em>, puis <em>cela</em>”.</strong> Lorsqu’il est représenté – c’est-à-dire écrit ou dessiné –, on lit classiquement un algorithme de haut en bas, conformément au sens de lecture de nombreux langages. On peut parfois s’émanciper, d’une certaine manière, de cette séquence, notamment en spécifiant expressément à l’algorithme d’éluder une partie des instructions dans certains cas précis. On groupe alors les instructions en ensembles – que l’on peut appeler des <em>fonctions</em> –, auxquels on peut ensuite faire référence. La “tête de lecture”, ou <em>positionnement</em> de l’algorithme à un moment donné de son exécution, ne déroule donc pas nécessairement la structure même cet algorithme de manière linéaire : elle peut effectuer des allers-retours, sauter des parties, y revenir, etc.</p>
<h3 id="affectation">Affectation</h3>
<p><img src="img/affectation.png" alt="affectation"></p>
<p><strong>L’affectation est le fait d’attribuer une valeur à une <em>variable</em> – par exemple, “<em>a</em> prend la valeur de <em>b</em>”.</strong> Une variable est constituée d’un nom (son identifiant) et d’une valeur unique à chaque instant. Cette valeur peut être numérique (un nombre entier ou décimal, naturel ou relatif), textuelle (un caractère ou une chaîne de caractères) ou encore un booléen : vrai (<em>true</em>) ou faux (<em>false</em>).<sup class="footnote-ref"><a href="#fn31" id="fnref31">31</a></sup> Une variable peut également accueillir un ensemble de données comme un tableau (<em>array</em> en anglais) indexé et/ou associatif. Comme son nom l’indique, une <em>variable</em> peut prendre plusieurs valeurs au cours du temps, à l’exception des constantes – dont la valeur est figée.</p>
<h3 id="itération">Itération</h3>
<p><img src="img/iteration.png" alt="Itération"></p>
<p><strong>L’itération, communément appelé <em>boucle</em>, est le fait de répéter une série d’instructions</strong>. Ce concept est fondamental, puisque les algorithmes ont généralement pour but d’automatiser des tâches répétitives. On trouve plusieurs types de boucles, en voici une liste non exhaustive :</p>
<ul>
<li>la boucle “pour” (<em>for loop</em> en anglais), qui exécute les instructions pour un nombre donné d’itérations : “répète 10 fois <em>ceci</em>” ;</li>
<li>la boucle “tant que” (<em>while</em> en anglais), qui exécute les instructions tant qu’un énoncé est valide : “tant que <em>ceci</em> est vrai, fait <em>cela</em>” ;</li>
<li>la boucle “pour chaque” (<em>for each</em> en anglais), qui exécute les instructions pour chaque entité d’une liste (des contacts dans un annuaire par exemple) : “<em>pour</em> chaque <em>ceci</em>, fait <em>cela</em>”.</li>
</ul>
<h3 id="condition">Condition</h3>
<p><img src="img/condition.png" alt="Condition"></p>
<p><strong>Enfin, la condition, ou <em>test conditionnel</em>, permet d’effectuer ou non une instruction – ou série d’instructions – selon la valeur d’une variable donnée : par exemple, “si <em>ceci</em> est vrai, faire <em>cela</em>”.</strong> On appelle généralement <em>expression conditionnelle</em> le schéma “si, alors, sinon” (<em>if, then, else</em>). De plus, on trouve parfois dans ces structures un nombre plus ou moins important d’expressions du type <em>sinon si</em> (<em>else if</em>), qui permettent des conditions imbriquées. Ici encore, cette notion est extrêmement importante, en cela qu’elle permet à un algorithme de prendre des chemins différents, de s’adapter à la complexité éclectique des données réelles qui lui sont fournies, et ainsi d’être plus polyvalent. À noter qu’on peut faire prendre des chemins différents à un algorithme en prenant comme conditions des valeurs générées aléatoirement : “choisis un nombre entre 1 et 10, s’il est supérieur à 5, fais <em>ceci</em>, sinon, fais <em>cela</em>”.</p>
<h1 id="manipuler-le-matériau--lécriture-algorithmique">Manipuler le matériau : l’écriture algorithmique</h1>
<p>Afin d’être exécutés par une machine, les algorithmes doivent être transposés de l’intelligence du programmeur vers un support pérenne et interprétable par cette machine. <strong>Parce que les ordinateurs ont été conçus pour manipuler des symboles, la méthode de communication qui s’est naturellement imposée est l’écriture.</strong> Programmer, vu de <em>l’extérieur</em>, c’est avant tout taper une succession de lettres et de chiffres sur un clavier. Dans cette partie, je m’intéresse donc à cette action d’écriture, mais également aux notions qu’elle implique, notamment l’emploi d’un <em>langage</em>.</p>
<h2 id="quest-ce-quécrire-">Qu’est-ce qu’écrire ?</h2>
<h3 id="écriture--le-langage-imagé">Écriture : le langage imagé</h3>
<p>L’écriture est une méthode de communication qui consiste à représenter un langage via l’inscription de signes graphiques sur des supports variés. En cela, elle est une forme d’inscription, tel que le terme est défini par Bruno Bachimont : “l’association d’un substrat matériel à une forme d’expression”. L’écriture est née quatre millénaires avant notre ère, en Mésopotamie, afin de conserver des traces d’échanges – notamment commerciaux –, la mémoire humaine n’étant pas infaillible et encore moins illimitée. Le philosophe François Dagognet nous rappelle l’adage latin : “<em>Verba volant, scripta manent</em>” – les paroles s’envolent, les écrits restent.<sup class="footnote-ref"><a href="#fn32" id="fnref32">32</a></sup> Mais Dagognet souligne aussi que dans ce transfert de la parole à l’écrit, le discours n’est pas forcément transcrit scrupuleusement, mais peut au contraire subir des modifications.</p>
<blockquote>
<p>De ce que le vocalisé s’insinue dans le texte et aide à le comprendre, il ne s’ensuit pas que l’imprimé ne le dépasse pas. Si le graphisme ne supprime pas entièrement le gestuel, il l’amoindrit, tend à l’éloigner, voire à l’enjamber. <sup class="footnote-ref"><a href="#fn33" id="fnref33">33</a></sup></p>
</blockquote>
<p>En résumant sa pensée, je retiendrai ceci : si l’écriture découle de la parole comme une nouvelle forme d’échange communicationnel, elle n’en est pas une forme strictement identique. Un énoncé vocal ne transmet pas seulement la nature de l’énoncé, mais également sa forme – la tonalité, la prononciation, l’attitude –, au même titre que la représentation graphique joue sur des variations de représentation – graphie, tracé, composition, contraste – pour véhiculer une information qui enrichit le contenu même de l’écrit.</p>
<p>Ce propos rejoint la thèse d’Anne-Marie Christin, professeure spécialiste de l’écriture et des relations entre texte et image. Selon elle, l’écriture ne reproduit pas la parole, mais la rend visible : <strong>elle est le résultat de la fusion entre le langage, qui régit les échanges à l’intérieur d’un groupe, et l’image, composée de figures et de supports.</strong><sup class="footnote-ref"><a href="#fn34" id="fnref34">34</a></sup></p>
<p>L’écriture présuppose donc un emploi du langage. Selon le <abbr title="Trésor de la Langue Française informatisé">TLFi</abbr>, le terme <em>langage</em> implique une définition multiple, selon que l’on parle du langage comme faculté et comme système, ou bien comme moyen d’expression, comme usage. Un langage est généralement doté d’une sémantique, et fréquemment d’une syntaxe – deux branches de la linguistique symétriquement opposées. La sémantique étudie les <em>signifiés</em> : ce dont on parle, ce que l’on cherche à transmettre – en résumé, le <em>fond</em> de l’énoncé. La syntaxe, pour sa part, se concentre sur le <em>signifiant</em> : la langue, la représentation graphique, la grammaire employée, etc. – en résumé, la <em>forme</em> de l’énoncé. <sup class="footnote-ref"><a href="#fn35" id="fnref35">35</a></sup></p>
<h3 id="écritures--3-typologies">Écritures : 3 typologies</h3>
<p>La notion d’écrit, au sens large, désigne donc les diverses formes que peuvent prendre la traduction graphique de l’information communiquée : dessins, symboles, chiffres, lettres, etc. Toutefois, le sens généralement admis du terme <em>écrit</em> désigne trois grandes catégories de systèmes : logographique, syllabique et alphabétique.</p>
<ul>
<li>l’écriture logographique emploie des <em>logogrammes</em>, caractères – ou <em>glyphes</em> – représentant un mot ou un <em>morphème</em> – une fraction de mot. Plus précisément, on parle d’un <em>pictogramme</em> lorsqu’on représente directement un objet (par exemple, le blé), et d’un idéogramme lorsqu’on cherche à symboliser une idée (par exemple, la vitalité).</li>
<li>l’écriture syllabique emploie un <em>syllabaire</em>, composés de symboles exprimant chacun une syllabe. Les différentes formes d’écritures chinoises et japonaises en sont les exemples les plus courants.</li>
<li>enfin, l’écriture alphabétique est celle que nous connaissons le mieux, pour l’utiliser quotidiennement. Elle utilise un ensemble de symboles, dont chacun représente un phonème – plus petite entité linguistique –, composés de manière à former des mots. Une trentaine de signes alphabétiques suffisent généralement à écrire une langue. <sup class="footnote-ref"><a href="#fn36" id="fnref36">36</a></sup></li>
</ul>
<p><ins>L’écriture algorithmique appartient classiquement à cette troisième catégorie : quelle forme prendrait la programmation si l’on changeait de catégorie, en préférant par exemple une écriture logographique ? Je propose une première réponse à cette question avec une expérimentation intitulée “<em>emoji2code</em>”, permettant de coder à partir d’un enchaînement d’emoji. Ici, l’écriture n’est pas <em>classique</em> – on ne tape pas sur les touches du clavier pour former des mots et des phrases –, il est d’avantage question de composition : il suffit de cliquer sur un emoji pour le voir apparaître dans la zone de saisie. Chaque emoji correspond à une instruction (par exemple “boucler”, “écrire dans la console”) ou un élément (une variable, une opération mathématique). Dans l’exemple ci-dessous, je réalise simplement une boucle permettant de compter de 0 à 9.<img src="img/emoji2code.png" alt="emoji2code, une interface d'écriture algorithmique à l'aide d'emoji"><br>
</ins></p>
<h3 id="lécriture-émancipée">L’écriture émancipée</h3>
<p>La pratique de l’écriture se place comme acte fondateur de la littérature. Par “littérature”, j’entends la conception de l’écriture comme une forme d’art. Cet art recouvre de nombreux genres et styles : genre pictural, genre narratif, genre dramatique, contenu, ou encore registre. <sup class="footnote-ref"><a href="#fn37" id="fnref37">37</a></sup></p>
<p>Nul besoin de traiter en détail les formes d’écritures que nous connaissons le mieux : page par page, alignant des mots dans un alphabet latin, de la gauche vers la droite et du haut vers le bas. <strong>Pour questionner le potentiel créatif de la pratique de l’écriture, je m’intéresse plus particulièrement à ses représentations moins classiques.</strong> Pour Anne-Marie Christin, l’exemple le plus pertinent qui a libéré l’écriture occidentale est une œuvre de Stéphane Mallarmé, poète français du XIX<sup>ème</sup>siècle. On le décrit aujourd’hui comme un des premiers “poèmes typographiques”.</p>
<blockquote>
<p>Tout a changé dans la pensée occidentale de l’écrit avec le <em>Coup de Dés</em> de Mallarmé. Pour la première fois de leur histoire, les héritiers de l’alphabet que nous sommes ont pris conscience du fait qu’ils ne disposaient pas simplement, avec ces quelques signes, d’un moyen plus ou moins commode de transcrire graphiquement leur parole mais d’un instrument complexe, double, auquel il suffisait de réintégrer la part visuelle – spatiale – dont il avait été privé pour lui restituer sa plénitude active d’écriture.<sup class="footnote-ref"><a href="#fn38" id="fnref38">38</a></sup></p>
</blockquote>
<p><img src="img/mallarme.png" alt="Extrait du &quot;Coup de Dés&quot; de Mallarmé"></p>
<p>Dans la même idée de mise en espace des lettres, le poète français Guillaume Apollinaire publie en 1918 un ouvrage intitulé “<em>Calligrammes</em>”, terme qu’il invente à partir de la contraction de <em>calligraphie</em> – l’art graphique du dessin de caractères – et d’<em>idéogramme</em>. Cette forme particulière de poésie est parfois nommée “poésie graphique”.</p>
<p><img src="img/calligramme-apollinaire.png" alt="Calligramme &quot;Il Pleut&quot; d'Apollinaire"></p>
<p>On notera que François Dagognet classe le travail d’Apollinaire dans une catégorie qu’il intitule “<em>iconographies ordinatrices et inventives</em>”. Celle-ci est constitué de productions graphiques et littéraires qui font usage de <em>métaboles</em>, qu’il emprunte au groupe µ<sup class="footnote-ref"><a href="#fn39" id="fnref39">39</a></sup> dans son ouvrage “<em>Réthorique Générale</em>” : un métabole désigne tout espèce de changement du langage.<sup class="footnote-ref"><a href="#fn40" id="fnref40">40</a></sup> Comme dans beaucoup de pratiques créatives, la nouveauté passe donc par le changement, l’émancipation des artistes vis-à-vis des formes ordinaires, au profit de formes nouvelles, alternatives.</p>
<p><ins><strong>En reportant ces distinctions au champ des algorithmes, on pourrait facilement s’interroger sur la forme que pourrait prendre une “écriture alternative” d’un algorithme, comme par exemple une écriture <em>poétique</em>.</strong> Le livre “<em>./code --poetry</em>” de Daniel Holden et Chris Kerr, ainsi que le site web associé<sup class="footnote-ref"><a href="#fn41" id="fnref41">41</a></sup>, présentent des exemples de programmes s’affranchissant des conventions habituelles (voir la partie “<a href="#lignes-de-code-r%C3%A8gles-et-conventions"><em>Lignes de code, règles et conventions</em></a>”) et dont le résultat est essentiellement esthétique : en résumé, du “code poétique” qui ouvre la voie à une <em>littérature algorithmique</em>. Le projet <a href="https://monoskop.org/images/5/55/Code_Poems_2012.pdf"><em>Code Peoms</em></a> du designer Ishac Bertran regroupe par exemple une série de poèmes dont la syntaxe et le vocabulaire sont empruntés au langages de programmation. Les œuvres tirées du projet “<em>./code --poetry</em>” s’inscrivent pour leur part dans un registre plus graphique, et qui traite encore davantage le code comme matière : on peut notamment citer <a href="http://code-poetry.com/flocking"><em>Flocking.go</em></a>, un programme dans le langage Go, mêlant poésies classique et algorithmique, pour un résultat animé qui fait écho avec la sémantique du texte.<br>
<img src="img/code-poetry.png" alt="Flocking.go, un programme poétique animé dans le langage Go"><br>
</ins></p>
<h2 id="lécriture-algorithmique">L’écriture algorithmique</h2>
<p>Attardons-nous davantage sur la spécificité de l’écriture dans le cas d’un programme informatique : <strong>quelle différence y a-t-il entre l’action de coder et la rédaction d’une article ou d’un poème ?</strong> On notera tout d’abord que dans ce contexte informatique, les algorithmes prennent la forme de programmes, rédigés dans un langage de programmation spécifique, grâce à un ordinateur. Toutefois, <em>algorithme</em> et <em>programme</em> sont deux notions différentes bien qu’étroitement liées, tout comme <em>informatique</em> et <em>ordinateur</em> : il convient donc de les clarifier.</p>
<h3 id="de-lalgorithme-au-programme">De l’algorithme au programme</h3>
<p>Un programme informatique est une suite d’instructions qui effectue une ou plusieurs tâches spécifiques lorsqu’elle est exécutée par un ordinateur.<sup class="footnote-ref"><a href="#fn42" id="fnref42">42</a></sup> L’universitaire français Franck Varenne attire notre attention sur une possible origine de la confusion entre algorithmes et programmes. Il cite Charles Hoare, professeur et informaticien britannique, également connu pour la conception de nombreux algorithmes encore utilisés aujourd’hui. Hoare déclare que “la programmation informatique est une science exacte en ce que toutes les propriétés d’un programme […] peuvent être découvertes à partir du texte du programme lui-même au moyen de raisonnement purement déductif.” Varenne y oppose l’argumentation de James Fetzer, philosophe américain spécialisé notamment en informatique : la vision de Hoare amène à confondre les algorithmes et les programmes. Selon Varenne, rien n’implique une exacte similitude entre le comportement supposé du programme – à la lecture donc – et les conséquences réelles de son exécution sur la machine.</p>
<blockquote>
<p>Les algorithmes sont des solutions formelles (abstraites en ce sens) et effectives pour certains problèmes bien formulés. Les programmes chargés en mémoire (exécutables) sont en revanche des modèles causaux (car physiques) de ces algorithmes. Alors que les algorithmes sont des modèles abstraits des programmes exécutables, les programmes exécutables sont des modèles causaux des algorithmes.<sup class="footnote-ref"><a href="#fn43" id="fnref43">43</a></sup></p>
</blockquote>
<p>Varenne qualifie donc ces modèles d’<em>imparfaits</em> : le programme ne peut jamais être vérifié formellement, mais seulement de façon empirique. En effet, on peut établir la validité d’un programme, notamment en développant une sémantique qui régule le <em>code</em> écrit par le programmeur. On résout alors les erreurs de programmation : variables sans valeur définie, fautes de syntaxe, structure erronée ou illogique, etc. Toutefois, la machine peut elle-même faire preuve de dysfonctionnement du fait même de sa dimension physique : processeur défectueux, espace de stockage corrompu, mémoire vive saturée, etc.</p>
<p>Cette marge d’incertitude entre le programme que l’on voit et ce que l’on obtient lorsqu’il est exécuté a été baptisée WYSINWYX, pour <em>What You See Is Not What You eXecute</em> – littéralement “ce que vous voyez n’est pas ce que vous exécutez”.<sup class="footnote-ref"><a href="#fn44" id="fnref44">44</a></sup> Cet acronyme est une référence au paronyme duquel il est inspiré : le terme WYSIWYG —<em>What You See Is What You Get</em>, soit “ce que vous voyez est ce que vous obtenez” – désigne, en informatique, les interfaces utilisateurs où l’on compose directement le résultat final souhaité.<sup class="footnote-ref"><a href="#fn45" id="fnref45">45</a></sup></p>
<h3 id="de-lordinateur-à-linformatique">De l’ordinateur à l’informatique</h3>
<p>La définition du terme “ordinateur”, dans son sens admis populairement, se base sur les travaux d’Alan Turing.</p>
<blockquote>
<p>Un ordinateur est un système de traitement de l’information programmable tel que défini par Turing et qui fonctionne par la lecture séquentielle d’un ensemble d’instructions, organisées en programmes, qui lui font exécuter des opérations logiques et arithmétiques.</p>
</blockquote>
<p>Les composants technologiques des ordinateurs modernes traitent des informations <em>binaires</em>. Là où les cartes perforées de Falcon utilisaient des trous ou des pleins pour signifier un des deux états uniques qui composent un <em>bit</em>, nos ordinateurs, dont le fonctionnement est basé sur l’électricité, utilisent pour signifier une valeur la présence ou l’absence de courant, de charge ou de tension électrique – suivant qu’il soit question de stocker ou de transmettre une donnée.</p>
<p>Les racines mathématiques de l’<em>ordinateur</em> se retrouvent dans l’étymologie même du terme. En 1955, Fançois Girard, responsable du service publicité d’<abbr title="International Business Machines">IBM</abbr> France, fait appel à son ancien professeur de lettres, Jacques Perret, afin de trouver ensemble une traduction au mot anglais “computer”. Perret propose alors l’appellation “ordinatrice électronique”, inspirée de l’<em>ordonnateur</em>, ce composant de la machine décrit par Babbage comme celui qui “prend et reporte les nombres, et les soumet à l’opération demandée”. L’intitulé est ensuite simplifié en <em>ordinateur</em> et entre rapidement dans le langage populaire.</p>
<p>La notion d’informatique est intimement liée à l’univers des ordinateurs. Si en anglais, ordinateur se dit “computer”, la notion d’informatique est tout simplement désignée par la formule “computer science”. Certains penseurs affirment toutefois que l’on ne peut pas définir l’informatique comme “la science des ordinateurs”. On attribue notamment à Edsger Dijkstra, informaticien néerlandais reconnu, l’aphorisme suivant : <strong>“L’informatique n’est pas plus la science des ordinateurs que l’astronomie n’est celle des télescopes.”</strong> Les auteurs de cette phrase sont en réalité Michael Fellows et Ian Perberry, et la citation complète – traduite – est la suivante :</p>
<blockquote>
<p>L’informatique n’est pas plus la science des ordinateurs que l’astronomie n’est celle des télescopes, la biologie celle des microscopes, ou la chimie celle des <em>béchers</em> et des tubes à essais. La science ne traite pas des outils. Elle traite de notre manière de les utiliser, et de ce que l’on découvre en les utilisant. <sup class="footnote-ref"><a href="#fn46" id="fnref46">46</a></sup></p>
</blockquote>
<p>Dans “<em>Qu’est-ce que l’informatique ?</em>”, Franck Varenne propose et critique de nombreuses ébauches définitionnelles – c’est là le cœur de l’ouvrage – avant de conclure par la description suivante :</p>
<blockquote>
<p>[L’informatique est] une technologie (dans son caractère instumental et de délégation opératoire) et une discipline (dans ses versants cognitifs et réthoriques) de démultiplication, d’entrelacement, d’application […] et/ou de confrontation des voies de la référence. Plus brièvement : elle est une technologie d’entrecroisement automatique et programmable des voies de la référence. <sup class="footnote-ref"><a href="#fn47" id="fnref47">47</a></sup></p>
</blockquote>
<p>Varenne nomme “voies de la référence” la faculté des <em>symboles</em> utilisés en informatique (nombres, lettres, signes, etc.) à faire référence à un ou plusieurs autres symboles. En ce qui concerne le calcul numérique, les <em>voies</em> sont au nombre de deux : la <em>concrétisation</em> ou l’<em>abstraction</em>. <strong>Si elle en est fondamentalement inspirée, l’informatique va au-delà du calcul et joue sur les niveaux de symboles mis en œuvre : les symboles sont hybridés via des procédés de sous-symbolisation et de simulation.</strong> On pourrait illustrer cette distinction par un phénomène de “couches” superposées, où chacune est une symbolisation de celle sur laquelle elle s’appuie : cette superposition constitue ainsi une forme de <em>simulation</em> récursive, chaque strate jouant le rôle de la précédente sous une autre forme.</p>
<p><img src="img/couches.png" alt="Schéma de la simulation récursive"></p>
<h3 id="langages-naturels-et-langages-formels">Langages naturels et langages formels</h3>
<p><strong>En linguistique, on appelle “langage naturel” un langage qui a évolué naturellement au travers de l’utilisation humaine et de sa répétition</strong>, sans planification particulière ou préméditation consciente de la part du peuple qui l’utilise – comme le français ou l’anglais par exemple. <strong>On y oppose la notion de “langage formel”, parfois également appelé “langage construit” ou encore “langage artificiel”.</strong> À l’inverse, il s’agit ici d’un langage créé de toutes pièces dans un temps relativement court, par une population bien plus restreinte – éventuellement l’œuvre d’un seul auteur. On peut distinguer trois catégories parmi ces langages construits :</p>
<ul>
<li>les langages conçus ou <em>engelangs</em> (de l’anglais <em>engineered</em>), à nouveau divisés en langages logiques (par exemple les langages de programmation informatique), philosophiques ou expérimentaux  ;</li>
<li>les langages auxiliaires ou <em>auxlangs</em>, créés pour la communication internationale – un des plus célèbres étant l’Esperanto ;</li>
<li>les langages artistiques ou <em>artlangs</em>, comme ceux inhérents à une œuvre de science-fiction ou de fantaisie – par exemple les langues créées par l’auteur J.R.R. Tolkien.</li>
</ul>
<p>Le terme de langage <em>formel</em> fait davantage référence au champ des mathématiques et de l’informatique : <strong>cette notion intègre à la fois l’ensemble des séquences de caractères et des symboles qui sont employés et les différentes règles qui déterminent leurs usages</strong>. C’est donc celle à laquelle je m’intéresse en particulier dans la suite de cet exposé, centrée sur les langages informatiques.</p>
<p><ins>En m’interrogeant sur la dualité entre langage naturel et langage formel dans notre manière de communiquer à la machine – notamment des instructions –, je propose la question suivante : <strong>ne peut-on pas utiliser d’autres formes de langages qu’un langage de programmation ?</strong> J’ai entamé une proposition de réponse grâce à une interface intitulée <em>text2code</em><sup class="footnote-ref"><a href="#fn48" id="fnref48">48</a></sup>, qui permet de “coder” en langage naturel, c’est-à-dire en écrivant de l’anglais intelligible par tous – ce qui implique une traduction “cachée” en langage JavaScript, exécutable par un navigateur.<br>
<img src="img/text2code.png" alt="text2code, une interface d'écriture algorithmique en langage naturel"></ins></p>
<h3 id="langages-informatiques">Langages informatiques</h3>
<p>Il existe une grande variété de langages de programmation, comme en témoigne la liste établie sur Wikipédia<sup class="footnote-ref"><a href="#fn49" id="fnref49">49</a></sup>. <strong>Tous possèdent des règles de syntaxe, un vocabulaire, une sémantique, un vocabulaire et des identifiants qui leurs sont propres</strong> – mais ils partagent également de nombreux poins communs. À la vue de cette liste de plus de 600 langages référencés, on peut se poser la question suivante : pourquoi y a-t-il autant de langages de programmation ? Sur le site communautaire de programmation StackOverflow<sup class="footnote-ref"><a href="#fn50" id="fnref50">50</a></sup>, l’ingénieur Matt Sherman propose dans un article<sup class="footnote-ref"><a href="#fn51" id="fnref51">51</a></sup> plusieurs éléments de réponse :</p>
<ul>
<li>les différents langages sont autant d’outils, chacun plus ou moins adapté à des usages précis – il s’agit de choisir pour chaque finalité le langage qui sera le plus efficace, sûr et rapide à manier.</li>
<li>les programmeurs ont des goûts personnels – et des compétences qui leurs sont propres. Tel ou tel langage est souvent choisi en fonction des connaissances de l’équipe de programmation sur celui-ci.</li>
<li>la variété des langages de programmation est ainsi riche, en ce qu’elle permet plus de flexibilité en fonction des tâches à accomplir et des personnes qui vont employer ces langages.</li>
</ul>
<p>Il faut aussi prendre en compte la faculté qu’ont les langages à disparaître – tels des langues mortes –, et le fait que certains ne soient que très peu utilisés, car trop spécifiques, de niche, ou tout simplement conçus pour le divertissement plutôt que dans l’optique d’une application logicielle concrète. Par ailleurs, on peut catégoriser les langages de programmation en paradigmes<sup class="footnote-ref"><a href="#fn52" id="fnref52">52</a></sup> de programmation. En résumé, un paradigme désigne la façon que le programmeur a d’envisager la structure et le fonctionnement du programme.</p>
<p><img src="img/js-code.png" alt="Un exemple d'algorithme en JavaScript"></p>
<p>Je m’attarde un instant sur un type de langages qui me semble se démarquer des langages de programmation “classiques”, les plus populaires de nos jours étant JavaScript – dont un exemple est donné ci-dessus –, Python, Ruby, Java, PHP ou encore C++ – d’après une étude<sup class="footnote-ref"><a href="#fn53" id="fnref53">53</a></sup> menée par la plateforme de développement collaboratif GitHub<sup class="footnote-ref"><a href="#fn54" id="fnref54">54</a></sup>. Il s’agit d’une façon de décrire un algorithme dans un langage naturel, sans faire référence à un langage de programmation particulier : on l’appelle le <em>pseudo-code</em>. <strong>Sans réelle règle ou convention établie, l’écriture en pseudo-code permet de mesurer la difficulté de la conception d’un algorithme</strong>, et ainsi d’anticiper une structure flexible et adaptée au développement réel qui a lieu dans un second temps : ici, un exemple de pseudo-code décrivant un algorithme de résolution du problème <a href="http://wiki.c2.com/?FizzBuzzTest"><em>FizzBuzz</em></a>.</p>
<p><img src="img/pseudo-code.png" alt="Un exemple de pseudo-code"></p>
<p>Les points communs entre ces langages se trouvent dans l’exercice de leur écriture : quels sont-ils ? Qu’est-ce, finalement, que le code, et comment est-il régi ?</p>
<h3 id="lignes-de-code-règles-et-conventions">Lignes de code, règles et conventions</h3>
<p><strong>Le code, tel que le définit l’archéologue et linguiste Clarisse Herrenschmidt, est "un moyen de chiffrer, propre à la machine qui crypte et décrypte."</strong><sup class="footnote-ref"><a href="#fn55" id="fnref55">55</a></sup> C’est la forme de programmation la plus classique : la quasi-intégralité des produits numériques, logiciels et autres applications que nous utilisons aujourd’hui ont été écrits, ligne par ligne, symbole par symbole. Les langages de programmation emploient une syntaxe – un ensemble de contraintes qui régissent la combinaison des symboles – qu’il convient de respecter pour assurer la bonne exécution du programme. Sinon, le compilateur rencontrera une anormalité et le “<em>débugger</em>” (ou la “console”) va afficher un message d’erreur. Le respect des règles imposé par un langage de programmation assure que celui-ci pourra être décrypté par la machine, et ainsi exécuté : le code est dit “valide”.</p>
<p>Outre la dimension fonctionnelle, un programmeur se doit de respecter un certain nombre de conventions afin d’être compris par d’éventuels autres programmeurs qui viendraient à lire ce code : <strong>la question n’est plus seulement “ce code est-il lisible par la machine ?”, mais “ce code est-il lisible par un humain ?”</strong>. On intègre alors à son écriture des principes visuels, de composition, ou encore de choix sémantiques. Un certain nombre de principes graphiques sont utilisés. Par exemple, l’<em>indentation</em> consiste à ajouter des espaces – ou des <em>tabulations</em> – en début de chaque ligne de code de façon à structurer visuellement l’ensemble du programme. <sup class="footnote-ref"><a href="#fn56" id="fnref56">56</a></sup> Dans certains des langages, les espaces vides sont ignorés lors de l’interprétation par la machine, ils sont donc utilisés selon la convenance pour faciliter la lecture. À l’inverse, dans d’autres langages – comme le Python –, cette structuration est essentielle car elle définit le fonctionnement même du programme, il n’est donc pas ici question uniquement de style ou de clarté. Un autre principe graphique employé pour la lisibilité : la coloration syntaxique (ou <em>syntax highlighting</em> en anglais), qui formate automatiquement les éléments du texte – notamment par le changement de couleur mais parfois aussi de typographie – afin d’en simplifier la lecture. Ce système répond d’ailleurs à un problème énoncé par Franck Varenne, faisant lui-même référence au philosophe Gilles Gaston Granger : “des symboles qui peuvent être écrits côte à côte dénotent des types d’entités différents”.<sup class="footnote-ref"><a href="#fn57" id="fnref57">57</a></sup></p>
<p>Voici d’autres exemples de conventions courantes :</p>
<ul>
<li>les commentaires, exprimés en langage naturel (souvent en anglais), non prise en compte dans l’exécution du script : ils servent à clarifier le fonctionnement du programme à un endroit précis auprès de potentiels futurs lecteurs ;</li>
<li>l’indentation, comme expliqué plus haut, dont on définit les points de retours à la ligne ou le nombre d’espaces ;</li>
<li>la longueur des lignes, pour garantir l’affichage complet en largeur du code au sein d’un éditeur de texte ;</li>
<li>le nommage des variables, notamment sur la façon de <em>concaténer</em> – mettre bout à bout plusieurs chaînes de caractères – des intitulés. On parle notamment de <em>casse</em>, c’est-à-dire de l’usage des lettres capitales pour assurer la lisibilité d’un mot-valise<sup class="footnote-ref"><a href="#fn58" id="fnref58">58</a></sup> ;</li>
<li>et d’autres encore, liées au “bonnes pratiques” et principes divers qui permettent l’intelligibilité, l’efficacité, la flexibilité ou encore la sécurité d’un programme.</li>
</ul>
<pre class=" language-javascript"><code class="prism  language-javascript"><span class="token comment">/* Ceci est un exemple de programme simple dans le langage JavaScript. Ces deux phrases sont des commentaires, elles ne sont pas prises en compte dans l'exécution du script. */</span>

<span class="token keyword">var</span> text <span class="token operator">=</span> <span class="token string">"Hello world!"</span><span class="token punctuation">;</span>
<span class="token comment">/* Ici, on attribue une valeur (dans ce cas une chaîne de caractères) à une variable nommée "text". */</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* Cette fonction permet d'afficher une variable dans la console (par exemple celle d'un navigateur web). */</span>
</code></pre>
<h2 id="outils-décriture-algorithmique">Outils d’écriture algorithmique</h2>
<p>Il existe différents outils employés dans les processus de conception algorithmique. Ceux-ci présentent des points communs et des différences, et tous conditionnent le travail de programmation d’une manière qui leur est propre. Quelles sont ces outils, ces interfaces, et quel est leur impact sur la pratique de l’usager ?</p>
<h3 id="ide-et-éditeurs-de-texte">IDE et éditeurs de texte</h3>
<p>On parle “d’environnement de développement” ou d’<abbr title="Integrated development environment">IDE</abbr> pour désigner l’ensemble des outils employés par un programmeur pour développer un programme informatique. Un IDE est généralement un logiciel dont l’interface propose un ensemble d’outils et de fonctions : le plus généralement, on trouve un éditeur de texte où le programmeur saisit des lignes de codes. Celui-ci est généralement accompagné d’un débugger – pour débusquer et corriger les <em>bugs</em> – ou encore, si le langage l’implique, d’un compilateur – utilisé pour “traduire” le langage de programmation en <em>langage machine</em>, c’est-à-dire en instructions exécutables par l’ordinateur. Le choix de tel ou tel logiciel de programmation – de tel ou tel environnement – dépend généralement du langage utilisé dans le cadre d’un projet, ainsi que des goûts personnels du développeur. Certains outils, ayant une communauté plus active, se développent particulièrement grâce à la contribution collective – lorsque le logiciel est <em>open-source</em> – tandis que d’autres tombent en désuétude, les années passant et les technologies évoluant en conséquence.</p>
<p>La définition stricte d’IDE désigne donc ces outils composés, multiples, et les oppose aux simples “éditeurs de texte”. Un éditeur de texte – <em>text editor</em> en anglais – est un programme permettant l’écriture ou la modification de texte <em>brut</em>, c’est-à-dire dénué de mise en forme : ces logiciels utilisent souvent une typographie monochasse, permettant l’alignement vertical des caractères et favorisant ainsi la lisibilité du code. Les fonctions les plus courantes sont le copier/coller, la recherche et remplacement, la coloration syntaxique, etc. Par abus de langage, ces éditeurs de texte sont généralement inclus dans la définition au sens large d’IDE, à juste titre : ils font bel et bien partie de l’environnement de développement du programmeur.</p>
<p><img src="img/atom-ide.png" alt="Capture d'écran du logiciel de programmation Atom"></p>
<h3 id="programmation-visuelle">Programmation visuelle</h3>
<p><strong>La programmation peut également prendre une forme graphique, visuelle. C’est le cas notamment des représentations algorithmiques en diagrammes, aussi appelées <em>algorigrammes</em> – ou <em>flowcharts</em> en anglais.</strong> Les instructions sont divisées dans autant de formes géométriques normalisés – un rectangle pour une opération, un losange pour un test, etc. – qui sont ensuite reliées entres elles pour symboliser l’enchaînement des instructions. Apparue il y a un siècle dans le domaine de l’ingénierie industrielle, cette représentation est utilisée dans certains logiciels de programmation comme Flowgorithm, qui est un intermédiaire entre la conception algorithmique visuelle et la programmation textuelle : le diagramme créé par l’utilisateur peut être traduit en un des langages de programmation les plus courants. Cette catégorie d’outils est notamment utilisée dans l’éducation, auprès de novices, afin de leur faire assimiler sans introduire les langages de programmation comme difficulté supplémentaire.</p>
<p><img src="img/flowgorithm.png" alt="Capture d'écran du logiciel Flowgorithm"><em>Capture d’écran du logiciel Flowgorithm</em></p>
<p><strong>La programmation visuelle peut aussi s’affranchir de la représentation normalisée d’un algorigramme.</strong> L’exemple le plus connu est le logiciel Scratch, développé par le <abbr title="Massachusetts Institute of Technology">MIT</abbr> depuis une quinzaine d’années. Scratch propose de voir la programmation algorithmique comme un jeu de puzzle, constitué de “blocs” représentant chacun un type d’opération particulier, imbriqués pour constituer la structure du programme. Son interface simple et colorée et son intuitivité en font l’outil parfait pour les plus jeunes créatifs, et un excellent moyen d’appréhender la réflexion logisticienne et mathématique.</p>
<p><img src="img/scratch-ide.png" alt="Capture d'écran du logiciel Scratch"><em>Capture d’écran du logiciel Scratch</em></p>
<p><ins>Le développeur de jeux vidéo indépendant – et d’expériences interactives – Nicky Case travaille en 2017 sur <a href="http://ncase.me/joy-demo/">JOY.js</a>, une interface qui propose de manipuler et visualiser des algorithmes en langage JavaScript grâce à un éditeur de texte interactif et une visualisation en temps réel.<br>
<img src="img/joy-js.png" alt="JOY.js, un outil interactif de manipulation de programmes JavaScript"><br>
</ins></p>
<h3 id="workflow">Workflow</h3>
<p>Les méthodes de travail d’un développeur sont souvent bien maîtrisées. On parle de <em>workflow</em> – “flux de travail” – pour désigner les méthodes d’organisation systématiques qu’il applique afin de fluidifier le processus de programmation et de se prévenir de complications diverses – notamment lorsque d’importantes quantités de données sont manipulées, et que l’erreur humaine peut intervenir à tout moment. Une des solutions les plus couramment appliquées de nos jours et la gestion de version – le <em>versionning</em> en anglais. J’ai déjà mentionné le logiciel <em>git</em>, qui permet d’enregistrer des points clés – des <em>commits</em> – dans l’avancement d’un projet numérique. Pour comprendre la valeur de cette méthode, il faut noter la nature spécifique de l’écriture algorithmique – écriture au sens large de conception et représentation, pas seulement textuelle. À l’image de l’étudiant – ou de l’auteur récompensé – qui écrit un paragraphe d’un écrit, revient en arrière, effectue des modifications le lendemain, réorganise son plan et finit par rayer des parties, le développeur a une écriture non linéaire. Les <em>commits</em> assurent une traçabilité de cette évolution d’un projet dans le temps, et permettent de revenir à une version antérieure lorsque l’on fait fausse route. Les outils de programmation, mais également les plateformes d’hébergement comme GitHub par exemple, permettent de comparer deux versions d’un même extrait de code en visualisant leurs différences, grâce aux <em>diffs</em> : les parties ajoutées sont surlignées en vert, les parties supprimées en rouge.</p>
<p><img src="img/github-diff.png" alt="Visualisation d'un diff sur GitHub"></p>
<p>Par ailleurs, lorsqu’on souhaite aborder une nouvelle fonctionnalité ou une modification majeure au sein d’un projet, on utilise un principe de <em>branches</em> : créer une branche signifie diverger de la version principale, et continuer à travailler sur une version différente. Tout comme on peut revenir en arrière dans son travail grâce aux <em>commits</em>, on peut passer librement de branche en branche, afin de travailler sur des fonctionnalités en parallèle tout en conservant une autonomie totale de chaque branche : indépendantes, elles n’entrent pas en collision les unes entres les autres. Elles peuvent cependant être fusionnées à n’importe quel moment, afin par exemple d’appliquer les modifications apportées par une branche à la version principale du projet. <strong>Les outils de gestion de versions sont donc particulièrement adaptés aux méthodes de travail spécifiques des développeurs, mais qu’en est-il des méthodes de travail du bricodeur ?</strong></p>
<p>Le créatif et le développeur ne travaillent fondamentalement pas de la même manière. Le développeur planifie, procède méthodiquement, cherche des solutions techniques avec un objectif fonctionnel précis. Le créatif quant à lui expérimente, cherche, propose des hypothèses, les abandonne, y revient plus tard. Dans un logiciel de création graphique classique, il crée des formes, les duplique pour les modifier individuellement, déplace, rapproche, réutilise des éléments… Comment le bricodeur pourrait-il s’adapter à la logique de <em>git</em> dans son processus créatif ? Ou, plus intéressant encore, comment la logique de <em>git</em> pourrait s’adapter au processus créatif du bricodeur ? Cette question me laisse imaginer une interface permettant de visualiser différentes versions, différentes propositions envisagées par le créatif, et de naviguer entre elles.</p>
<h1 id="modes-singuliers-de-programmation-algorithmique">Modes singuliers de programmation algorithmique</h1>
<p>Lorsqu’un designer utilise la programmation dans une recherche d’innovation formelle, il adopte une démarche créative qui transcende le matériau qu’est l’écriture algorithmique : le créatif a une pratique singulière du code, ses outils doivent donc être adaptés à cet usage, voire le favoriser.</p>
<h2 id="pratiques-singulières">Pratiques singulières</h2>
<p>?</p>
<h3 id="le-code-auto-modifiant">Le code auto-modifiant</h3>
<p><strong>Et si le code n’était plus seulement <em>clos</em>, modifiable uniquement par l’homme en vue d’un résultat externe, mais qu’il accueillait lui-même un résultat, une modification ?</strong> Qu’adviendrait-il d’un programme capable d’éditer sa propre teneur, avant de s’exécuter à nouveau en prenant en compte les modifications apportées ?</p>
<p><ins>Cette idée m’a inévitablement motivé à réaliser une expérimentation fonctionnelle. C’était sans compter la complexité technique et intellectuelle d’un tel programme, comme l’expliquent Geoff Cox, Alex McLean et Adrian Ward dans un article paru dans <em>Art++</em>, intitulé “<em>Praxis de la programmation : reconsidérer "L’esthétique du code génératif</em>”.</ins></p>
<blockquote>
<p>Dans notre exemple […], un éditeur de texte produit un code qui a la propriété de se modifier lui-même durant son exécution. […] Bien entendu, cela a des répercussions majeures sur l’acte de programmation. Le programmeur doit à présent réfléchir non seulement à ce que le logiciel fera et à la façon dont il interagira, mais aussi à la façon dont il se modifiera tout en restant fonctionnel et actif. Un code qui réfléchit à sa propre création ne peut être considéré comme un simple outil – il est réflexif.<sup class="footnote-ref"><a href="#fn59" id="fnref59">59</a></sup></p>
</blockquote>
<h3 id="langages-ésotériques">Langages ésotériques</h3>
<p><strong>Il existe une catégorie de langages de programmation tout à fait particulière, celle des langages dits “ésotériques”,</strong> parfois appelés langages <em>exotiques</em> – <em>esoteric languages</em> en anglais, ou <em>esolangs</em> dans la forme contractée. Le terme “ésotérique” désigne une forme d’enseignement secret ou hermétique, réservé à des initiés. En effet, qu’ils se présentent comme des œuvres logicielles, des exercices intellectuels ou même de simples plaisanteries<sup class="footnote-ref"><a href="#fn60" id="fnref60">60</a></sup>, ces langages nécessitent une certaine maîtrise antérieure des langages de programmation classiques pour être compris, voire manipulés. Parmi les plus connus se trouve le <em>Brainfuck</em> : en n’employant que 8 caractères distincts, ce langage amène à produire du code particulièrement <em>obfusqué</em>.<sup class="footnote-ref"><a href="#fn61" id="fnref61">61</a></sup> Un autre exemple particulièrement intéressant d’<em>esolang</em> est le Piet, nommé d’après le célèbre peintre néerlandais Piet Mondrian. Ce langage n’est pas textuel mais graphique : les programmes prennent la forme d’images semblables à de l’art abstrait – librement inspiré des travaux du peintre éponyme.</p>
<p><img src="img/esolangs.png" alt="Exemples de langages ésotériques"><em>À gauche : programme en Brainfuck affichant “Hello World!”. Au centre : programme en Piet affichant “Piet”. À droite : programme en Piet affichant “Hello World!”</em></p>
<p><strong>Ici, l’écriture algorithmique n’est plus seulement un outil au service de la création d’une œuvre, mais elle est une œuvre en soi.</strong> D’aucuns affirmeraient que le code étant une production humaine, sa pratique est nécessairement créative, voire artistique : cela soulève des considérations esthétiques.</p>
<h3 id="esthétiques-du-code">Esthétiques du code</h3>
<p><strong>Qu’est-ce que le “beau” code ?</strong></p>
<p><em>Beau</em> code, <em>bon</em> code, code <em>propre</em>… Ces adjectifs font partie du langage du programmeur, mais font référence à un type de “beau” bien précis : on parle ici en réalité de code astucieux, bien pensé, réfléchi. Dans <em>Art++</em>, l’informaticienne Sylvie Tissot est interrogée sur sa définition d’un “beau” programme, elle cite un certain nombre de principes qui permettent d’évaluer la <em>qualité</em> d’un programme : une condition “si” doit toujours être suivie d’un “sinon”, les <em>sorties exceptionnelles</em> – type <em>exit</em> – sont prohibées, la limite d’imbrication de conditions ou de boucles est fixée à 7, etc.</p>
<p>“Beau” code, art génératif et software art</p>
<h3 id="programmation-tangible--la-réflexion-par-la-main">Programmation tangible : la réflexion par la main</h3>
<p>En déportant la réflexion distanciée qu’implique l’usage d’une interface de programmation classique, à une manipulation plus directe, tangible, on permet une nouvelle façon de penser et d’imaginer des options créatives : <strong>on ne pense pas de la même manière avec sa tête ou avec ses mains.</strong></p>
<p>Cette thèse est la genèse d’un projet intitulé <em>Dynamicland</em><sup class="footnote-ref"><a href="#fn62" id="fnref62">62</a></sup>, initié notamment par Bret Victor<sup class="footnote-ref"><a href="#fn63" id="fnref63">63</a></sup>. <em>Dynamicland</em> est un concept d’ordinateur alternatif, nouveau médium informatique collaboratif, où les utilisateurs travaillent à plusieurs en manipulant des objets physiques réels plutôt que des objets virtuels au travers d’écrans.</p>
<blockquote>
<p>Pas d’écrans, pas d’appareils. Simplement des matériaux physiques ordinaires – papier et pâte à modeler, jetons et voitures en plastique – rendus vivants grâce à une technologie dissimulée au plafond. […] Dynamicland est un ordinateur avec lequel on travaille <em>ensemble</em>, en face-à-face, les yeux dans les yeux et avec les mains – beaucoup de mains. […] On pense avec nos mains. On pense avec nos corps. On s’étale, on se déplace, on compare différentes possibilités. On improvise, on expérimente, avec <em>tout</em>.</p>
</blockquote>
<p>Dans le cas de <em>Dynamicland</em>, on manipule des objets, captés par des caméras et reconnus grâce à un système de points colorés : ils sont ainsi interprétés par des algorithmes “classiques”. Si le mode d’interaction est nouveau, la matière algorithmique, dissimulée, n’est pas directement tangibilisée et manipulée. <strong>Quelle forme prendrait un langage de programmation tangible ?</strong> Le collectif d’arts numériques transdisciplinaire <em>[foam]</em> propose une réponse : ils travaillent en 2017 sur une installation nommée “<em>Pattern Matrix</em>”, qui n’est autre qu’un langage de programmation matériel, tangible. Celui-ci a littéralement été créé de toutes pièces : on opère l’installation en tournant une série de “jetons” qui cachent des senseurs magnétiques. Des informations visuelles, sont superposées grâce à la <em>réalité augmentée</em>, permettant de visualiser – et ainsi de comprendre – les états de chaque composant et les échanges qui s’exercent entre eux. Un premier essai du dispositif a été fait dans le cadre d’une performance musicale live à Brighton : bien qu’expérimental et particulièrement singulier, cette interface-outil peut nourrir une pratique créative.<sup class="footnote-ref"><a href="#fn64" id="fnref64">64</a></sup><br>
<img src="img/pattern-matrix.png" alt="Pattern Matrix, un langage de programmation tangible"></p>
<p><ins>Je me suis interrogé sur la nature qu’aurait une interface de programmation “hors de l’écran”, au travers d’une expérimentation mettant en jeu la manipulation : en utilisant la surface tactile d’un smartphone, et en transmettant les données en temps réel à un ordinateur connecté, un algorithme de reconnaissance de formes permet de comprendre une forme “tracée” du doigt, et attribuée à une fonction précise. Par exemple, le dessin d’une boucle peut faire apparaître une boucle itérative dans le code, ou l’exécuter de façon éphémère. On peut également faire réagir des variables ou des objets virtuels grâce à cette interaction : modification d’une valeur, déplacement dans un espace en deux ou trois dimensions. On peut également tirer parti des fonctionnalités technique du smartphone, notamment l’accéléromètre et le gyroscope. L’appareil devient alors une extension de l’interface de programmation, tel une télécommande programmable. J’ai réalisé une preuve de concept que je souhaite approfondir par la suite.</ins></p>
<h2 id="modes-de-représentations">Modes de représentations</h2>
<p><strong>Les différents modes de représentation des algorithmes permettent donc de s’emparer de la programmation comme matière.</strong> Quels écarts de perception existent entre la lecture d’un algorithme au sein d’un éditeur de texte, la visualisation de sa transcription visuelle, ou encore la manipulation, simulée ou tangible, de celui-ci ? En quoi l’attitude du créatif varie-t-elle selon ces cas ?</p>
<h3 id="représenter-visuellement-les-algorithmes">Représenter visuellement les algorithmes</h3>
<p><strong>La représentation visuelle d’un processus algorithmique permet d’appréhender l’algorithme en question d’une manière plus intuitive, car sensorielle, que dans le cas d’une lecture réfléchie du code.</strong> Dans le monde scientifique et informatique, c’est un véritable exercice de style. Ces visualisations permettent en effet de comprendre en profondeur la démarche et l’efficacité d’un algorithme pour répondre à un problème donné : génération aléatoire de points dans un espace, tri de données<sup class="footnote-ref"><a href="#fn65" id="fnref65">65</a></sup>, <em>pathfinding</em> – recherche du chemin le plus rapide entre deux points –, etc. Le designer de visualisations Michael Bostock illustre ces exemples au sein d’un article intitulé <a href="https://bost.ocks.org/mike/algorithms/"><em>Visualizing Algorithms</em></a>. Il cite en introduction le professeur en sciences cognitives Donald Norman, qui témoigne de l’importance de ces outils qui “aident” à la compréhension :</p>
<blockquote>
<p>Les capacités de l’esprit sans aide extérieure sont fortement surestimées. Les facultés réelles proviennent de la conception d’aides externes qui améliorent les capacités cognitives.</p>
</blockquote>
<p>Dans un essai intitulé “<em>Learnable Programming</em>”<sup class="footnote-ref"><a href="#fn66" id="fnref66">66</a></sup>, Bret Victor réfléchit au design de systèmes de programmation permettant de mieux comprendre les programmes. Il introduit son propos avec une théorie qui rejoint celle de Donal Norman :</p>
<blockquote>
<p><strong>On comprend ce que l’on peut voir.</strong> Si un programmeur ne peut pas voir ce qu’un programme est en train de faire, il ne peut pas le comprendre.</p>
</blockquote>
<p>Cet essai est donc construit autour d’une question au cœur de mon sujet : <strong>comment peut-on <em>voir</em> ce que l’on code, au moment exact où on le code ?</strong></p>
<h3 id="représenter-au-sein-de-lide">Représenter au sein de l’IDE</h3>
<p>Dans une conférence donnée au <abbr title="The Canadian University Software Engineering Conference">CUSEC</abbr> de 2012, Bret Victor dénonce le délai, qui, dans un processus créatif, peut séparer l’apparition d’une idée et sa matérialisation.</p>
<blockquote>
<p>Il est essentiel, dans un processus créatif, de pouvoir essayer une idée à l’instant où l’on y pense. S’il y a le moindre délai dans cette boucle de <em>feedback</em> [retour d’information] entre la conception d’une chose, sa visualisation et sa réalisation, alors un monde entier d’opportunités créatives disparaît. <em>Ce sont des pensées que l’on ne peut penser</em>.<sup class="footnote-ref"><a href="#fn67" id="fnref67">67</a></sup></p>
</blockquote>
<p>Pour illustrer son propos, Bret Victor prend l’exemple d’un dessin algorithmique, programmé en JavaScript et restitué visuellement dans un <em>canvas</em> – une toile numérique – au sein d’un explorateur web.</p>
<blockquote>
<p>Voici comment fonctionne la programmation : vous tapez un tas de code dans un éditeur de texte, en essayant d’imaginer ce que chaque ligne de code va faire. Puis, vous compilez et exécutez ce code, et quelque chose en sort. […] Mais s’il y a une erreur, ou si vous souhaitez faire des modifications, vous devez retourner dans le code, le modifier, compiler et exécuter à nouveau, et voir à quoi il ressemble. La majeure partie de ce processus se passe dans l’éditeur, où l’on travaille <em>aveuglément</em>, sans connexion immédiate avec ce que l’on cherche réellement à produire.</p>
</blockquote>
<p>Bret Victor dénonce ici ce que l’on pourrait qualifier de “niveau zéro” de la créativité algorithmique : <strong>lorsque la conception et la réalisation d’une œuvre implique de passer constamment du code au résultat, cela impose un délai dans le <em>feedback</em>, et la créativité en est fortement diminuée.</strong> Il propose donc une interface binaire, scindée verticalement : à gauche le résultat, à droite l’éditeur de texte avec le programme. Lorsqu’on modifie une ligne ou une valeur dans le code, le résultat est directement visible, en temps réel – en cela, sa proposition ressemble beaucoup à Processing. L’expérience de la programmation est améliorée, facilitée : on est au “niveau un”. Un autre exemple pourrait être celui de la superposition du code et du résultat, comme le propose <a href="https://github.com/fand/vedajs">VedaJS</a>, un <em>framework</em><sup class="footnote-ref"><a href="#fn68" id="fnref68">68</a></sup> adapté à la création de <em>shaders</em> – images de synthèse simulant graphiquement de la lumière, des textures et des animations.</p>
<h3 id="manipuler-au-sein-de-lide">Manipuler au sein de l’IDE</h3>
<p>Mais Bret Victor va plus loin que la simple juxtaposition du programme et du résultat produit. Pour simplifier l’édition des valeurs – notamment chiffrées – utilisées dans un algorithme, il propose un nouveau type d’interaction : au lieu de devoir effacer des caractères pour les remplacer, chaque valeur devient <em>draggable</em> – on peut cliquer et déplacer la souris en maintenant le clic appuyé, et c’est ce geste qui permet de faire évoluer ces variables. Sur un dessin représentant un arbre, cette interaction appliquée à une variable liée au positionnement des feuilles permet de révéler une opportunité d’animation : en faisant varier en continu une valeur, les feuilles semblent s’agiter comme si le vent soufflait, et Bret Victor souligne l’apparition d’un nouveau champ de possibles créatifs : “comment aurais-je découvert cela si j’avais dû compiler et exécuter le code entre chaque changement ?”.</p>
<p>Bret Victor propose énormément d’autre interventions au sein d’outils de programmation dans sont essai “<em>Learnable Programming</em>”, ponctué d’expérimentations démonstratives. Il conçoit de nombreuses fonctionnalités et autant d’interactions liées :</p>
<ul>
<li>exploration de l’exécution du programme à chaque étape grâce à un <em>slider</em> ;</li>
<li>visualisation de l’évolution dans le temps du programme, via un tracé transparent symbolisant l’état d’un objet à chaque instant, ainsi qu’une <em>timeline</em> – frise chronologique – interactive ;</li>
<li>mise en évidence les parties de l’algorithme liées à une zone précise du résultat en la pointant, et inversement ;</li>
<li>complétion automatique des expressions et fonctions fréquentes, avec valeurs par défaut, et accès rapide par des boutons ;</li>
<li>création de fonctions intelligentes et mise en relations des variables par <em>drag and drop</em> – glisser-déposer ;</li>
<li>et bien d’autres micro-interactions à découvrir dans son article illustré.</li>
</ul>
<p>Ces interactions concordent avec deux observations énoncées plus haut : on comprend ce que l’on peut voir, mais on comprend aussi ce que l’on peut manipuler. Et c’est précisément en <em>comprenant</em> le comportement de son programme que le bricodeur gagne un plus grand contrôle sur le résultat qu’il cherche à produire : en quelque sorte, l’outil est là pour lui simplifier la tâche.</p>
<h2 id="la-dualité-dans-lexpérience-de-loutil">La dualité dans l’expérience de l’outil</h2>
<p>Grille de lecture des typologies d’interfaces :</p>
<ul>
<li>interface qui se rapproche : s’adapte, simplifie, rend plus efficace</li>
<li>interface qui s’éloigne : nous déplace, incite, invite</li>
</ul>
<p>Comment les outils conditionnent le travail</p>
<p>Comment faciliter et encourager l’intégration de processus algorithmiques dans une pratique créative ? Deux réponses : interfaces qui se rapprochent pour favoriser la maîtrise, et interfaces qui s’éloignent pour nourrir la créativité.</p>
<h3 id="loutil-se-rapprochant">L’outil se rapprochant</h3>
<h3 id="loutil-séloignant">L’outil s’éloignant</h3>
<h1 id="conclusion">Conclusion</h1>
<h1 id="ressources">Ressources</h1>
<h2 id="bibliographie">Bibliographie</h2>
<p><cite>1</cite></p>
<p><cite>2</cite></p>
<p><cite>3</cite></p>
<p><cite>6</cite></p>
<p><cite>7</cite></p>
<p><cite>8</cite></p>
<p><cite>9</cite></p>
<p><cite>10</cite></p>
<p><cite>11</cite></p>
<p><cite>12</cite></p>
<p><cite>13</cite></p>
<h2 id="webographie">Webographie</h2>
<p><cite>14</cite></p>
<p>Dépôt <a href="https://github.com/tayllan/awesome-algorithms"><em>Awesome Algorithms</em></a> de Tayllan Búrigo, liste collaborative, GitHub</p>
<hr>
<h3 id="état-de-lart">État de l’art</h3>
<p>Distinguer catégories :</p>
<ul>
<li>Atom, Sublime text</li>
<li>Visual Studio</li>
<li>Dreamweaver ?</li>
<li>Processing</li>
<li>Scratch</li>
<li>Programmation visuelle (flowcharts)</li>
<li>Programmation tangible</li>
<li>IDE Bret Victor</li>
<li>etc.</li>
</ul>
<p>Critères : efficacité (shortcuts, auto-complétion…), personnalisation (plugins, “hackabilité”), flexibilité (un ou plusieurs langages), “manipulation” (déplacer, connecter), visualisation, objectif (développement/apprentissage/dessin…), etc.</p>
<p>Trouver quelques exemples pertinents pour chaque aspect</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>Serge Abiteboul et Gilles Dowek sont chercheurs à l’<abbr title="Institut national de recherche en informatique et en automatique">INRIA</abbr> et professeurs à l’<abbr title="École normale supérieure">ENS</abbr> de Paris-Saclay. <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p><cite>1:11</cite> <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>La recherche par force brute (<em>brute force</em> en anglais), aussi connue sous le nom “générer et tester” est une technique générale de résolution de problème qui consiste à énumérer tous les candidats possibles à une solution et vérifier chacun d’eux afin de déterminer lequel répond le mieux au problème. <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>Le sociologue français Dominique Cardon propose une classification des typologies d’algorithmes qui régissent notre quotidien – notamment sur le web. Il distingue quatre familles, qu’il illustre spatialement : “les mesures peuvent se trouver <em>à côté</em>, <em>au-dessus</em>, <em>dans</em> ou <em>en dessous</em> des données numériques”. <cite>2:17–18</cite> <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p>Le <em>creative coding</em> – ou “code créatif” – est un type de programmation informatique où les langages de programmation sont employés à des fins d’innovation expressive – souvent esthétique – plutôt que fonctionnelle. <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p><cite>11</cite> <a href="#fnref6" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn7" class="footnote-item"><p><cite>12:29–30</cite> <a href="#fnref7" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn8" class="footnote-item"><p><cite>12:27</cite> <a href="#fnref8" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn9" class="footnote-item"><p>Le <abbr title="Massachusetts Institute of Technology">MIT</abbr> est un institut de recherche américain spécialisé dans les domaines de la science et de la technologie. <a href="#fnref9" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn10" class="footnote-item"><p><em>Design by Numbers</em>, (parfois noté DBN), est une expérimentation logicielle menée par John Maeda et ses étudiants du MIT en 1999. Il s’agit d’un outil de conception graphique par le code : les choix (formes, tracés, positionnements…) sont matérialisés par une succession d’instructions algorithmiques. <a href="#fnref10" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn11" class="footnote-item"><p><em>Processing</em> est un langage de programmation intégré à un IDE (voir <a href="#environnements-de-d%C3%A9veloppement-et-workflow">Environnements de développement</a>), initié au MIT en 2001 par Casey Reas et Ben Fry – deux élèves de John Maeda. <a href="#fnref11" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn12" class="footnote-item"><p><cite>10:10–11</cite> <a href="#fnref12" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn13" class="footnote-item"><p><cite>13:25</cite> <a href="#fnref13" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn14" class="footnote-item"><p>Étymologiquement, le terme <em>algorithme</em> est d’ailleurs issu de la combinaison du mot grec <em>arithmos</em>, qui signifie “nombre”, et du mot latin <em>algorismus</em>, dérivé du nom du mathématicien Al-Khwarizmi – scientifique perse du VII<sup>ème</sup> siècle, auteur d’un ouvrage classifiant les procédés algébriques de son époque. <a href="#fnref14" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn15" class="footnote-item"><p>Le terme <em>abaque</em> désigne tout instrument mécanique plan facilitant le calcul. <a href="#fnref15" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn16" class="footnote-item"><p>Blaise Pascal était un mathématicien, physicien, inventeur et philosophe français. À 19 ans, il invente la première machine à calculer, dénommée <em>machine d’arithmétique</em>, puis <em>pascaline</em>. <a href="#fnref16" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn17" class="footnote-item"><p>Gottfried Leibniz était un philosophe, scientifique, mathématicien et logicien allemand. <a href="#fnref17" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn18" class="footnote-item"><p>Le <em>bit</em>, abréviation de <em>binary digit</em> (chiffre binaire) est l’unité d’information la plus basique : un chiffre binaire ne peut avoir que deux valeurs, et ainsi être représenté avec un dispositif à deux états. Ces valeurs d’états sont le plus souvent représentés comme 0 ou 1. <a href="#fnref18" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn19" class="footnote-item"><p>Charles Babbage était un mathématicien et inventeur britannique du XIX<sup>ème</sup> siècle. Il fut l’un des principaux précurseurs de l’informatique. <a href="#fnref19" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn20" class="footnote-item"><p><a href="https://fr.wikipedia.org/wiki/Machine_analytique#Description_et_fonctionnement">Machine analytique – Description et fonctionnement</a> sur Wikipédia <a href="#fnref20" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn21" class="footnote-item"><p>En mathématiques, les nombres de Bernoulli constituent une suite de nombres rationnels. Ces nombres ont d’abord été étudiés par Jacques Bernoulli, mathématicien et physicien suisse du XVII<sup>ème</sup>siècle. <a href="#fnref21" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn22" class="footnote-item"><p>Alan Turing était un mathématicien et cryptologue britannique, dont les travaux ont fondé l’informatique moderne. Après l’invention de la machine de Turing – qui contribue à la thèse de Church-Turing autour de la notion de problème <em>calculable</em> –, il participe au décryptage des codes secrets de la machine allemande Enigma pendant la Seconde Guerre Mondiale – ce qui joua un rôle essentiel dans la victoire des Alliés. Turing poursuit des recherches en informatique et formule le “test de Turing”, fondamental dans le champ de l’intelligence artificielle. <a href="#fnref22" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn23" class="footnote-item"><p><cite>3:16–18</cite> <a href="#fnref23" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn24" class="footnote-item"><p><a href="https://fr.wikipedia.org/wiki/Architecture_de_von_Neumann#Architecture">Architecture de von Neumann</a> sur Wikipédia <a href="#fnref24" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn25" class="footnote-item"><p>La recherche dans ce domaine ne date pas d’il y a quelques années ou même du début du siècle : depuis 70 ans déjà, la thèse de Turing – suggérant qu’une machine pouvait simuler n’importe quel processus de raisonnement formel à partir de symboles binaires – a amené de nombreux chercheurs en neurologie, informatique et cybernétique à considérer la possibilité de créer un cerveau artificiel. <a href="#fnref25" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn26" class="footnote-item"><p>Allen Newell, Herbert Simon, John McCarthy, Marvin Minsky et Arthur Samuel furent les fondateurs de cette science nouvelle, née en 1956. Leurs premiers travaux rencontrèrent un immense succès dans la presse : leurs ordinateurs étaient capables de gagner au jeu de dames contre des humains, de résoudre des problèmes algébriques énoncés textuellement, ou encore de parler anglais. <a href="#fnref26" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn27" class="footnote-item"><p>L’évolution des performances de notre matériel informatique joue également un rôle essentiel. Les lois de Moore caractérisent cette croissance par le fait que la quantité de transistors pour un espace donné au sein d’un microprocesseur double approximativement tous les deux ans. <a href="#fnref27" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn28" class="footnote-item"><p>Pour comprendre en détail le fonctionnement d’un réseau neuronal, visionner la playlist <a href="https://www.youtube.com/watch?v=aircAruvnKk">Neural Networks</a> de <em>3Blue1Brown</em> sur YouTube <a href="#fnref28" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn29" class="footnote-item"><p><cite>6:104, 110–119</cite> <a href="#fnref29" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn30" class="footnote-item"><p><cite>1:18–19</cite> <a href="#fnref30" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn31" class="footnote-item"><p>Un booléen est un type de variable à deux états. Cette terminologie fait référence aux travaux de George Boole, célèbre logicien et mathématicien  britannique, qui en 1845 a établit les bases de la “logique booléenne”, n’acceptant que deux valeurs numériques : 0 et 1. Cet algèbre connaîtra une importance capitale dans l’informatique et est encore énormément employée de nos jours. <a href="#fnref31" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn32" class="footnote-item"><p><cite>7:15</cite> <a href="#fnref32" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn33" class="footnote-item"><p><cite>7:26</cite> <a href="#fnref33" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn34" class="footnote-item"><p><cite>8:7–8</cite> <a href="#fnref34" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn35" class="footnote-item"><p>La notion de “signifiant et signifié” a été théorisée par le linguiste suisse Ferdinand de Saussure dans son ouvrage “<em>Cours de linguistique générale</em>”. Tel qu’il les définit, le <em>signifié</em> désigne le concept, et le <em>signifiant</em> désigne l’image sonore : de Saussure exclut donc les autres formes de représentation – graphique, gestuelle, etc. <a href="#fnref35" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn36" class="footnote-item"><p><a href="http://classes.bnf.fr/dossiecr/sys-ecri.htm">“<em>Les systèmes d’écriture</em>”</a> sur <abbr title="Bibliothèque Nationale de France">BNF</abbr> <a href="#fnref36" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn37" class="footnote-item"><p>Voici une liste non exhaustive énumérant quelques grandes catégories de genre littéraires : poétiques (poésies, poèmes, haïkus, chansons mais aussi calligrammes), narratifs (romans, comptes, nouvelles, biographie), théâtraux (pièces de théâtre de tous registres), épistolaires (constitués de lettres échangées), argumentatifs (essais, pensées ou même pamphlets), graphiques (roman graphique, bande dessinée), ou encore formes brèves (proverbes, aphorisme, énigme, blague, etc.) <a href="#fnref37" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn38" class="footnote-item"><p><cite>8:10</cite> <a href="#fnref38" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn39" class="footnote-item"><p>Le groupe µ – prononcer “mu” – est un collectif interdisciplinaire de chercheurs en linguistique, sociologie ou encore sémiotique, fondé en 1967. <a href="#fnref39" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn40" class="footnote-item"><p>Les auteurs décrivent quatre opérations fondamentales qui peuvent constituer une métabole : l’addition, la suppression, la substitution ou la permutation d’unités phonétiques ou morphologiques. Il la distingue d’une autre catégorie appelée “<em>iconographies nouménalisantes et explicatives</em>” parmi lesquelles il compte notamment la représentation des molécules en chimie, ou le dessin des volumes géométriques. <a href="#fnref40" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn41" class="footnote-item"><p>Voir quelques exemples visuels et animés sur le site <a href="http://code-poetry.com/"><em>./code --poetry</em></a> <a href="#fnref41" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn42" class="footnote-item"><p><a href="https://fr.wikipedia.org/wiki/Programme_informatique">Programme informatique</a> sur Wikipédia <a href="#fnref42" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn43" class="footnote-item"><p><cite>3:46</cite> <a href="#fnref43" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn44" class="footnote-item"><p><cite>4</cite> <a href="#fnref44" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn45" class="footnote-item"><p><a href="https://fr.wikipedia.org/wiki/What_you_see_is_what_you_get"><em>What you see is what you get</em></a> sur Wikipédia <a href="#fnref45" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn46" class="footnote-item"><p><cite>5</cite> <a href="#fnref46" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn47" class="footnote-item"><p><cite>3:67</cite> <a href="#fnref47" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn48" class="footnote-item"><p>Voir une <a href="https://twitter.com/Ashugeo/status/927947488950177793">démonstration en vidéo du prototype “<em>text2code</em>”</a> sur Twitter, et les réponses à ce tweet : certains de mes contacts se sont emparé de mon expérimentation pour produire leur propre proposition. <a href="#fnref48" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn49" class="footnote-item"><p><a href="https://fr.wikipedia.org/wiki/Liste_de_langages_de_programmation">Liste de langages de programmation</a> sur Wikipédia <a href="#fnref49" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn50" class="footnote-item"><p><a href="https://stackoverflow.com">Stack Overflow</a> est une plateforme web où chacun peut poser des questions ou apporter des réponses sur de nombreux de thèmes liés à la programmation informatique. Il fait partie du réseau de sites Stack Exchange, qui intègre de nombreux services basés sur le même principe d’entraide communautaire, dans des disciplines variées. <a href="#fnref50" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn51" class="footnote-item"><p><a href="https://stackoverflow.blog/2015/07/29/why-are-there-so-many-programming-languages/">“<em>Why are there so many programming languages?</em>”</a> sur StackOverflow <a href="#fnref51" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn52" class="footnote-item"><p>Quelques exemples : la programmation <em>orientée objet</em>, où l’on considère le programme comme une collection d’<em>objets</em> en interaction ; la programmation <em>procédurale</em> qui fait appel à une suite de <em>fonctions</em> ; la programmation <em>déclarative</em> qui consiste à déclarer les données d’un problème puis à le faire résoudre par le programme ; etc. On remarquera que certains langages mêlent plusieurs paradigmes : le JavaScript par exemple, créé en 1995 et aujourd’hui un des plus présents notamment sur le web, est multi-paradigme – il est à la fois orienté objet, impératif et déclaratif. <a href="#fnref52" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn53" class="footnote-item"><p><a href="https://octoverse.github.com/">GitHub Octoverse 2017</a> <a href="#fnref53" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn54" class="footnote-item"><p>GitHub est une plateforme d’hébergement de gestion de versions collaborative. Basé sur le logiciel <em>git</em>, qui permet d’enregistrer des versions de son travail à différentes étapes de l’avancement du projet, GitHub est communautaire et chacun peut dupliquer le code d’autrui – si celui-ci est <em>ouvert</em>, ou <em>open-source</em> –, y apporter des modifications ou des remarques. <a href="#fnref54" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn55" class="footnote-item"><p><cite>9:395</cite> <a href="#fnref55" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn56" class="footnote-item"><p>Le choix entre espaces et tabulations pour l’indentation est depuis de nombreuses années sujet à débats dans la sphère informatique, chaque option ayant son lot d’avantages et d’inconvénients. Des tendances statistiques s’observent selon le langage utilisé, comme le montre <a href="https://ukupat.github.io/tabs-or-spaces/">une recherche menée sur GitHub</a>. <a href="#fnref56" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn57" class="footnote-item"><p><cite>3:39</cite> <a href="#fnref57" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn58" class="footnote-item"><p>Les plus connus sont le <em>camelCase</em>, le <em>PascalCase</em> et le <em>snake_case</em>, dont les intitulés même illustrent leur principe : des capitales au début de chaque mot – incluant ou non le premier –, ou des <em>underscores</em> entre les mots. <a href="#fnref58" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn59" class="footnote-item"><p><cite>11:86–87</cite> <a href="#fnref59" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn60" class="footnote-item"><p>Le site <a href="http://esoteric.codes/">esoteric.codes</a> regroupe plusieurs exemples créatifs mettant en jeu des langages ésotériques. <a href="#fnref60" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn61" class="footnote-item"><p>En programmation, “obsfuquer” signifie rendre un programme illisible, en transformant notamment le nom des variables afin de rendre la structure globale de l’algorithme incompréhensible et inexploitable. <a href="#fnref61" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn62" class="footnote-item"><p>Voir les vidéos sur le site <a href="https://dynamicland.org/">Dynamicland</a>. <a href="#fnref62" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn63" class="footnote-item"><p>Bret Victor est un designer d’interaction et informaticien, dont le travail porte notamment sur les outils et les interfaces permettant de comprendre et de créer. <a href="#fnref63" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn64" class="footnote-item"><p><a href="https://fo.am/blog/2017/11/27/pattern-matrix-algomech2/">“<em>How to design a tangible programming language</em>”</a> sur <em>[foam]</em> <a href="#fnref64" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn65" class="footnote-item"><p>Les méthodes de tri – <em>sorting algorithms</em> – les plus connues sont illustrées sous forme d’animations sur la page <a href="https://www.toptal.com/developers/sorting-algorithms"><em>Sorting Algorithms Animations</em></a> du site d’offre d’emplois <em>toptal</em>. <a href="#fnref65" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn66" class="footnote-item"><p><cite>14</cite> <a href="#fnref66" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn67" class="footnote-item"><p><a href="https://vimeo.com/36579366">Bret Victor - Inventing on Principle</a> sur Vimeo <a href="#fnref67" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn68" class="footnote-item"><p>Un <em>framework</em>, ou “cadre de travail”, désigne un ensemble d’outils de programmation structurant les bases techniques et architecturales d’un projet. <a href="#fnref68" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

    </div>
  </div>
</body>

</html>
